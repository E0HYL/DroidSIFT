package mySoot;

import mySoot.util.*;

import java.io.File;
import java.io.PrintWriter;
import java.util.*;

import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Targets;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.util.Chain;
import soot.util.HashChain;
import soot.jimple.*;
import soot.*;
import soot.jimple.internal.*;
import soot.tagkit.*;

public class CallGraphTransformer extends SceneTransformer {
	
	public static boolean ANALYZE = false;
	public static boolean CFG = false;
	public static boolean REACH_DEF = false;
	public static boolean DATAFLOW = false;
	public static boolean INSTRUMENT = false;
	public static boolean OPTIMIZE = false;
	public static boolean O1 = false;
	public static boolean O2 = false;
	public static boolean O3 = false;
	public static boolean O4 = false;

	//taint tags
	//static final int FROM_USER = 0;
	//static final int FROM_CONTACTS = 1;
	
	//need fix
	/*
	static TaintTag[] taintTags = new TaintTag[]{
		//new TaintTag(MyConstants.SL_FW_FROM_USER),
		//new TaintTag(MyConstants.SL_FW_FROM_CONTACTS)
	};
	static TaintTag[] extraDefTags = new TaintTag[]{
		//new TaintTag(MyConstants.SL_FW_FROM_USER),
		//new TaintTag(MyConstants.SL_FW_FROM_CONTACTS)
	};
	static int taintCount = 0;
	*/
	
	static LinkedHashMap<String, TaintTag> taintTagMap = new LinkedHashMap<String, TaintTag>();
	static LinkedHashMap<String, TaintTag> extraDefTagMap = new LinkedHashMap<String, TaintTag>();
	static LinkedHashMap<TaintTag, String> taintTagReverseMap = new LinkedHashMap<TaintTag, String>();
	static LinkedHashMap<TaintTag, String> extraDefTagReverseMap = new LinkedHashMap<TaintTag, String>();
	
	static TaintTag generalTaintTag = new TaintTag(1);
	static TaintTag instrumentationTag = new TaintTag(2);
	static TaintTag generalExtraDefTag = new TaintTag(3);
	static TaintTag wrapperBeginTag = new TaintTag(4);
	static TaintTag wrapperEndTag = new TaintTag(5);
	static TaintTag invokeWrapperTag = new TaintTag(6);
	static TaintTag beforeWrapperTag = new TaintTag(7);
	static TaintTag afterWrapperTag = new TaintTag(8);
	static TaintTag initTaintTag = new TaintTag(9);
	static TaintTag checkTaintTag = new TaintTag(10);
	static TaintTag referenceTag = new TaintTag(11);
	static TaintTag initialLocalTag = new TaintTag(12);
	
	static TaintTag isWrapperTag = new TaintTag(126);
	static TaintTag wrapperMethodTag = new TaintTag(127);
	static TaintTag referenceRelatedTag = new TaintTag(128);
	static TaintTag taintStaticTag = new TaintTag(129);
	static TaintTag equivTag = new TaintTag(130);
	
	static TaintTag debuggingTag = new TaintTag(1023);
	
	//security labels
	static SecurityLabel securityLabel = new SecurityLabel(0);
	
	private CallGraph cg;
	
	//private static List<SootField> usedStaticFields = new ArrayList<SootField>();
	//private static List<SootField> usedInstanceFields = new ArrayList<SootField>();
	
	private static LinkedHashMap<SootField, Vector<Integer>> usedStaticFieldMap = new LinkedHashMap<SootField, Vector<Integer>>();
	private static LinkedHashMap<SootField, Vector<Integer>> usedInstanceFieldMap = new LinkedHashMap<SootField, Vector<Integer>>();
	private static int sourceCount = 0;
	//private static int sinkCount = 0;
	
	private static LinkedHashMap<SootMethod, Vector<Integer>> sMethodsWithSources = new LinkedHashMap<SootMethod, Vector<Integer>>();
		
	private static List<SootField> taintedStaticFields = new ArrayList<SootField>();
	private static List<SootField> taintedFieldsInCallee = new ArrayList<SootField>();
	private static List<SootField> taintedFieldsInCaller = new ArrayList<SootField>();
	private static List<String> sinks = new ArrayList<String>();
	private static List<String> srcs = new ArrayList<String>();
	private static LinkedHashMap<SootMethod, LinkedHashMap<Stmt, List<Stmt>>> methodToEquiv 
		= new LinkedHashMap<SootMethod, LinkedHashMap<Stmt, List<Stmt>>>();
	
	private static Stack<SootMethod> callString = new Stack<SootMethod>();
	
	private static LinkedHashMap<String, List<Integer>> propagationHistory 
		= new LinkedHashMap<String, List<Integer>>();
	
	public static LinkedHashMap<String, LinkedHashMap<String, List<String>>> methodToSourceToVar
		= new LinkedHashMap<String, LinkedHashMap<String, List<String>>>();
	
	public static LinkedHashMap<String, LinkedHashMap<String, List<String>>> classToSourceToField
		= new LinkedHashMap<String, LinkedHashMap<String, List<String>>>();
	
	public static LinkedHashMap<String, List<String>> methodToTaintVar = new LinkedHashMap<String, List<String>>();
	public static LinkedHashMap<String, List<String>> classToTaintField = new LinkedHashMap<String, List<String>>();
	
	public static long O4Time = 0;
	
	public CallGraphTransformer(){
		LinkedHashMap<String, Integer> sources = CallGraphExample.sources;
		//LinkedHashMap<String, Integer> sinks = CallGraphExample.sinks;
		
		Set<String> srcKeySet = sources.keySet();
		Iterator<String> srcIter = srcKeySet.iterator();
		while(srcIter.hasNext()){
			String src = srcIter.next();
			if(!taintTagMap.containsKey(src)){			
				TaintTag tag = new TaintTag(sources.get(src).intValue());
				taintTagMap.put(src, tag);
				taintTagReverseMap.put(tag, src);
			}
			if(!extraDefTagMap.containsKey(src)){			
				TaintTag tag = new TaintTag(sources.get(src).intValue());
				extraDefTagMap.put(src, tag);
				extraDefTagReverseMap.put(tag, src);
			}
			sourceCount++;
		}
	}
	
	
	@Override
	protected void internalTransform(String string, Map map) {
		CallGraph cg = Scene.v().getCallGraph();
		this.cg = cg;
		// System.out.println(cg);
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				Iterator targets = new Targets(cg.edgesOutOf(method));
				while (targets.hasNext()) {
					SootMethod target = (SootMethod) targets.next();
					System.out.println(method + " may call " + target);
				}
			}
		}
		
		//doControlFlowAnalysis();
		
		long runtime = 0;
		
		
		buildSinkList();
		//System.out.println("[Sinks]" + sinks);
		
		buildSrcList();
		
		buildEquivTables();
		
		//dumpEquivTables();
		
		//if(ANALYZE == true){
		if(true){

			runtime = System.currentTimeMillis();
			doDataFlowAnalysis();
			
			if(!MyConstants.COUNT_LOC){
				dumpTaintedFieldsAndVariables();
			}
			
			runtime = System.currentTimeMillis() - runtime;
			System.out.println("Analysis TIME: " + runtime);
			
			dumpAllInstructions();
			System.out.println("Chop LOC: " + countChopLOC());
			
			
			//if(MyConstants.instrument == true){
			//if(INSTRUMENT == true){
			if(true){
				addTaintFields();
				
				addWrappers();
				addQueryMethod();
				
				runtime = System.currentTimeMillis();
				doInstrumentation();
				runtime = System.currentTimeMillis() - runtime;
				System.out.println("Instru TIME: " + runtime);
				
				dumpAllInstructions();				
				System.out.println("Instru LOC: " + countLOC());
				
				traceMethods();
				
				
				//if(MyConstants.optimize == true){
				//if(OPTIMIZE == true){
				if(true){
					
					//dumpOneMethod("<com.flurry.android.FlurryAgent: void fWrapper(com.flurry.android.BoolWrapper)>");
					//dumpOneMethod("<com.flurry.android.FlurryAgent: byte[] eWrapper(com.flurry.android.BoolWrapper, com.flurry.android.BoolWrapper)>");
					
					if(O1==true){
						
						runtime = System.currentTimeMillis();
						doOptimization1();
						runtime = System.currentTimeMillis() - runtime;
						System.out.println("O1 TIME: " + runtime);
						
						//dumpAllInstructions();
						System.out.println("O1 LOC: " + countLOC());
					}
					
					//dumpOneMethod("<com.flurry.android.FlurryAgent: byte[] eWrapper(com.flurry.android.BoolWrapper, com.flurry.android.BoolWrapper)>");
					//dumpAllInstructions();
					dumpOneMethod("<com.akbur.mathsworkout.model.BrainCruncherQuestion: void generateAdditionQuestionWrapper(int,int,com.akbur.mathsworkout.model.BoolWrapper,com.akbur.mathsworkout.model.BoolWrapper,com.akbur.mathsworkout.model.BoolWrapper)>");
					
					if(O1==true && O2==true){
						
						runtime = System.currentTimeMillis();
						doOptimization2();
						runtime = System.currentTimeMillis() - runtime;
						System.out.println("O2 TIME: " + runtime);
						
						//dumpAllInstructions();
						System.out.println("O2 LOC: " + countLOC());
					}
					
					//dumpOneMethod("<com.flurry.android.FlurryAgent: void fWrapper(com.flurry.android.BoolWrapper)>");
					//dumpAllInstructions();
					dumpOneMethod("<com.akbur.mathsworkout.model.BrainCruncherQuestion: void generateAdditionQuestionWrapper(int,int,com.akbur.mathsworkout.model.BoolWrapper)>");
					
					if(true){
					if(O1==true && O2==true && O3==true){
						
						runtime = System.currentTimeMillis();
						doOptimization3();
						runtime = System.currentTimeMillis() - runtime;
						System.out.println("O3 TIME: " + runtime);
						
						dumpAllInstructions();
						System.out.println("O3 LOC: " + countLOC());
					}
					}
					
				}
				
				secretUglyFix();
				
				removeConstructorWrapper();
			
				O4Time = System.currentTimeMillis();
			}
		
		}

	}	
	
	private void secretUglyFix(){
		//com.myyearbook.m
		uglyFix("<com.myyearbook.m.Utils.BroadcastReceiver: void onReceive(android.content.Context,android.content.Intent)>");
		uglyFix("<com.adwhirl.adapters.AdSenseAdapter: void handle()>");
		
		//findastarbucks
		uglyFix("<crittercism.android.h: java.lang.String aWrapper(org.apache.http.client.methods.HttpRequestBase)>", "r1_t");
		
		//howtotie
		uglyFix("<com.flurry.android.v: void aWrapper(com.flurry.android.v,android.content.Context,java.lang.String)>", "r2_t");
		
		
		//edj: com.scoreloop.client.android.core.model.a tmp29
		//uglyFixClass("com.scoreloop.client.android.core.model.a", "tmp29");
		//uglyFixClass("com.scoreloop.client.android.core.model.a", "tmp31");
		uglyFixClass("com.scoreloop.client.android.core.model.a");
		
		//maxdroid.christmas
		uglyFix("<com.applovin.impl.notifications.AppLovinBarNotificationFactoryImpl: android.app.Notification createNotification(com.applovin.notifications.AppLovinPictureNotificationMessage,android.content.Context)>");
		uglyFix("<com.XvSLjMTQ.DlPUdJFn64038.Airpush: void <init>(android.content.Context)>");
		
		//netgate
		uglyFixClass("com.netgate.android.network.NetworkManager");
		uglyFixClass("com.netgate.android.data.SimpleCrypto");
		
		//skyfire
		uglyFix("<com.skyfire.browser.core.Main: void checkAlphaAccess()>");
		
		//taskos
		uglyFixClass("com.taskos.gtasks.GoogleProtocol");
		uglyFixClass("com.taskos.sharing.ShareManager");
		uglyFix("<com.taskos.service.plugins.StateSyncPlugin: void sendToServerWrapper(com.taskos.service.plugins.StateSyncPlugin$StateSyncData,com.taskos.service.plugins.BoolWrapper,com.taskos.service.plugins.BoolWrapper)>");
		uglyFix("<com.taskos.activity.ShareTask: boolean startService()>");
		uglyFix("<com.taskos.alert.AlertManager: void registerAlertWrapper(android.content.Context,long,com.taskos.alert.BoolWrapper,com.taskos.alert.BoolWrapper)>");
		uglyFix("<com.taskos.alert.AlertManager: void renewAlertWrapper(android.content.Context,long,com.taskos.alert.BoolWrapper,com.taskos.alert.BoolWrapper)>");
		
		//oeffi
		uglyFix("<de.schildbach.oeffi.directions.DirectionsActivity: void handleGo()>");
		uglyFix("<de.schildbach.oeffi.directions.DirectionsActivity: void onResume()>");
		uglyFix("<de.schildbach.oeffi.directions.DirectionsActivity: void handleShowLastConnectionWrapper(android.database.Cursor,int,de.schildbach.oeffi.directions.BoolWrapper)>");
		
		//fmlife
		uglyFix("<com.google.ads.AdActivity: void onCreate(android.os.Bundle)>");
		
		//flixster
		uglyFix("<net.flixster.android.TheaterListPage: int getTheatersWrapper(java.util.List,net.flixster.android.BoolWrapper,net.flixster.android.BoolWrapper,net.flixster.android.BoolWrapper)>");
		uglyFix("<net.flixster.android.TheaterMapPage: int getTheatersWrapper(net.flixster.android.BoolWrapper)>");
		uglyFix("<net.flixster.android.MovieTheaterMapPage: int getTheatersWrapper(net.flixster.android.BoolWrapper)>");
		
		//videopoker
		uglyFixClass("com.flurry.android.u");
	}
	
	private void saveTaintVariables(){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				if(!method.isConcrete()){
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				Iterator it = body.getUnits().iterator();
				
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					
					if(s.getTags().contains(instrumentationTag)){
						List<ValueBox> vbs = s.getUseAndDefBoxes();
						Iterator iter = vbs.iterator();
						while(iter.hasNext()){
							ValueBox vb = (ValueBox)iter.next();
							if(vb.getValue() instanceof Local){
								String varName = ((Local)vb.getValue()).getName();
								if(methodToTaintVar.containsKey(method.getSignature())){
									List<String> taintVars = methodToTaintVar.get(method.getSignature());
									if(!taintVars.contains(varName)){
										taintVars.add(varName);
									}
								}else{
									List<String> taintVars = new ArrayList<String>();
									taintVars.add(varName);
									methodToTaintVar.put(method.getSignature(), taintVars);
								}
							}else if(vb.getValue() instanceof InstanceFieldRef){
								SootField instanceField = ((InstanceFieldRef)vb.getValue()).getField();

								if(instanceField.getDeclaringClass().isApplicationClass() == false){
									continue;
								}

								if(instanceField.getDeclaringClass().isPhantom()){
									continue;
								}
								
								if(classToTaintField.containsKey(instanceField.getSignature())){
									List<String> taintFields = classToTaintField.get(method.getSignature());
									if(!taintFields.contains(instanceField.getSignature())){
										taintFields.add(instanceField.getSignature());
									}
								}else{
									List<String> taintFields = new ArrayList<String>();
									taintFields.add(instanceField.getSignature());
									classToTaintField.put(method.getSignature(), taintFields);
								}
								
							}else if(vb.getValue() instanceof StaticFieldRef){
								SootField staticField = ((StaticFieldRef)vb.getValue()).getField();

								if(staticField.getDeclaringClass().isApplicationClass() == false){
									continue;
								}

								if(staticField.getDeclaringClass().isPhantom()){
									continue;
								}
								
								if(classToTaintField.containsKey(staticField.getSignature())){
									List<String> taintFields = classToTaintField.get(method.getSignature());
									if(!taintFields.contains(staticField.getSignature())){
										taintFields.add(staticField.getSignature());
									}
								}else{
									List<String> taintFields = new ArrayList<String>();
									taintFields.add(staticField.getSignature());
									classToTaintField.put(method.getSignature(), taintFields);
								}
														
							}
							
						}
					}
				}
			}
		}
	}
	
	private void dumpTaintedFieldsAndVariables(){
		System.out.println("Tainted variables:");
		
		{
			Set<String> outKeySet = methodToSourceToVar.keySet();
			Iterator<String> outIter = outKeySet.iterator();
			while(outIter.hasNext()){
				String outKey = outIter.next();
				LinkedHashMap<String, List<String>> taintSourceToVar = methodToSourceToVar.get(outKey);
				
				Set<String> inKeySet = taintSourceToVar.keySet();
				Iterator<String> inIter = inKeySet.iterator();
				while(inIter.hasNext()){
					String inKey = inIter.next();
					List<String> varList = taintSourceToVar.get(inKey);
					
					for(String var : varList){
						System.out.println("Method[" + outKey + "]|Taint[" + inKey + "]|Var[" + var + "]");
					}
				}
			}		
		}
		
		System.out.println("Tainted fields:");
		
		{
			Set<String> outKeySet = classToSourceToField.keySet();
			Iterator<String> outIter = outKeySet.iterator();
			while(outIter.hasNext()){
				String outKey = outIter.next();
				LinkedHashMap<String, List<String>> taintSourceToVar = classToSourceToField.get(outKey);
				
				Set<String> inKeySet = taintSourceToVar.keySet();
				Iterator<String> inIter = inKeySet.iterator();
				while(inIter.hasNext()){
					String inKey = inIter.next();
					List<String> varList = taintSourceToVar.get(inKey);
					
					for(String var : varList){
						System.out.println("Method[" + outKey + "]|Taint[" + inKey + "]|Var[" + var + "]");
					}
				}
			}
		}
			
	}
	
	private void buildSinkList(){
		Set<String> keySet = CallGraphExample.sinks.keySet();
		Iterator<String> iter = keySet.iterator();
		while(iter.hasNext()){
			sinks.add(iter.next());
		}
	}
	
	private void buildSrcList(){
		Set<String> keySet = CallGraphExample.sources.keySet();
		Iterator<String> iter = keySet.iterator();
		while(iter.hasNext()){
			srcs.add(iter.next());
		}
	}
	
	private void buildEquivTables(){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			
			List<SootMethod> methods = soot_class.getMethods();
			
			for (SootMethod method : methods) {
				
				if(!method.isConcrete()){
					continue;
				}
								
				//System.out.println(method);
				
				JimpleBody body = (JimpleBody)method.retrieveActiveBody();
				
				ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);			
				
				
				MyReachingDefinition mrd = new MyReachingDefinition(eug);	
				
				LinkedHashMap<Stmt, List<Stmt>> equivTable = new LinkedHashMap<Stmt, List<Stmt>>();
				
				Chain<Unit> units = body.getUnits();				
				
				Iterator it = units.iterator();
				while(it.hasNext()){
					Stmt s = (Stmt)it.next();
					if(s instanceof InvokeStmt){
						InvokeExpr invoke = s.getInvokeExpr();
						if(invoke instanceof InstanceInvokeExpr){
							if(invoke.getMethod().getSignature().equals(
									"<java.io.DataOutputStream: void <init>(java.io.OutputStream)>")){
								Value base = ((InstanceInvokeExpr) invoke).getBase();
								Value arg0 = invoke.getArg(0);
																
								List<Unit> defsBase = mrd.getDefsOfAt((Local)base, s);
								if(defsBase.size()>1){
									continue;
								}
								Stmt defBase = (Stmt)defsBase.get(0);
								
								List<Unit> defsArg0 = mrd.getDefsOfAt((Local)arg0, s);
								if(defsArg0.size()>1){
									continue;
								}
								Stmt defArg0 = (Stmt)defsArg0.get(0);
								
								if(equivTable.containsKey(defBase)){
									List<Stmt> equivs = equivTable.get(defBase);
									equivs.add(defArg0);
								}else{
									List<Stmt> equivs = new ArrayList<Stmt>();
									equivs.add(defBase);
									equivs.add(defArg0);
									equivTable.put(defBase, equivs);
								}
								
								if(equivTable.containsKey(defArg0)){
									List<Stmt> equivs = equivTable.get(defArg0);
									equivs.add(defBase);
								}else{
									List<Stmt> equivs = new ArrayList<Stmt>();
									equivs.add(defArg0);
									equivs.add(defBase);
									equivTable.put(defArg0, equivs);
								}
							}
							
						}
												
					}
					/*
					else if(s instanceof DefinitionStmt){
						Value rhs = ((DefinitionStmt) s).getRightOp();
						if(rhs instanceof InstanceInvokeExpr){
							InvokeExpr invoke = s.getInvokeExpr();
							if(invoke.getMethod().getSignature().equals(
									"<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>")){
								Value base = ((InstanceInvokeExpr) invoke).getBase();
								Value lhs = ((DefinitionStmt) s).getLeftOp();
								
								List<Unit> defsBase = mrd.getDefsOfAt((Local)base, s);
								if(defsBase.size()>1){
									continue;
								}
								Stmt defBase = (Stmt)defsBase.get(0);
								
								List<Unit> defsArg0 = mrd.getDefsOfAt((Local)lhs, s);
								if(defsArg0.size()>1){
									continue;
								}
								Stmt defArg0 = (Stmt)defsArg0.get(0);
								
								if(equivTable.containsKey(defBase)){
									List<Stmt> equivs = equivTable.get(defBase);
									equivs.add(defArg0);
								}else{
									List<Stmt> equivs = new ArrayList<Stmt>();
									equivs.add(defBase);
									equivs.add(defArg0);
									equivTable.put(defBase, equivs);
								}
								
								if(equivTable.containsKey(defArg0)){
									List<Stmt> equivs = equivTable.get(defArg0);
									equivs.add(defBase);
								}else{
									List<Stmt> equivs = new ArrayList<Stmt>();
									equivs.add(defArg0);
									equivs.add(defBase);
									equivTable.put(defArg0, equivs);
								}
							}
						}
					}
					*/
				}//end while(it.hasNext()){
				
				if(!equivTable.isEmpty()){
					methodToEquiv.put(method, equivTable);
				}
			}
		}
		
		
	}
	
	private void dumpEquivTables(){
		
		if(!MyConstants.COUNT_LOC){
			System.out.println("printing out equivalence tables...\n");
		}
		Set<SootMethod> keySet = methodToEquiv.keySet();
		Iterator<SootMethod> iter = keySet.iterator();
		while(iter.hasNext()){
			SootMethod method = iter.next();
			if(!MyConstants.COUNT_LOC){
				System.out.println(method + ":");
			}
			LinkedHashMap<Stmt, List<Stmt>> equivTable = methodToEquiv.get(method);
			Set<Stmt> stmtKeySet = equivTable.keySet();
			Iterator<Stmt> stmtIter = stmtKeySet.iterator();
			while(stmtIter.hasNext()){
				Stmt s = stmtIter.next();
				if(!MyConstants.COUNT_LOC){
					System.out.print(s + "|");
				}
				List<Stmt> equivs = equivTable.get(s);
				if(!MyConstants.COUNT_LOC){
					System.out.println(equivs);
				}
			}
			if(!MyConstants.COUNT_LOC){
				System.out.println();
			}
		}
	}
	
	
	private void removeConstructorWrapper(){
		
		if(!MyConstants.COUNT_LOC){
			System.out.println("removing the wrapper of constructors...");
		}
		
		List<SootMethod> methodsToRemove = new ArrayList<SootMethod>();
		List<SootMethod> methodsToRename = new ArrayList<SootMethod>();
		LinkedHashMap<SootMethod, SootClass> methodToAddToClass = new LinkedHashMap<SootMethod, SootClass>();
		
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			List<SootMethod> methods = soot_class.getMethods();
			//System.out.println(methods);
			for (SootMethod method : methods) {
							
				if(!method.getName().equals("<init>Wrapper")){
					continue;
				}
				
				SootClass sClass = method.getDeclaringClass();
				String wrapperName = method.getName();
				if(MyConstants.DEBUG_INFO)
					System.out.println("method name: " + method.getName());
				
				String wrapperSubSig = method.getSubSignature();
				if(MyConstants.DEBUG_INFO)
					System.out.println("method sub-signature: " + method.getSubSignature());
				
				String oldName = wrapperName.substring(0, wrapperName.indexOf("Wrapper"));
				if(MyConstants.DEBUG_INFO)
					System.out.println("oldName: " + oldName);
				
				String oldSubSig = wrapperSubSig.replace(wrapperName, oldName);
				if(MyConstants.DEBUG_INFO)
					System.out.println("oldSubSig: " + oldSubSig);
				
				if(oldSubSig.contains("BoolWrapper")){
					oldSubSig = oldSubSig.substring(0, oldSubSig.indexOf("BoolWrapper"));
					if(MyConstants.DEBUG_INFO)
						System.out.println("oldSubSig: " + oldSubSig);
				}
				
				if(oldSubSig.lastIndexOf(',') > 0){
					oldSubSig = oldSubSig.substring(0, oldSubSig.lastIndexOf(','));
				}else{
					oldSubSig = oldSubSig.substring(0, (oldSubSig.indexOf('(') + 1));
				}
				if(MyConstants.DEBUG_INFO)
					System.out.println("oldSubSig: " + oldSubSig);
				
				oldSubSig = oldSubSig + ")";
				
				if(MyConstants.DEBUG_INFO)
					System.out.println("<init> subsig: " + oldSubSig);
				
				SootMethod oldMethod = sClass.getMethod(oldSubSig);
				
				List<Type> wrapperArgTypes = method.getParameterTypes();
				List<Type> oldArgTypes = oldMethod.getParameterTypes();
				
				if(wrapperArgTypes.equals(oldArgTypes)){
					methodsToRemove.add(oldMethod);
					methodsToRename.add(method);
				}else{
					methodsToRemove.add(method);
					
					//SootClass sClass = method.getDeclaringClass();
					//String methodName = method.getName();
					Type retType = method.getReturnType();
					int modifier = method.getModifiers();
					JimpleBody body = (JimpleBody)method.getActiveBody();
					
					Chain oldUnits = body.getUnits();
					Chain oldLocals = body.getLocals();						
					
					SootMethod adjustedWrapperMethod = new SootMethod(oldName,
							wrapperArgTypes, retType, modifier);
					
					
					
			        methodToAddToClass.put(adjustedWrapperMethod, sClass);
			        
			        
			        				        
			        JimpleBody newBody = Jimple.v().newBody(adjustedWrapperMethod);
			        
			            
			        adjustedWrapperMethod.setActiveBody(newBody);
			        adjustedWrapperMethod.addTag(wrapperMethodTag);
					
			        
			        
					Chain newUnits = newBody.getUnits();
			        
			        
			        Iterator oldLocalIter = oldLocals.iterator();
			        while(oldLocalIter.hasNext()){
			        	Local l = (Local)oldLocalIter.next();
			        	
			        	newBody.getLocals().add(l);
			        }
			        
			        //unitsClone(oldUnits, newUnits);
			        bodyCloneWithoutLocals(body, newBody);
				}
				
			}
		}
		
		Set<SootMethod> keySet = methodToAddToClass.keySet();
		Iterator<SootMethod> iter = keySet.iterator();
		while(iter.hasNext()){
			SootMethod methodToAdd = iter.next();
			SootClass classToAdd = methodToAddToClass.get(methodToAdd);
			classToAdd.addMethod(methodToAdd);
		}
		
		
		
		Chain<SootClass> classes1 = Scene.v().getClasses();
		Iterator<SootClass> classes_iter1 = classes1.iterator();
		while (classes_iter1.hasNext()) {
			SootClass soot_class = classes_iter1.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			List<SootMethod> methods = soot_class.getMethods();
			//System.out.println(methods);
			for (SootMethod method : methods) {
				
				if(!method.isConcrete()){
					continue;
				}
				
				LinkedHashMap<Stmt, Stmt> toReplace = new LinkedHashMap<Stmt, Stmt>();
				
				JimpleBody body = (JimpleBody)method.getActiveBody();
				Chain<Unit> units = body.getUnits();
				Iterator it = units.iterator();
				while(it.hasNext()){
					Stmt s = (Stmt)it.next();
					if(s instanceof InvokeStmt){
						
						InvokeExpr specialExpr = s.getInvokeExpr();
						if(specialExpr instanceof SpecialInvokeExpr){
							
							SootMethod oldMethod = specialExpr.getMethod();
							String oldMethodName = oldMethod.getName();
							if(oldMethodName.equals("<init>Wrapper")){
								
								Value base = ((SpecialInvokeExpr) specialExpr).getBase();
								List<Value> args = specialExpr.getArgs();
								
								SootClass oldMethodClass = oldMethod.getDeclaringClass();
								List<Type> oldArgTypes = oldMethod.getParameterTypes();
								Type oldReturnType = oldMethod.getReturnType();
								
								SootMethod toCall = Scene.v().getMethod(SootMethod.getSignature(
										oldMethodClass, "<init>", oldArgTypes, oldReturnType));
								
								Stmt toAdd = Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr((Local)base, toCall.makeRef(), args));
								toReplace.put(toAdd, s);
							}
						}
					}
				}
				
				Set<Stmt> keySet1 = toReplace.keySet();
				Iterator<Stmt> iter1 = keySet1.iterator();
				while(iter1.hasNext()){
					Stmt toAdd = iter1.next();
					Stmt toRemove = toReplace.get(toAdd);
					
					body.getUnits().insertBefore(toAdd, toRemove);
					body.getUnits().remove(toRemove);
					
				}
			}
		}
		
		for(SootMethod m : methodsToRemove){
			SootClass c = m.getDeclaringClass();
			
			c.removeMethod(m);
		}
		
		for(SootMethod m : methodsToRename){
			//SootClass c = m.getDeclaringClass();
			m.setName("<init>");
		}
	}
	
	//need fix. there's a bug when optimizing method for com.utagoe.momentdiary-45.apk. the wrapper is removed, but parameter list is not updated.
	//lift taint propagation from wrapper to its caller and remove wrapper
	private void doOptimization3(){
		System.out
			.println("optimizing the instrumentation code, phase three...");
		
		//List<SootMethod> initWrappers = new ArrayList<SootMethod>();
		LinkedHashMap<SootMethod, List<Stmt>> methodToEquations = new LinkedHashMap<SootMethod, List<Stmt>>();
		LinkedHashMap<SootMethod, LinkedHashMap<InstanceFieldRef, Integer>> methodToMapping = new LinkedHashMap<SootMethod, LinkedHashMap<InstanceFieldRef, Integer>>();
		
		List<SootMethod> checks = new ArrayList<SootMethod>();
		List<SootMethod> methodsWithRef = new ArrayList<SootMethod>();
		
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			List<SootMethod> methods = soot_class.getMethods();
			
			if(MyConstants.DEBUG_INFO)
				System.out.println(methods);
			for (SootMethod method : methods) {
				
				//boolean needMerge = false;
				
				if(!method.getTags().contains(wrapperMethodTag)){
					continue;
				}
				
				//if(method.getName().equals("<init>Wrapper")){
					//needMerge = true;
				//	initWrappers.add(method);
				//}
				
				if(MyConstants.DEBUG_INFO)
					System.out.println("class: " + method.getDeclaringClass() + "| method: " + method);
				
				boolean isChecking = false;
				boolean hasReference = false;
				
				LinkedHashMap<InstanceFieldRef, Integer> mapping = new LinkedHashMap<InstanceFieldRef, Integer>();
				
				List<Stmt> wrapperEnds = new ArrayList<Stmt>();
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				//ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);
				//MyReachingDefinition mrd = new MyReachingDefinition(eug);
				//if(body==null){
				//	System.out.println("body is null");
				//}
				
				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					//System.out.println(s);
					
					if(s.getTags().contains(wrapperEndTag)){
						wrapperEnds.add(s);
					}else if(s.getTags().contains(checkTaintTag)){
						//if(s instanceof IfStmt){
							isChecking = true;
							break;
						//}
					}else if(s.getTags().contains(referenceTag)){
						hasReference = true;
						break;
					}
					
				}
				
				//System.out.println(wrapperEnds);
				//System.out.println(isChecking);
				
				if(isChecking){
					if(!checks.contains(method)){
						checks.add(method);
					}
					continue;
				}
				
				if(hasReference){
					if(!methodsWithRef.contains(method)){
						methodsWithRef.add(method);
					}
					continue;
				}
				
				//if(!wrapperEnds.isEmpty()){
					
					ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);
					//ExceptionalUnitGraph eug = new ExceptionalUnitGraph((JimpleBody) method.retrieveActiveBody());
				
					MyReachingDefinition mrd = new MyReachingDefinition(eug);
					
					boolean hasBranch = false;
					List<Stmt> equations = new ArrayList<Stmt>();
					
					for(Stmt s : wrapperEnds){
						
						if(hasBranch){
							break;
						}
						/*
						Value lhs = ((DefinitionStmt)s).getLeftOp();
						Value rhs = ((DefinitionStmt)s).getRightOp();
						
						if(rhs instanceof Local){
							Value nrhs = getDefinition((Local)rhs, s, mrd);
							if(nrhs!=null){
								Stmt defStmt = Jimple.v().newAssignStmt(lhs, nrhs);
								System.out.println(defStmt);
							}
						}
						*/
						
						
						//boolean hasBranch = false;
						Stack<Stmt> duChain = new Stack<Stmt>();
						
						Stack<Stmt> stack = new Stack<Stmt>();
						stack.push(s);
						while(!stack.isEmpty()){
							Stmt use = stack.pop();
							
							duChain.push(use);
							//System.out.println(use);
							
							if(use.getTags().contains(wrapperBeginTag)){
								continue;
							}
							
							//boolean allAboutLocals = true;
							Value rhs = ((DefinitionStmt)use).getRightOp();
							//System.out.println("rhs="+rhs);
							
							if(rhs instanceof Local){
								List<Unit> defs = mrd.getDefsOfAt((Local)rhs, use);
								//System.out.println("use=" + use + "; rhs=" + rhs + "; defs=" + defs);
								if(defs.size()>1){
									hasBranch = true;
									break;
								}
								stack.push((Stmt)defs.get(0));
							}else if(rhs instanceof OrExpr){
								Value op1 = ((OrExpr) rhs).getOp1();
								Value op2 = ((OrExpr) rhs).getOp2();
								
								if(op1 instanceof Local){
									List<Unit> defs1 = mrd.getDefsOfAt((Local)op1, use);
									if(defs1.size()>1){
										hasBranch = true;
										break;
									}
									stack.push((Stmt)defs1.get(0));
								}
								
								if(op2 instanceof Local){
									List<Unit> defs2 = mrd.getDefsOfAt((Local)op2, use);
									if(defs2.size()>1){
										hasBranch = true;
										break;
									}
									stack.push((Stmt)defs2.get(0));
								}
							}
						}
						
						if(!hasBranch){
							while(!duChain.isEmpty()){
								Stmt def = duChain.pop();
								
								if(MyConstants.DEBUG_INFO)
									System.out.println(def);
								equations.add(def);
								if(def instanceof DefinitionStmt){
									Value lhs = ((DefinitionStmt) def).getLeftOp();
									Value rhs = ((DefinitionStmt) def).getRightOp();
									
									if(lhs instanceof InstanceFieldRef){
										Value base = ((InstanceFieldRef) lhs).getBase();
										if(base instanceof Local){
											List<Unit> identities = mrd.getDefsOfAt((Local)base, def);
											if(identities.get(0) instanceof IdentityStmt){
												Value rhsIdentity = ((IdentityStmt)identities.get(0)).getRightOp();
												if(rhsIdentity instanceof ParameterRef){
													int index = ((ParameterRef)rhsIdentity).getIndex();
													mapping.put((InstanceFieldRef)lhs, new Integer(index));
												}
												
											}else{
												System.out.println("something went wrong lhs as InstanceFieldRef!");
												hasBranch = true;
												break;
												//System.exit(-1);
											}
										}
									}
									
									if(rhs instanceof InstanceFieldRef){
										Value base = ((InstanceFieldRef) rhs).getBase();
										if(base instanceof Local){
											List<Unit> identities = mrd.getDefsOfAt((Local)base, def);
											if(identities.get(0) instanceof IdentityStmt){
												Value rhsIdentity = ((IdentityStmt)identities.get(0)).getRightOp();
												if(rhsIdentity instanceof ParameterRef){
													int index = ((ParameterRef)rhsIdentity).getIndex();
													mapping.put((InstanceFieldRef)rhs, new Integer(index));
												}
												
											}else{
												if(MyConstants.DEBUG_INFO)
													System.out.println("identities[0]=" + identities.get(0));
												
												System.out.println("something went wrong with rhs as InstanceFieldRef!");
												hasBranch = true;
												break;
												//System.exit(-1);
											}
										}
									}
								}
								
							}
						}					
						
					}//end for(Stmt s : wrapperEnds)
					
					if(hasBranch){
						continue;
					}
					
					if(MyConstants.DEBUG_INFO)
						System.out.println("equations: " + equations);
					//if(!equations.isEmpty()){
					
						methodToEquations.put(method, equations);
						
					//}
					
					//if(!mapping.isEmpty()){
					
						methodToMapping.put(method, mapping);
					//}
					
				//}
				
				
			}
		}
		
		if(methodToEquations.isEmpty()){
			System.out.println("no equations!");
			return;
		}
		
		List<SootMethod> toRemoveMethods = new ArrayList<SootMethod>();
		
		Chain<SootClass> classes1 = Scene.v().getClasses();
		Iterator<SootClass> classes_iter1 = classes1.iterator();
		while (classes_iter1.hasNext()) {
			SootClass soot_class = classes_iter1.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}

			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				/*
				if(checks.contains(method)){
					continue;
				}
				*/
				
				if(!method.isConcrete()){
					continue;
				}
			
				List<Stmt> toRemove = new ArrayList<Stmt>();
				LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();
				LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				Iterator it = body.getUnits().iterator();
				
				ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);
				MyReachingDefinition mrd = new MyReachingDefinition(eug);
				
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					
					if(s.getTags().contains(invokeWrapperTag)){
						
						InvokeExpr invokeExpr = s.getInvokeExpr();
						SootMethod wrapper = invokeExpr.getMethod();
						
						
						if(checks.contains(wrapper)){
							continue;
						}
						
						
						if(methodsWithRef.contains(wrapper)){
							continue;
						}
						
						
						if(!MyConstants.COUNT_LOC){
							System.out.println("removing method: " + wrapper);
						}
						
						SootClass oldMethodClass = wrapper.getDeclaringClass();
						String oldMethodName = wrapper.getName();
						String newMethodName = oldMethodName.substring(0, oldMethodName.indexOf("Wrapper"));
						Type oldReturnType = wrapper.getReturnType();
						List<Type> oldArgTypes = wrapper.getParameterTypes();
						List<Type> newArgTypes = new ArrayList<Type>();
						
						Type boolWrapper = null;
						if(oldMethodClass.getPackageName().equals("")){
							boolWrapper = RefType.v(MyConstants.boolWrapper);
						}else{
							boolWrapper = RefType.v(oldMethodClass.getPackageName() + "." + MyConstants.boolWrapper);
						}
						 
						
						
						List<Value> args = invokeExpr.getArgs();
						List<Value> nargs = new ArrayList<Value>();
						for(Value v : args){
							if(!v.getType().equals(boolWrapper)){
								nargs.add(v);
							}
						}
						
						
						
						for(Type t : oldArgTypes){
							
							if(t.equals(boolWrapper)){
								
								if(MyConstants.DEBUG_INFO)
									System.out.println("found wrapper parameter: " + t);
							}else{
								newArgTypes.add(t);
							}
						}
						
						//List<Stmt> toInsertAfter = new ArrayList<Stmt>();
						LinkedHashMap<Local, Local> localToLocal = new LinkedHashMap<Local, Local>();
						LinkedHashMap<InstanceFieldRef, Value> fieldToValue = new LinkedHashMap<InstanceFieldRef, Value>();
						
						
						if(methodToEquations.containsKey(wrapper) && methodToMapping.containsKey(wrapper)){
							
							if(!toRemoveMethods.contains(wrapper)){
								toRemoveMethods.add(wrapper);
							}
							
							List<Stmt> equations = methodToEquations.get(wrapper);
							LinkedHashMap<InstanceFieldRef, Integer> mapping = methodToMapping.get(wrapper);
							List<Unit> unitsToAdd = new LinkedList<Unit>();
							for(Stmt eq : equations){
								if(eq instanceof DefinitionStmt){
									Value lhs = ((DefinitionStmt) eq).getLeftOp();
									Value rhs = ((DefinitionStmt) eq).getRightOp();
									
									Value nlhs = null;
									Value nrhs = null;
									
									if(lhs instanceof Local){
										if(!localToLocal.containsKey(lhs)){
											
											int localCount = body.getLocalCount();
											Local local = Jimple.v().newLocal(MyConstants.tempLocal+localCount, BooleanType.v());
							                body.getLocals().add(local);
											
											localToLocal.put((Local)lhs, local);
										}
										
										nlhs = localToLocal.get((Local)lhs);
										
										
									}else if(lhs instanceof InstanceFieldRef){
										if(!fieldToValue.containsKey(lhs)){
											int index = mapping.get(lhs).intValue();
											Value arg = invokeExpr.getArg(index);
											//System.out.println("wrapper's definitions: " + mrd.getDefsOfAt((Local)arg, s));
											Stmt back = (Stmt)body.getUnits().getPredOf(s);
											while(back.getTags().contains(beforeWrapperTag)){
												if(back instanceof DefinitionStmt){
													Value lBack = ((DefinitionStmt) back).getLeftOp();
													Value rBack = ((DefinitionStmt) back).getRightOp();
													
													if(lBack instanceof InstanceFieldRef){
														Value base = ((InstanceFieldRef) lBack).getBase();
														if(base.equivTo(arg)){
															fieldToValue.put((InstanceFieldRef)lhs, rBack);
														}
													}
												}
												back = (Stmt)body.getUnits().getPredOf(back);
											}
											
											
											
										}
										
										nlhs = fieldToValue.get((InstanceFieldRef)lhs);
									}
									
									
									if(rhs instanceof Local){
										if(!localToLocal.containsKey(rhs)){
											
											int localCount = body.getLocalCount();
											Local local = Jimple.v().newLocal(MyConstants.tempLocal+localCount, BooleanType.v());
							                body.getLocals().add(local);
											
											localToLocal.put((Local)rhs, local);
										}
										
										nrhs = localToLocal.get((Local)rhs);
										
									}else if(rhs instanceof InstanceFieldRef){
										if(!fieldToValue.containsKey(rhs)){
											int index = mapping.get(rhs).intValue();
											Value arg = invokeExpr.getArg(index);
											
											Stmt back = (Stmt)body.getUnits().getPredOf(s);
											while(back.getTags().contains(beforeWrapperTag)){
												if(back instanceof DefinitionStmt){
													Value lBack = ((DefinitionStmt) back).getLeftOp();
													Value rBack = ((DefinitionStmt) back).getRightOp();
													
													if(lBack instanceof InstanceFieldRef){
														Value base = ((InstanceFieldRef) lBack).getBase();
														if(base.equivTo(arg)){
															fieldToValue.put((InstanceFieldRef)rhs, rBack);
														}
													}
												}
												back = (Stmt)body.getUnits().getPredOf(back);
											}										
											
										}
										
										nrhs = fieldToValue.get((InstanceFieldRef)rhs);
										
									}else if(rhs instanceof OrExpr){
										Value op1 = ((OrExpr) rhs).getOp1();
										Value op2 = ((OrExpr) rhs).getOp2();
										
										Value nop1 = null;
										Value nop2 = null;
										
										if(op1 instanceof Local){
											if(!localToLocal.containsKey(op1)){
												
												int localCount = body.getLocalCount();
												Local local = Jimple.v().newLocal(MyConstants.tempLocal+localCount, BooleanType.v());
								                body.getLocals().add(local);
												
												localToLocal.put((Local)op1, local);
											}
											
											nop1 = localToLocal.get((Local)op1);
											
										}
										
										if(op2 instanceof Local){
											if(!localToLocal.containsKey(op2)){
												
												int localCount = body.getLocalCount();
												Local local = Jimple.v().newLocal(MyConstants.tempLocal+localCount, BooleanType.v());
								                body.getLocals().add(local);
												
												localToLocal.put((Local)op2, local);
											}
											
											nop2 = localToLocal.get((Local)op2);
										}
										
										if(op1!=null && op2!=null){
											nrhs = Jimple.v().newOrExpr(nop1, nop2);
										}
										
									}else if(rhs instanceof IntConstant){
										nrhs = IntConstant.v(((IntConstant)rhs).value);
									}
									
									if(nlhs!=null && nrhs!=null){
										Stmt toAdd = Jimple.v().newAssignStmt(nlhs, nrhs);
										toAdd.addTag(instrumentationTag);
										
										unitsToAdd.add(toAdd);
										
										
									}
									
									
								}
							}
							
							if(!unitsToAdd.isEmpty()){
								toInstrumentAfter.put(unitsToAdd, s);
							}
							
							
							Unit back = s;
							back = body.getUnits().getPredOf(back);
							while(back.getTags().contains(beforeWrapperTag)){
								toRemove.add((Stmt)back);								
								back = body.getUnits().getPredOf(back);
							}
							
							Unit forward = s;
							forward = body.getUnits().getSuccOf(forward);
							while(forward.getTags().contains(afterWrapperTag)){
								toRemove.add((Stmt)forward);
								forward = body.getUnits().getSuccOf(forward);
							}
							
							SootMethod toCall = null;
							toCall = Scene.v().getMethod(SootMethod.getSignature(
									oldMethodClass, newMethodName, newArgTypes, oldReturnType));
							/*
							if(methodsWithRef.contains(wrapper)){
								System.out.println("method with reference:" + wrapper);
								
								toCall = Scene.v().getMethod(SootMethod.getSignature(
										oldMethodClass, oldMethodName, newArgTypes, oldReturnType));
							}else{
								System.out.println("method without reference:" + wrapper);
								
								toCall = Scene.v().getMethod(SootMethod.getSignature(
										oldMethodClass, newMethodName, newArgTypes, oldReturnType));
							}
							*/
							 
							
														
							if(s instanceof InvokeStmt){
								
								if(invokeExpr instanceof StaticInvokeExpr){
									
									InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}else if(invokeExpr instanceof VirtualInvokeExpr){
									Value base = ((VirtualInvokeExpr) invokeExpr).getBase();
									if(base instanceof Local){
										InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}else if(invokeExpr instanceof SpecialInvokeExpr){
									Value base = ((SpecialInvokeExpr) invokeExpr).getBase();
									if(base instanceof Local){
										InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}else if(invokeExpr instanceof InterfaceInvokeExpr){
									Value base = ((InterfaceInvokeExpr) invokeExpr).getBase();
									if(base instanceof Local){
										InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newInterfaceInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}
								
								
							}else if(s instanceof DefinitionStmt){
								Value nlhs = ((DefinitionStmt)s).getLeftOp();
								if(invokeExpr instanceof StaticInvokeExpr){
									AssignStmt nStmt = Jimple.v().newAssignStmt(
											nlhs, Jimple.v().newStaticInvokeExpr(toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}else if(invokeExpr instanceof VirtualInvokeExpr){
									Value base = ((VirtualInvokeExpr) invokeExpr).getBase();
									if(base instanceof Local){
										AssignStmt nStmt = Jimple.v().newAssignStmt(
												nlhs, Jimple.v().newVirtualInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}else if(invokeExpr instanceof SpecialInvokeExpr){
									Value base = ((SpecialInvokeExpr) invokeExpr).getBase();
									if(base instanceof Local){
										AssignStmt nStmt = Jimple.v().newAssignStmt(
												nlhs, Jimple.v().newSpecialInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}else if(invokeExpr instanceof InterfaceInvokeExpr){
									Value base = ((InterfaceInvokeExpr) invokeExpr).getBase();
									if(base instanceof Local){
										AssignStmt nStmt = Jimple.v().newAssignStmt(
												nlhs, Jimple.v().newInterfaceInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}
							}
							
							
						}
						
						
						
					}//s.getTags().contains(invokeWrapperTag)
				}
				
				for(Stmt s : toRemove){
					body.getUnits().remove(s);
				}
				
				Set<List<Unit>> keySet = toInstrumentAfter.keySet();
				Iterator<List<Unit>> keyIterator = keySet.iterator();
				while (keyIterator.hasNext()) {

					List<Unit> toAdd = keyIterator.next();
					Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
					body.getUnits().insertAfter(toAdd, s);
				}
				
				
				Set<Stmt> keySet1 = toInstrumentAt.keySet();
				Iterator<Stmt> keyIterator1 = keySet1.iterator();
				while (keyIterator1.hasNext()) {

					Stmt toReplace = keyIterator1.next();
					Stmt s = (Stmt) toInstrumentAt.get(toReplace);

					body.getUnits().insertBefore(toReplace, s);
					body.getUnits().remove(s);
				}
				
				

			}
		}
		
		
		
		//List<SootMethod> toRemoveMethods = new ArrayList<SootMethod>();
		
		for(SootMethod sMethod : toRemoveMethods){
			
			
			SootClass soot_class = sMethod.getDeclaringClass();
			soot_class.removeMethod(sMethod);
			/*
			String wrapperName = sMethod.getName();
			String oldName = wrapperName.substring(0, wrapperName.indexOf("Wrapper"));
						
			SootMethod oldMethod = soot_class.getMethodByName(oldName);
			
			JimpleBody body = (JimpleBody)sMethod.getActiveBody();
			
			ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);
			MyReachingDefinition mrd = new MyReachingDefinition(eug);
			
			List<Unit> unitsToRemove = new ArrayList<Unit>();
			for(Unit u : body.getUnits()){
				
				Stack<Stmt> toKeep = new Stack<Stmt>();
				Stmt s = (Stmt)u;
				if(s.getTags().contains(referenceTag)){
					Value rhs = ((DefinitionStmt)s).getRightOp();
					if(rhs instanceof Local){
						toKeep.push(s);
					}
				}
				
				while(!toKeep.isEmpty()){
					Stmt refStmt = toKeep.pop();
					if(!refStmt.getTags().contains(referenceRelatedTag)){
						refStmt.addTag(referenceRelatedTag);
					}
					
					if(refStmt instanceof DefinitionStmt){
						Value rhs = ((DefinitionStmt) refStmt).getRightOp();
						if(rhs instanceof Local){
							List<Unit> defs = mrd.getDefsOfAt((Local)rhs, refStmt);
							for(Unit def : defs){
								
							}
						}
					}
				}
			}
			
			for(Unit u : unitsToRemove){
				body.getUnits().remove(u);
			}
			
			if(!methodsWithRef.contains(sMethod)){
				soot_class.removeMethod(oldMethod);
				sMethod.setName(oldName);
			}
			sMethod.setParameterTypes(oldMethod.getParameterTypes());
			*/
			
			/*
			if(sMethod.getName().equals("<init>Wrapper")){
				
				String wrapperName = sMethod.getName();
				String oldName = wrapperName.substring(0, wrapperName.indexOf("Wrapper"));
							
				SootMethod oldMethod = soot_class.getMethodByName(oldName);
				
				
				
				soot_class.removeMethod(oldMethod);
				
				List<Unit> unitsToRemove = new ArrayList<Unit>();
				for(Unit u : sMethod.getActiveBody().getUnits()){
					if(u.getTags().contains(instrumentationTag) && !u.getTags().contains(initialLocalTag)
							&& !u.getTags().contains(referenceTag)){
						unitsToRemove.add(u);
					}
				}
				
				for(Unit u : unitsToRemove){
					sMethod.getActiveBody().getUnits().remove(u);
				}
				
				
				sMethod.setName(oldName);
				sMethod.setParameterTypes(oldMethod.getParameterTypes());
				
			}else{
				
				soot_class.removeMethod(sMethod);
			}
			*/
			
		}
		
		/*
		Chain<SootClass> classes2 = Scene.v().getClasses();
		Iterator<SootClass> classes_iter2 = classes2.iterator();
		while (classes_iter2.hasNext()) {
			SootClass soot_class = classes_iter2.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}

			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for(SootMethod sMethod : toRemoveMethods){
				
				if(methods.contains(sMethod)){
					
					soot_class.removeMethod(sMethod);
				}
			}
			
		}
		*/
		
	}
	
	private void bodyCloneWithoutLocals(JimpleBody oldBody, JimpleBody newBody){
		
		Chain oldUnits = oldBody.getUnits();
		Chain newUnits = newBody.getUnits();
        
		LinkedHashMap<Stmt, Stmt> oldStmtToNewStmt = new LinkedHashMap<Stmt, Stmt>();
        
		Iterator oldIter = oldUnits.iterator();
	    while(oldIter.hasNext()){
	    	Stmt s = (Stmt)oldIter.next();		        	
	    	Stmt newUnit = (Stmt)s.clone();
	        	
	    	newUnit.addAllTagsOf(s);
	    	s.removeAllTags();

	    	oldStmtToNewStmt.put(s, newUnit);
	    }
	    
	    for(Trap t : oldBody.getTraps()){
        	Unit oldBegin = t.getBeginUnit();
        	Unit oldEnd = t.getEndUnit();
        	Unit oldHandler = t.getHandlerUnit();
        	SootClass ex = t.getException();
        	
        	Unit newBegin = oldStmtToNewStmt.get((Stmt)oldBegin);
        	Unit newEnd = oldStmtToNewStmt.get((Stmt)oldEnd);
        	Unit newHandler = oldStmtToNewStmt.get((Stmt)oldHandler);
        	
        	newBody.getTraps().add(Jimple.v().newTrap(ex, newBegin, newEnd, newHandler));
        }
	        
	    Set<Stmt> keySet = oldStmtToNewStmt.keySet();
	    Iterator<Stmt> keyIterator = keySet.iterator();
	    while (keyIterator.hasNext()) {

	    	Stmt oldStmt = keyIterator.next();
	    	Stmt newStmt = (Stmt) oldStmtToNewStmt.get(oldStmt);
				
	    	if(oldStmt instanceof IfStmt){
	    		Stmt oldTarget = ((IfStmt) oldStmt).getTarget();
	    		Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    		((IfStmt) newStmt).setTarget(newTarget);
	    	}else if(oldStmt instanceof GotoStmt){
	    		Stmt oldTarget = (Stmt)((GotoStmt) oldStmt).getTarget();
	    		Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    		((GotoStmt) newStmt).setTarget(newTarget);
	    	}else if(oldStmt instanceof LookupSwitchStmt){
	    		List<Stmt> oldTargets = ((LookupSwitchStmt) oldStmt).getTargets();
	    		List<Stmt> newTargets = new ArrayList<Stmt>();
	    		for(Stmt oldTarget : oldTargets){
	    			Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    			newTargets.add(newTarget);
	    		}
	    		
	    		Stmt[] newTargetsArray = new Stmt[newTargets.size()];
				for(int i=0;i<newTargets.size();i++){
					newTargetsArray[i] = newTargets.get(i);
				}
				((LookupSwitchStmt) newStmt).setTargets(newTargetsArray);
	    		//((LookupSwitchStmt) newStmt).setTargets((Stmt[])newTargets.toArray());
	    		
	    		Stmt oldDefaultTarget = (Stmt)((LookupSwitchStmt) oldStmt).getDefaultTarget();
				Stmt newDefaultTarget = oldStmtToNewStmt.get(oldDefaultTarget);
				((LookupSwitchStmt) newStmt).setDefaultTarget(newDefaultTarget);
	    		
	    	}else if(oldStmt instanceof TableSwitchStmt){
	    		List<Stmt> oldTargets = ((TableSwitchStmt) oldStmt).getTargets();
	    		List<Unit> newTargets = new ArrayList<Unit>();
	    		for(Stmt oldTarget : oldTargets){
	    			Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    			newTargets.add(newTarget);
	    		}						 
	    		((TableSwitchStmt) newStmt).setTargets(newTargets);
	    		
	    		Stmt oldDefaultTarget = (Stmt)((TableSwitchStmt) oldStmt).getDefaultTarget();
				Stmt newDefaultTarget = oldStmtToNewStmt.get(oldDefaultTarget);
				((TableSwitchStmt) newStmt).setDefaultTarget(newDefaultTarget);
	    	}
				
				
	    	newUnits.add(newStmt);
	    }
	}
	
	private void unitsClone(Chain<Unit> oldUnits, Chain<Unit> newUnits){
		
		LinkedHashMap<Stmt, Stmt> oldStmtToNewStmt = new LinkedHashMap<Stmt, Stmt>();
	        
		Iterator oldIter = oldUnits.iterator();
	    while(oldIter.hasNext()){
	    	Stmt s = (Stmt)oldIter.next();		        	
	    	Stmt newUnit = (Stmt)s.clone();
	        	
	    	newUnit.addAllTagsOf(s);
	    	s.removeAllTags();

	    	oldStmtToNewStmt.put(s, newUnit);
	    }
	        
	    Set<Stmt> keySet = oldStmtToNewStmt.keySet();
	    Iterator<Stmt> keyIterator = keySet.iterator();
	    while (keyIterator.hasNext()) {

	    	Stmt oldStmt = keyIterator.next();
	    	Stmt newStmt = (Stmt) oldStmtToNewStmt.get(oldStmt);
				
	    	if(oldStmt instanceof IfStmt){
	    		Stmt oldTarget = ((IfStmt) oldStmt).getTarget();
	    		Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    		((IfStmt) newStmt).setTarget(newTarget);
	    	}else if(oldStmt instanceof GotoStmt){
	    		Stmt oldTarget = (Stmt)((GotoStmt) oldStmt).getTarget();
	    		Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    		((GotoStmt) newStmt).setTarget(newTarget);
	    	}else if(oldStmt instanceof LookupSwitchStmt){
	    		List<Stmt> oldTargets = ((LookupSwitchStmt) oldStmt).getTargets();
	    		List<Stmt> newTargets = new ArrayList<Stmt>();
	    		for(Stmt oldTarget : oldTargets){
	    			Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    			newTargets.add(newTarget);
	    		}
	    		
	    		Stmt[] newTargetsArray = new Stmt[newTargets.size()];
				for(int i=0;i<newTargets.size();i++){
					newTargetsArray[i] = newTargets.get(i);
				}
				((LookupSwitchStmt) newStmt).setTargets(newTargetsArray);
	    		//((LookupSwitchStmt) newStmt).setTargets((Stmt[])newTargets.toArray());
	    		
	    		Stmt oldDefaultTarget = (Stmt)((LookupSwitchStmt) oldStmt).getDefaultTarget();
				Stmt newDefaultTarget = oldStmtToNewStmt.get(oldDefaultTarget);
				((LookupSwitchStmt) newStmt).setDefaultTarget(newDefaultTarget);
	    		
	    	}else if(oldStmt instanceof TableSwitchStmt){
	    		List<Stmt> oldTargets = ((TableSwitchStmt) oldStmt).getTargets();
	    		List<Unit> newTargets = new ArrayList<Unit>();
	    		for(Stmt oldTarget : oldTargets){
	    			Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
	    			newTargets.add(newTarget);
	    		}						 
	    		((TableSwitchStmt) newStmt).setTargets(newTargets);
	    		
	    		Stmt oldDefaultTarget = (Stmt)((TableSwitchStmt) oldStmt).getDefaultTarget();
				Stmt newDefaultTarget = oldStmtToNewStmt.get(oldDefaultTarget);
				((TableSwitchStmt) newStmt).setDefaultTarget(newDefaultTarget);
	    	}
				
				
	    	newUnits.add(newStmt);
	    }
	}
	
	
	//remove redundant parameters in wrapper
	private void doOptimization2(){
		
		System.out
			.println("optimizing the instrumentation code, phase two...");

		LinkedHashMap<SootMethod, List<Integer>> methodToRemoveIndexes = new LinkedHashMap<SootMethod, List<Integer>>();
		//LinkedHashMap<SootMethod, Integer> methodToBoolNumber = new LinkedHashMap<SootMethod, Integer>();
		LinkedHashMap<SootMethod, List<Type>> methodToTypeList = new LinkedHashMap<SootMethod, List<Type>>();
		
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			System.out.println("optimizing class " + soot_class);
			
			LinkedHashMap<SootMethod, SootClass> methodToAddToClass = new LinkedHashMap<SootMethod, SootClass>();
			
			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				if(!method.getTags().contains(wrapperMethodTag)){
					//System.out.println(method + " is not a wrapper");
					continue;
				}

				//System.out.println(method.getName() + ":");

				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				List<Local> identityLocals = new ArrayList<Local>();
				List<Local> identityStillLocals = new ArrayList<Local>();
				LinkedHashMap<Local, Stmt> identity = new LinkedHashMap<Local, Stmt>();
				List<Stmt> identityToRemove = new ArrayList<Stmt>();
				List<Stmt> identityToKeep = new ArrayList<Stmt>();
				int lastParameterIndex = -1;
				int removeCount = 0;
				
				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					
					if(s instanceof IdentityStmt){
						if(s.getTags().contains(instrumentationTag)){
							Value lhs = ((IdentityStmt) s).getLeftOp();
							if(lhs instanceof Local){
								identityLocals.add((Local)lhs);	
								identity.put((Local)lhs, s);
							}
						}else{
							Value rhs = ((IdentityStmt)s).getRightOp();
							if(rhs instanceof ParameterRef){
								lastParameterIndex++;
							}
						}
					}
					
				}
				
				//Set<Local> localsInIdentity = identity.keySet();
				
				Iterator it1 = body.getUnits().iterator();
				while (it1.hasNext()) {
					Stmt s = (Stmt) it1.next();
					
					if(!(s instanceof IdentityStmt)){
						List<ValueBox> vbs = s.getUseAndDefBoxes();
						Iterator i = vbs.iterator();
						while(i.hasNext()){
							ValueBox vb = (ValueBox)i.next();
							if(vb.getValue() instanceof Local){
								
								if(identityLocals.contains((Local)vb.getValue())){
									identityStillLocals.add((Local)vb.getValue());
									identityLocals.remove((Local)vb.getValue());
								}
								
							}
						}
					}
				}
				
				if(!identityLocals.isEmpty()){
					for(Local l : identityLocals){
						identityToRemove.add(identity.get(l));
						removeCount++;
					}
				}
				
				if(!identityStillLocals.isEmpty()){
					for(Local l : identityStillLocals){
						identityToKeep.add(identity.get(l));
					}
				}
				
				
				List<Integer> indexesToRemove = new ArrayList<Integer>();
				for(Stmt s: identityToRemove){
					if(s instanceof IdentityStmt){
						Value rhs = ((IdentityStmt)s).getRightOp();
						if(rhs instanceof ParameterRef){
							int index = ((ParameterRef)rhs).getIndex();
							indexesToRemove.add(new Integer(index));
						}
					}
				}
				
				
				//remove redundant identity statement
				if(!identityToRemove.isEmpty()){
					for(Stmt s : identityToRemove){
						body.getUnits().remove(s);
					}
				}
				
				//remove redundant locals ( Soot also perform this optimization )
				if(!identityLocals.isEmpty()){
					for(Local l : identityLocals){
						body.getLocals().remove(l);
					}
				}
				
				//adjust left identity statement ( parameter indices )
				int count = lastParameterIndex;
				if(!identityToKeep.isEmpty()){
					for(Stmt s : identityToKeep){						
						count++;
						Value rhs = ((IdentityStmt)s).getRightOp();
						if(rhs instanceof ParameterRef){
							((ParameterRef)rhs).setIndex(count);
						}
					}
				}
				
				//adjust wrapper prototype ( parameter list )
				List<Type> argTypes = method.getParameterTypes();
				int argCount = method.getParameterCount();
				int boolNumber = argCount-(lastParameterIndex+1);
				
				//System.out.println("method:" + method + "|removeCount = " + removeCount + ", boolNumber = " + boolNumber);
				
				if(removeCount <= boolNumber){
					//System.out.println(method + " prototype needs adjustment");
					
					List<Type> newArgTypes = new ArrayList<Type>();
					for(Type t : argTypes){
						newArgTypes.add(t);
					}
					
					for(int j=0;j<removeCount;j++){
						argCount--;
						newArgTypes.remove(argCount);
					}
					
					//method.setParameterTypes(newArgTypes);
					
					/*
					int deduction = 0;
					for(Integer i : indexesToRemove){
						int adjustedIndex = i.intValue() - deduction;
						newArgTypes.remove(adjustedIndex);
					}
					*/
					
					//record the number of parameters to be removed for this wrapper method
					if(!indexesToRemove.isEmpty()){
						methodToRemoveIndexes.put(method, indexesToRemove);
						//methodToBoolNumber.put(method, new Integer(boolNumber));
						methodToTypeList.put(method, newArgTypes);
						
						if(!MyConstants.COUNT_LOC){
							System.out.println(method + " prototype needs adjustment to " + newArgTypes);
						}
						
						
						//create adjusted wrapper class
						{
							SootClass sClass = method.getDeclaringClass();
							String methodName = method.getName();
							Type retType = method.getReturnType();
							int modifier = method.getModifiers();
							
							Chain oldUnits = body.getUnits();
							Chain oldLocals = body.getLocals();						
							
							SootMethod adjustedWrapperMethod = new SootMethod(methodName,
									newArgTypes, retType, modifier);
							
							
							//System.out.println("adding wrappers");
					        //sClass.addMethod(adjustedWrapperMethod);
					        methodToAddToClass.put(adjustedWrapperMethod, sClass);
					        
					        
					        //System.out.println("added wrappers");
					        				        
					        JimpleBody newBody = Jimple.v().newBody(adjustedWrapperMethod);
					        
					            
					        adjustedWrapperMethod.setActiveBody(newBody);
					        adjustedWrapperMethod.addTag(wrapperMethodTag);
							
					        
					        
							Chain newUnits = newBody.getUnits();
					        //Chain newLocals = newBody.getLocals();
					        
					        Iterator oldLocalIter = oldLocals.iterator();
					        while(oldLocalIter.hasNext()){
					        	Local l = (Local)oldLocalIter.next();
					        	//Local newLocal = (Local)l.clone();
					        	//Local newLocal = Jimple.v().newLocal(l.getName(), l.getType());
					        	//newBody.getLocals().add(newLocal);
					        	newBody.getLocals().add(l);
					        }
					        
					        if(MyConstants.DEBUG_INFO)
					        	System.out.println("local chains: " + adjustedWrapperMethod.getActiveBody().getLocals());
					        
					        //unitsClone(oldUnits, newUnits);
					        bodyCloneWithoutLocals(body, newBody);
					        
					        /*
					        LinkedHashMap<Stmt, Stmt> oldStmtToNewStmt = new LinkedHashMap<Stmt, Stmt>();
					        
					        Iterator oldIter = oldUnits.iterator();
					        while(oldIter.hasNext()){
					        	Stmt s = (Stmt)oldIter.next();		        	
					        	Stmt newUnit = (Stmt)s.clone();
					        	
					        	
					        	newUnit.addAllTagsOf(s);
					        	s.removeAllTags();
					        	
					        	
					        	oldStmtToNewStmt.put(s, newUnit);
					        }
					        
					        Set<Stmt> keySet = oldStmtToNewStmt.keySet();
							Iterator<Stmt> keyIterator = keySet.iterator();
							while (keyIterator.hasNext()) {

								Stmt oldStmt = keyIterator.next();
								Stmt newStmt = (Stmt) oldStmtToNewStmt.get(oldStmt);
								
								if(oldStmt instanceof IfStmt){
									Stmt oldTarget = ((IfStmt) oldStmt).getTarget();
									Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
									((IfStmt) newStmt).setTarget(newTarget);
								}else if(oldStmt instanceof GotoStmt){
									Stmt oldTarget = (Stmt)((GotoStmt) oldStmt).getTarget();
									Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
									((GotoStmt) newStmt).setTarget(newTarget);
								}else if(oldStmt instanceof LookupSwitchStmt){
									List<Stmt> oldTargets = ((LookupSwitchStmt) oldStmt).getTargets();
									List<Stmt> newTargets = new ArrayList<Stmt>();
									for(Stmt oldTarget : oldTargets){
										Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
										newTargets.add(newTarget);
									}						 
									((LookupSwitchStmt) newStmt).setTargets((Stmt[])newTargets.toArray());
								}else if(oldStmt instanceof TableSwitchStmt){
									List<Stmt> oldTargets = ((TableSwitchStmt) oldStmt).getTargets();
									List<Unit> newTargets = new ArrayList<Unit>();
									for(Stmt oldTarget : oldTargets){
										Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
										newTargets.add(newTarget);
									}						 
									((TableSwitchStmt) newStmt).setTargets(newTargets);
								}
								
								
								newUnits.add(newStmt);
							}
							*/
					        
						}
						
					}
				}
				
			}
			
			Set<SootMethod> keySet = methodToAddToClass.keySet();
			Iterator<SootMethod> keyIterator = keySet.iterator();
			while (keyIterator.hasNext()) {

				SootMethod toAdd = keyIterator.next();
				SootClass sClass = methodToAddToClass.get(toAdd);

				sClass.addMethod(toAdd);
			}
			
			
		}
		
		//adjust the invocation of wrapper in caller ( including wrapper parameter initialization and wrapper invocation )
		
		List<SootMethod> methodsToRemove = new ArrayList<SootMethod>();
		
		Chain<SootClass> classes1 = Scene.v().getClasses();
		Iterator<SootClass> classes_iter1 = classes1.iterator();
		while (classes_iter1.hasNext()) {
			SootClass soot_class = classes_iter1.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}


			List<SootMethod> methods = soot_class.getMethods();
			if(MyConstants.DEBUG_INFO)
				System.out.println("methods: " + methods);
			
			//LinkedHashMap<SootMethod, SootClass> methodToRemoveToClass = new LinkedHashMap<SootMethod, SootClass>();
			//List<SootMethod> methodsToRemove = new ArrayList<SootMethod>();
			
			for (SootMethod method : methods) {
				
				if(!method.isConcrete()){
					continue;
				}

				if(MyConstants.DEBUG_INFO)
					System.out.println(method.getName() + ":");
				
				List<Stmt> toRemove = new ArrayList<Stmt>();
				LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();

				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					if(s.getTags().contains(invokeWrapperTag)){
						
						//Iterator targets = new Targets(cg.edgesOutOf(s));
						//while (targets.hasNext()) {
							//SootMethod wrapper = (SootMethod) targets.next();
							
							//System.out.println("optimizer2: " + wrapper);
							
						InvokeExpr invokeExpr = s.getInvokeExpr();
						
						if(MyConstants.DEBUG_INFO){
							System.out.println("statement with invokeWrapperTag: " + s);
						}
						SootMethod wrapper = invokeExpr.getMethod();
						
						if(!MyConstants.COUNT_LOC){
							System.out.println("optimizer2: " + wrapper);
						}
						
						if(!methodToRemoveIndexes.containsKey(wrapper)){
							if(!MyConstants.COUNT_LOC){
								System.out.println(wrapper + " doesn't need adjustment");
							}
							continue;
						}
						
						List<Integer> indexesToRemove = methodToRemoveIndexes.get(wrapper);
						
						//System.out.println(indexesToRemove);
						
						List<Type> newArgTypes = methodToTypeList.get(wrapper);
						if(MyConstants.DEBUG_INFO)
							System.out.println("newArgTypes:" + newArgTypes);
						//int boolNumber = methodToBoolNumber.get(wrapper);
						
						String oldMethodName = wrapper.getName();
						SootClass oldMethodClass = wrapper.getDeclaringClass();
						Type oldReturnType = wrapper.getReturnType();
						//List<Type> oldParameterTypes = wrapper.getParameterTypes();
						
						//wrapper.setParameterTypes(newArgTypes);
						if(!methodsToRemove.contains(wrapper)){
							methodsToRemove.add(wrapper);
						}
						//methodToRemoveToClass.put(wrapper, wrapper.getDeclaringClass());
						
						
						//int rangeBack = boolNumber * 3;
						//int rangeForward = boolNumber;
						
						//System.out.println("optimizer2: " + rangeBack + " " + rangeForward);
						
						List<Value> args = invokeExpr.getArgs();
						
						
						List<Value> nargs = new ArrayList<Value>();
						for(Value v : args){
							nargs.add(v);
						}
						
						if(MyConstants.DEBUG_INFO)
							System.out.println("nargs:" + nargs);
						
						int deduction = 0;
						for(Integer i : indexesToRemove){
							Value arg = invokeExpr.getArg(i.intValue());
							//System.out.println("arg" + arg);
							
							int adjustedIndex = i.intValue() - deduction;
							nargs.remove(adjustedIndex);
							deduction++;
							
							if(MyConstants.DEBUG_INFO)
								System.out.println("nargs:" + nargs);
							
							Unit back = s;
							//for(int b=0;b<rangeBack;b++){
							back = body.getUnits().getPredOf(back);
							while(back.getTags().contains(beforeWrapperTag)){
								
								List<ValueBox> vbs = back.getUseAndDefBoxes();
								Iterator iter = vbs.iterator();
								boolean isUsed = false;
								while(iter.hasNext()){
									ValueBox vb = (ValueBox)iter.next();
									if(vb.getValue() instanceof Local){
										if(((Local)vb.getValue()).equivTo((Local)arg)){
											isUsed = true;
										}
									}
								}
								if(isUsed){
									toRemove.add((Stmt)back);
								}
								back = body.getUnits().getPredOf(back);
							}
							
							Unit forward = s;
							//for(int f=0;f<rangeForward;f++){
							forward = body.getUnits().getSuccOf(forward);
							while(forward.getTags().contains(afterWrapperTag)){
								
								List<ValueBox> vbs = forward.getUseAndDefBoxes();
								Iterator iter = vbs.iterator();
								boolean isUsed = false;
								while(iter.hasNext()){
									ValueBox vb = (ValueBox)iter.next();
									if(vb.getValue() instanceof Local){
										if(((Local)vb.getValue()).equivTo((Local)arg)){
											isUsed = true;
										}
									}
								}
								if(isUsed){
									toRemove.add((Stmt)forward);
								}
								forward = body.getUnits().getSuccOf(forward);
							}
						}
						
						
						
						
						/*
						List<Type> nargsType = new ArrayList<Type>();
						for(Value v : nargs){
							nargsType.add(v.getType());
						}
						*/
						
						//System.out.println("nargsType: " + nargsType);
						SootMethod toCall = Scene.v().getMethod(SootMethod.getSignature(
								oldMethodClass, oldMethodName, newArgTypes, oldReturnType));
						
						if(MyConstants.DEBUG_INFO)
							System.out.println("toCall:" + toCall);
						/*
						invokeExpr.setMethodRef(toCall.makeRef());
						int argC = 0;
						for(Value v : nargs){
							invokeExpr.setArg(argC, v);
							argC++;
						}
						*/
						
						//}
						
						if(s instanceof InvokeStmt){
							
							if(invokeExpr instanceof StaticInvokeExpr){
								
								InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(toCall.makeRef(), nargs));
								nStmt.addTag(instrumentationTag);
								nStmt.addTag(invokeWrapperTag);
								toInstrumentAt.put(nStmt, s);
							}else if(invokeExpr instanceof VirtualInvokeExpr){
								Value base = ((VirtualInvokeExpr) invokeExpr).getBase();
								if(base instanceof Local){
									InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr((Local)base, toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}
							}else if(invokeExpr instanceof SpecialInvokeExpr){
								Value base = ((SpecialInvokeExpr) invokeExpr).getBase();
								if(base instanceof Local){
									InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr((Local)base, toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}
							}else if(invokeExpr instanceof InterfaceInvokeExpr){
								Value base = ((InterfaceInvokeExpr) invokeExpr).getBase();
								if(base instanceof Local){
									InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newInterfaceInvokeExpr((Local)base, toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}
							}
							
							
						}else if(s instanceof DefinitionStmt){
							Value nlhs = ((DefinitionStmt)s).getLeftOp();
							if(invokeExpr instanceof StaticInvokeExpr){
								AssignStmt nStmt = Jimple.v().newAssignStmt(
										nlhs, Jimple.v().newStaticInvokeExpr(toCall.makeRef(), nargs));
								nStmt.addTag(instrumentationTag);
								nStmt.addTag(invokeWrapperTag);
								toInstrumentAt.put(nStmt, s);
							}else if(invokeExpr instanceof VirtualInvokeExpr){
								Value base = ((VirtualInvokeExpr) invokeExpr).getBase();
								if(base instanceof Local){
									AssignStmt nStmt = Jimple.v().newAssignStmt(
											nlhs, Jimple.v().newVirtualInvokeExpr((Local)base, toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}
							}else if(invokeExpr instanceof SpecialInvokeExpr){
								Value base = ((SpecialInvokeExpr) invokeExpr).getBase();
								if(base instanceof Local){
									AssignStmt nStmt = Jimple.v().newAssignStmt(
											nlhs, Jimple.v().newSpecialInvokeExpr((Local)base, toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}
							}else if(invokeExpr instanceof InterfaceInvokeExpr){
								Value base = ((InterfaceInvokeExpr) invokeExpr).getBase();
								if(base instanceof Local){
									AssignStmt nStmt = Jimple.v().newAssignStmt(
											nlhs, Jimple.v().newInterfaceInvokeExpr((Local)base, toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}
							}
						}
						
							
						/*
						Iterator targets = new Targets(cg.edgesOutOf(s));
						while (targets.hasNext()) {
							SootMethod target = (SootMethod) targets.next();
							//System.out.println(method + " may call " + target);
							if(methodToRemoveIndexes.containsKey(target)){
								List<Integer> indexesToRemove = methodToRemoveIndexes.get(target);
								for(Integer i : indexesToRemove){
									
								}
							}
						}	
						*/					 
					}
				}
				
				if(!MyConstants.COUNT_LOC){
					System.out.println("removing statements...");
				}
				for(Stmt s : toRemove){
					body.getUnits().remove(s);
				}
				
				if(!MyConstants.COUNT_LOC){
					System.out.println("redirecting invocation...");
				}
				Set<Stmt> keySet = toInstrumentAt.keySet();
				Iterator<Stmt> keyIterator = keySet.iterator();
				while (keyIterator.hasNext()) {

					Stmt toReplace = keyIterator.next();
					Stmt s = (Stmt) toInstrumentAt.get(toReplace);

					body.getUnits().insertBefore(toReplace, s);
					body.getUnits().remove(s);
				}
				
				if(!MyConstants.COUNT_LOC){
					System.out.println("done with method: " + method);
				}
			}
			
			/*			
			//System.out.println(methodsToRemove);
			for(SootMethod m : methodsToRemove){
				
				//System.out.println("removing " + m);
				m.getDeclaringClass().removeMethod(m);
			}
			*/
		}
		
		for(SootMethod m : methodsToRemove){
			
			//System.out.println("removing " + m);
			m.getDeclaringClass().removeMethod(m);
		}
		
	}
	
	//remove redundant statements (with wrapperBeginTag/wrapperEndTag)
	private void doOptimization1(){
		
		System.out
			.println("optimizing the instrumentation code, phase one...");

		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
	
			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			if(!MyConstants.COUNT_LOC){
				System.out.println("optimizing class " + soot_class);
			}
	
	
			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				if(!method.getTags().contains(wrapperMethodTag)){
					continue;
				}

				if(!MyConstants.COUNT_LOC){
					System.out.println("optimizing method " + method);
				}

				JimpleBody body = (JimpleBody) method.retrieveActiveBody();

				ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);

				MyReachingDefinition mrd = new MyReachingDefinition(eug);
				
				List<Stmt> toRemove = new ArrayList<Stmt>();
				List<Stmt> toKeep = new ArrayList<Stmt>();
				
				List<Local> beginLocals = new ArrayList<Local>();
				//List<Local> beginLocalsToKeep = new ArrayList<Local>();
				List<Stmt> beginStmts = new ArrayList<Stmt>();
				LinkedHashMap<Local, Stmt> beginLocalToStmt = new LinkedHashMap<Local, Stmt>();
				
				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					//System.out.println(s + "|tags:" + s.getTags());
					if(s.getTags().contains(wrapperEndTag)){
						//System.out.println(s);					
						if(s instanceof DefinitionStmt){
							Value lhs = ((DefinitionStmt) s).getLeftOp();
							Value rhs = ((DefinitionStmt) s).getRightOp();
							
							if(rhs instanceof Local){
								
								//if(!toRemove.contains(s)){
									
									toKeep.add(s);
									
									List<Unit> defs = mrd.getDefsOfAt((Local)rhs, s);
									//System.out.println(s + " has defs: " + defs);
									if(defs.size()==1){
										Stmt def = (Stmt)defs.get(0);
										
										/*
										if(def.getTags().contains(wrapperBeginTag)){
											toRemove.add(s);
										}
										*/
										
										if(def instanceof DefinitionStmt){
											Value defRHS = ((DefinitionStmt) def).getRightOp();
											if(defRHS.equivTo(lhs)){
												System.out.println("OP1: " + s + " def: " + def + " | " + lhs);
												toRemove.add(s);
												toKeep.remove(s);
											}
										}
										
									}
								//}
								
							}
						}
					}else if(s.getTags().contains(wrapperBeginTag)){
						if(s instanceof DefinitionStmt){
							Value lhs = ((DefinitionStmt) s).getLeftOp();
							if(lhs instanceof Local){
								beginLocals.add((Local)lhs);
								beginStmts.add(s);
								beginLocalToStmt.put((Local)lhs, s);
							}
						}
					}
				}
				
				if(MyConstants.DEBUG_INFO)
					System.out.println("toRemove: " + toRemove);
				for(Stmt s : toRemove){
					body.getUnits().remove(s);
				}
				
				//toRemove = new ArrayList<Stmt>();
				
				//if this method is sink, taint can go to the checking (if) statement or a static field
				Iterator it2 = body.getUnits().iterator();
				while (it2.hasNext()) {
					Stmt s = (Stmt)it2.next();
					if(s.getTags().contains(instrumentationTag)){
						if(s instanceof IfStmt){
							toKeep.add(s);
						}else if(s instanceof DefinitionStmt){
							//static field
						}
					}
				}
				
				if(MyConstants.DEBUG_INFO)
					System.out.println("toKeep: " + toKeep);
				for(Stmt s : toKeep){
					
					Stack<Stmt> stack = new Stack<Stmt>();
					stack.push(s);
					
					List<Stmt> allToKeep = new ArrayList<Stmt>();
					allToKeep.add(s);
					
					while(!stack.isEmpty()){
						Stmt def = stack.pop();
						//System.out.println("popping def: " + def);
						
						if(def.getTags().contains(wrapperBeginTag)){
							if(beginStmts.contains(def)){
								//System.out.println("removing " + def);
								beginStmts.remove(def);
							}
							continue;
						}
						
						
						if(def instanceof DefinitionStmt){
							
							Value rhs = ((DefinitionStmt) def).getRightOp();
							if(rhs instanceof Local){
								List<Unit> defs = mrd.getDefsOfAt((Local)rhs, def);
								Iterator iter = defs.iterator();
								while(iter.hasNext()){
									Stmt def1 = (Stmt)iter.next();
									if(!allToKeep.contains(def1)){
										stack.push(def1);
										allToKeep.add(def1);
									}
								}
							}else if(rhs instanceof OrExpr){
								Value op1 = ((OrExpr) rhs).getOp1();
								Value op2 = ((OrExpr) rhs).getOp2();
								
								if(op1 instanceof Local){
									List<Unit> defs = mrd.getDefsOfAt((Local)op1, def);
									Iterator iter = defs.iterator();
									while(iter.hasNext()){
										Stmt def1 = (Stmt)iter.next();
										if(!allToKeep.contains(def1)){
											stack.push(def1);
											allToKeep.add(def1);
										}
									}
								}
								
								if(op2 instanceof Local){
									List<Unit> defs_op2 = mrd.getDefsOfAt((Local)op2, def);
									//System.out.println("defs_op2: " + defs_op2);
									Iterator iter_op2 = defs_op2.iterator();
									while(iter_op2.hasNext()){
										Stmt def1 = (Stmt)iter_op2.next();
										//System.out.println("pushing op2's def onto stack: " + def1);
										if(!allToKeep.contains(def1)){
											stack.push(def1);
											allToKeep.add(def1);
										}
									}
									//System.out.println("finish pushing");
								}
							}else if(rhs instanceof InstanceFieldRef){
								Iterator iti = body.getUnits().iterator();
								while (iti.hasNext()) {
									Stmt si = (Stmt) iti.next();
									if(si instanceof DefinitionStmt){
										Value lhsOfSi = ((DefinitionStmt) si).getLeftOp();
										if(lhsOfSi instanceof InstanceFieldRef){
											if(lhsOfSi.equivTo(rhs)){
												if(!allToKeep.contains(si)){
													stack.push(si);
													allToKeep.add(si);
												}
											}
										}
									}
								}
							}							
							
						}else if(def instanceof IfStmt){
							List<ValueBox> vbs = def.getUseBoxes();
							Iterator iUse = vbs.iterator();
							while(iUse.hasNext()){
								ValueBox vb = (ValueBox)iUse.next();
								if(vb.getValue() instanceof Local){
									Local l = (Local)vb.getValue();
									List<Unit> defs = mrd.getDefsOfAt(l, def);
									for(Unit u : defs){
										if(!allToKeep.contains((Stmt)u)){
											stack.push((Stmt)u);
											allToKeep.add((Stmt)u);
										}
										//stack.push((Stmt)u);
									}
								}
							}
						}
					}
					
					
				}
				
				//if this method is sink, taint can go to the checking (if) statement or a static field
				
				/*
				List<Stmt> beginStmtsToKeep = new ArrayList<Stmt>();
				for(Stmt s : beginStmts){
					Iterator it2 = body.getUnits().iterator();
					while (it2.hasNext()) {
						Stmt ifStmtOrStaticField = (Stmt) it2.next();
						if(ifStmtOrStaticField instanceof IfStmt){
							List<ValueBox> vbs = ifStmtOrStaticField.getUseBoxes();
							Iterator iUse = vbs.iterator();
							while(iUse.hasNext()){
								ValueBox vb = (ValueBox)iUse.next();
								if(vb.getValue() instanceof Local){
									Local l = (Local)vb.getValue();
									List<Unit> defs = mrd.getDefsOfAt(l, ifStmtOrStaticField);
									
									if(defs.contains(s)){
										if(!beginStmtsToKeep.contains(s)){
											beginStmtsToKeep.add(s);
										}
									}
									
									for(Unit def : defs){
										
									}
								}
							}
						}else if(ifStmtOrStaticField instanceof DefinitionStmt){
							//static field
						}
					}
				}
				
				for(Stmt s : beginStmtsToKeep){
					if(beginStmts.contains(s)){
						beginStmts.remove(s);
					}
				}
				
				*/
				
				List<Stmt> toRemove2 = new ArrayList<Stmt>();
				List<Stmt> delta = new ArrayList<Stmt>();
				for(Stmt s : beginStmts){
					toRemove2.add(s);
					delta.add(s);
				}
				
				for(Stmt begin : beginStmts){
					Iterator it4 = body.getUnits().iterator();
					while(it4.hasNext()){
						Stmt s = (Stmt)it4.next();
						if(s.getTags().contains(instrumentationTag)){
							if(s instanceof DefinitionStmt){
								Value lhs = ((DefinitionStmt) s).getLeftOp();
								Value rhs = ((DefinitionStmt) s).getRightOp();
								
								if(rhs instanceof Local){
									List<Unit> defs = mrd.getDefsOfAt((Local)rhs, s);
									if(defs.contains(begin)){
										if(lhs instanceof InstanceFieldRef || lhs instanceof StaticFieldRef){
											if(toRemove2.contains(begin)){
												toRemove2.remove(begin);
												delta.remove(begin);
											}
											
										}
									}
								}								
							}
						}
					}
				}
				
				if(MyConstants.DEBUG_INFO)
					System.out.println("method:" + method.getSignature() + "|beginStmts: " + beginStmts);
				
				
				
				while(!delta.isEmpty()){
					
					delta = new ArrayList<Stmt>();
					
					Iterator it3 = body.getUnits().iterator();
					while (it3.hasNext()) {
						Stmt s = (Stmt) it3.next();
						if(s.getTags().contains(instrumentationTag)){
							List<ValueBox> vbs = s.getUseBoxes();
							Iterator iUse = vbs.iterator();
							while(iUse.hasNext()){
								ValueBox vb = (ValueBox)iUse.next();
								if(vb.getValue() instanceof Local){
									Local l = (Local)vb.getValue();
									List<Unit> defs = mrd.getDefsOfAt(l, s);
									if(defs.size()==1){
										Stmt def = (Stmt)defs.get(0);
										if(toRemove2.contains(def)){
											
																					
											if(!toRemove2.contains(s)){
												toRemove2.add(s);
												delta.add(s);
											}
										}
									}
								}
							}
						}
					}
				}
				if(MyConstants.DEBUG_INFO)
					System.out.println("method:" + method.getSignature() + "|toRemove2: " + toRemove2);
				
				for(Stmt s : toRemove2){
					body.getUnits().remove(s);
				}
				
				
				
				
				/*
				Iterator it1 = body.getUnits().iterator();
				while (it1.hasNext()) {
					Stmt s = (Stmt) it1.next();
					if(!s.getTags().contains(wrapperBeginTag)){
						List<ValueBox> vbs = s.getUseBoxes();
						Iterator i = vbs.iterator();
						while(i.hasNext()){
							ValueBox vb = (ValueBox)i.next();
							if(vb.getValue() instanceof Local){
								if(beginLocals.contains((Local)vb.getValue())){
									
									if(mrd.getDefsOfAt((Local)vb.getValue(), s).contains(beginLocalToStmt.get((Local)vb.getValue()))){									
										beginLocals.remove((Local)vb.getValue());
									}
								}
							}
						}
					}
					
				}
				*/
				
				/*
				if(!beginLocals.isEmpty()){
					for(Stmt s : beginStmts){
						Local def = (Local)(((DefinitionStmt)s).getLeftOp());
						if(beginLocals.contains(def)){
							body.getUnits().remove(s);
						}
					}
				}
				*/
				
				/*
				if(!beginLocals.isEmpty()){
					for(Local l : beginLocals){
						body.getUnits().remove(beginLocalToStmt.get(l));
					}
				}
				*/
			}
		}
		
	}
	
	private void addQueryMethod(){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}

			if(soot_class.isPhantom()){
				continue;
			}
			
			//if(soot_class.getSuperclass().getName().equals("android.app.Activity") || soot_class.getSuperclass().getName().equals("android.app.Service")){
				addQueryServiceMethod(soot_class);
			//}
		}
		
	}
	
	private void addWrappers(){

		if(!MyConstants.COUNT_LOC){
			System.out.println("adding wrapper methods for those propagate information...");
		}		

		//List<SootMethod> sMethods = new ArrayList<SootMethod>();
		//LinkedHashMap<SootMethod, Vector<String>> sMethodsWithSources = new LinkedHashMap<SootMethod, Vector<String>>();

		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}

			if(soot_class.isPhantom()){
				continue;
			}

			if(!MyConstants.COUNT_LOC){			
				System.out.println("processing " + soot_class.getName() + "..." );
			}

			List<SootMethod> methods = soot_class.getMethods();

			for (SootMethod method : methods) {

				if(method.isConcrete()==false){
					continue;
				}

				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();

					if ((s.getTags().contains(generalTaintTag))) {

						Vector<Integer> labels = new Vector<Integer>();

						for(Tag tag : s.getTags()){
							if(taintTagReverseMap.containsKey(tag)){
								Integer label = new Integer(((TaintTag)tag).getLabel());
								if(!labels.contains(label)){
									labels.add(label);
								}
							}else if(extraDefTagReverseMap.containsKey(tag)){
								Integer label = new Integer(((TaintTag)tag).getLabel());
								if(!labels.contains(label)){
									labels.add(label);
								}
							}								
						}	

						if(s instanceof InvokeStmt){

							SootMethod sMethod = ((InvokeStmt)s).getInvokeExpr().getMethod();
							//if(sMethod.getName().equals("getDeviceId") || sMethod.getName().equals("send")){
							//getSignature().equals("<java.io.OutputStream: void write(byte[],int,int)>")
							//if(sMethod.getName().equals(MyConstants.leakSource) 
							//|| sMethod.getSignature().equals("<java.io.OutputStream: void write(byte[],int,int)>")){
							if(srcs.contains(sMethod.getSignature()) || sinks.contains(sMethod.getSignature())){

							}
							else{
								//if(!sMethods.contains(sMethod)){
								//	sMethods.add(sMethod);
								//}
								
								if(sMethodsWithSources.containsKey(sMethod)){
									Vector<Integer> oldLabels = sMethodsWithSources.get(sMethod);
									for(Integer label : labels){
										if(!oldLabels.contains(label)){
											oldLabels.add(label);
										}
									}
								}else{
									Vector<Integer> newLabels = new Vector<Integer>();
									newLabels.addAll(labels);
									sMethodsWithSources.put(sMethod, newLabels);
								}								


								if(sMethod.isAbstract()){
									Iterator targets = new Targets(cg.edgesOutOf(method));
									while (targets.hasNext()) {
										SootMethod target = (SootMethod) targets.next();
										//System.out.println(method + " may call " + target);
										if(target.getSubSignature().equals(sMethod.getSubSignature())){
											if(sMethodsWithSources.containsKey(target)){
												Vector<Integer> oldLabels = sMethodsWithSources.get(target);
												for(Integer label : labels){
													if(!oldLabels.contains(label)){
														oldLabels.add(label);
													}
												}
											}else{
												Vector<Integer> newLabels = new Vector<Integer>();
												newLabels.addAll(labels);
												sMethodsWithSources.put(target, newLabels);
											}
										}
									}
									
								}
							}

						}else if (s instanceof DefinitionStmt) {

							Value rhs = ((DefinitionStmt) s).getRightOp();
							Value lhs = ((DefinitionStmt) s).getLeftOp();

							if (rhs instanceof InvokeExpr) {

								SootMethod sMethod = ((InvokeExpr)rhs).getMethod();
								//if(sMethod.getName().equals("getDeviceId") || sMethod.getName().equals("send")){
								//if(sMethod.getName().equals(MyConstants.leakSource) 
								//|| sMethod.getSignature().equals("<java.io.OutputStream: void write(byte[],int,int)>")){
								if(srcs.contains(sMethod.getSignature()) || sinks.contains(sMethod.getSignature())){

								}else{
									//if(!sMethods.contains(sMethod)){
									//	sMethods.add(sMethod);
									//}

									if(sMethodsWithSources.containsKey(sMethod)){
										Vector<Integer> oldLabels = sMethodsWithSources.get(sMethod);
										for(Integer label : labels){
											if(!oldLabels.contains(label)){
												oldLabels.add(label);
											}
										}
									}else{
										Vector<Integer> newLabels = new Vector<Integer>();
										newLabels.addAll(labels);
										sMethodsWithSources.put(sMethod, newLabels);
									}
									
									if(sMethod.isAbstract()){
										Iterator targets = new Targets(cg.edgesOutOf(method));
										while (targets.hasNext()) {
											SootMethod target = (SootMethod) targets.next();
											//System.out.println(method + " may call " + target);
											if(target.getSubSignature().equals(sMethod.getSubSignature())){
												if(sMethodsWithSources.containsKey(target)){
													Vector<Integer> oldLabels = sMethodsWithSources.get(target);
													for(Integer label : labels){
														if(!oldLabels.contains(label)){
															oldLabels.add(label);
														}
													}
												}else{
													Vector<Integer> newLabels = new Vector<Integer>();
													newLabels.addAll(labels);
													sMethodsWithSources.put(target, newLabels);
												}
											}
										}
										
									}
								}
							}
						}
					}
				}
			}

		}


		//System.out.println("add wrappers");

		Set<SootMethod> methKeySet = sMethodsWithSources.keySet();
		Iterator<SootMethod> methIter = methKeySet.iterator();
		while(methIter.hasNext()){
			SootMethod m = methIter.next();
			//Vector<Integer> labels = sMethodsWithSources.get(m);


			if(m.getSignature().equals("<java.lang.Object: void <init>()>")){
				continue;
			}

			if(m.getDeclaringClass().isApplicationClass()==false){
				continue;
			}

			if(m.getDeclaringClass().isPhantom()){
				continue;
			}

			if(!MyConstants.COUNT_LOC){
				System.out.println("add wrappers for method: " + m);
			}				

			SootClass sClass = m.getDeclaringClass();

			String boolWrapper = "";
			if(sClass.getPackageName().equals("")){
				boolWrapper = MyConstants.boolWrapper;
			}else{
				boolWrapper = sClass.getPackageName() + "." + MyConstants.boolWrapper;
			}


			String boolField = "<" + boolWrapper + ": boolean b>";

			String methodName = m.getName();

			if(!m.isConcrete()){
				int argCount = m.getParameterCount();
				List<Type> argTypes = m.getParameterTypes();
				List<Type> newArgTypes = new ArrayList<Type>();
				for(Type t : argTypes){
					newArgTypes.add(t);
				}

				Type retType = m.getReturnType();
				int modifier = m.getModifiers();

				int count = argCount;
				for(int i=0;i<argCount;i++){						
					newArgTypes.add(RefType.v(boolWrapper));
					count++;
				}

				if(!m.isStatic()){
					newArgTypes.add(RefType.v(boolWrapper));
					count++;
				}

				if(!(retType.equals(VoidType.v()))){
					newArgTypes.add(RefType.v(boolWrapper));
					count++;
				}

				if(!MyConstants.COUNT_LOC){
					System.out.println("wrapper name: " + getWrapperMethodName(methodName));
				}
				SootMethod wrapperMethod = new SootMethod(getWrapperMethodName(methodName),
						newArgTypes, retType, modifier);
				if(!wrapperMethod.getTags().contains(isWrapperTag)){
					wrapperMethod.addTag(isWrapperTag);
				}


				//System.out.println("adding wrappers");
				sClass.addMethod(wrapperMethod);

				continue;
			}


			/*
					if(methodName.equals("<init>")){
						System.out.println("<init> signature:" + m.getSignature());
						continue;
					}
			 */	

			//Vector<Integer> labelInts = decodeLabelString(label);
			int multiple = sourceCount;

			int argCount = m.getParameterCount();
			List<Type> argTypes = m.getParameterTypes();
			List<Type> newArgTypes = new ArrayList<Type>();
			for(Type t : argTypes){
				newArgTypes.add(t);
			}

			Type retType = m.getReturnType();
			int modifier = m.getModifiers();

			//if((JimpleBody)m.hasActiveBody())
			//System.out.println("getting jimple body");

			JimpleBody oldBody = (JimpleBody)m.getActiveBody();

			//JimpleBody oldBody = (JimpleBody)m.retrieveActiveBody();
			//System.out.println("got jimple body");


			Chain oldUnits = oldBody.getUnits();
			Chain oldLocals = oldBody.getLocals();


			List<Local> addedLocals = new ArrayList<Local>();
			List<Local> addedParameterLocals = new ArrayList<Local>();
			Local addedThisLocal = null;
			Local addedReturnLocal = null;
			List<Unit> addedIdentityStmts = new ArrayList<Unit>();
			List<Unit> beginAssignStmts = new ArrayList<Unit>();
			List<Unit> endAssignStmts = new ArrayList<Unit>();
			List<Unit> retAssignStmts = new ArrayList<Unit>();

			int count = argCount;
			for(int i=0;i<argCount;i++){
				for(int j=0;j<multiple;j++){

					newArgTypes.add(RefType.v(boolWrapper));

					Local wParameter = Jimple.v().newLocal("w_s" + j + "_p" + i, RefType.v(boolWrapper));
					addedLocals.add(wParameter);
					addedParameterLocals.add(wParameter);

					Stmt parameterStmt = Jimple.v().newIdentityStmt(
							wParameter, Jimple.v().newParameterRef(RefType.v(boolWrapper), count));
					parameterStmt.addTag(instrumentationTag);
					addedIdentityStmts.add(parameterStmt);

					count++;
				}
			}

			if(!m.isStatic()){
				for(int j=0;j<multiple;j++){
					newArgTypes.add(RefType.v(boolWrapper));
					Local wThis = Jimple.v().newLocal("w_s" + j + "_t", RefType.v(boolWrapper));
					addedLocals.add(wThis);
					addedThisLocal = wThis;

					Stmt thisStmt = Jimple.v().newIdentityStmt(
							wThis, Jimple.v().newParameterRef(RefType.v(boolWrapper), count));
					thisStmt.addTag(instrumentationTag);
					addedIdentityStmts.add(thisStmt);

					count++;
				}
			}

			if(!(retType.equals(VoidType.v()))){
				for(int j=0;j<multiple;j++){
					newArgTypes.add(RefType.v(boolWrapper));
					Local wReturn = Jimple.v().newLocal("w_s" + j + "_r", RefType.v(boolWrapper));
					addedLocals.add(wReturn);
					addedReturnLocal = wReturn;

					Stmt returnStmt = Jimple.v().newIdentityStmt(
							wReturn, Jimple.v().newParameterRef(RefType.v(boolWrapper), count));
					returnStmt.addTag(instrumentationTag);
					addedIdentityStmts.add(returnStmt);

					count++;
				}
			}

			if(!MyConstants.COUNT_LOC){
				System.out.println("wrapper name: " + getWrapperMethodName(methodName));
			}
			SootMethod wrapperMethod = new SootMethod(getWrapperMethodName(methodName),
					newArgTypes, retType, modifier);
			if(!wrapperMethod.getTags().contains(isWrapperTag)){
				wrapperMethod.addTag(isWrapperTag);
			}


			//System.out.println("adding wrappers");
			sClass.addMethod(wrapperMethod);
			//System.out.println("added wrappers");


			//
			//wrapperMethod.setActiveBody(oldBody);
			//wrapperMethod.addTag(wrapperMethodTag);

			//JimpleBody newBody = (JimpleBody)wrapperMethod.getActiveBody();
			//Chain newUnits = newBody.getUnits();




			JimpleBody newBody = Jimple.v().newBody(wrapperMethod);


			wrapperMethod.setActiveBody(newBody);
			wrapperMethod.addTag(wrapperMethodTag);

			if(MyConstants.DEBUG_INFO)
				System.out.println("wrapper: " + wrapperMethod);

			Chain newUnits = newBody.getUnits();
			//Chain newLocals = newBody.getLocals();

			Iterator oldLocalIter = oldLocals.iterator();
			while(oldLocalIter.hasNext()){
				Local l = (Local)oldLocalIter.next();
				//Local newLocal = (Local)l.clone();
				//Local newLocal = Jimple.v().newLocal(l.getName(), l.getType());
				//newBody.getLocals().add(newLocal);
				newBody.getLocals().add(l);
			}

			for(Local l : addedLocals){
				newBody.getLocals().add(l);
			}

			if(MyConstants.DEBUG_INFO)
				System.out.println("local chains: " + wrapperMethod.getActiveBody().getLocals());

			//clone while keeping a mapping, for if-like statements, find corresponding target in old units and map
			//to the one in new units
			LinkedHashMap<Stmt, Stmt> oldStmtToNewStmt = new LinkedHashMap<Stmt, Stmt>();

			Iterator oldIter = oldUnits.iterator();
			while(oldIter.hasNext()){
				Stmt s = (Stmt)oldIter.next();		        	
				Stmt newUnit = (Stmt)s.clone();

				newUnit.addAllTagsOf(s);
				s.removeAllTags();
				/*
			        	if(s.getTags().contains(taintTag)){
			        		newUnit.addTag(taintTag);
			        		s.removeAllTags();
			        	}else if(s.getTags().contains(extraDefTag)){
			        		newUnit.addTag(extraDefTag);
			        		s.removeAllTags();
			        	}
				 */

				oldStmtToNewStmt.put(s, newUnit);
			}

			//moved to the end
			/*
			for(Trap t : oldBody.getTraps()){
				Unit oldBegin = t.getBeginUnit();
				Unit oldEnd = t.getEndUnit();
				Unit oldHandler = t.getHandlerUnit();
				SootClass ex = t.getException();

				Unit newBegin = oldStmtToNewStmt.get((Stmt)oldBegin);
				Unit newEnd = oldStmtToNewStmt.get((Stmt)oldEnd);
				Unit newHandler = oldStmtToNewStmt.get((Stmt)oldHandler);

				newBody.getTraps().add(Jimple.v().newTrap(ex, newBegin, newEnd, newHandler));
			}
			*/

			Set<Stmt> keySet = oldStmtToNewStmt.keySet();
			Iterator<Stmt> keyIterator = keySet.iterator();
			while (keyIterator.hasNext()) {

				Stmt oldStmt = keyIterator.next();
				Stmt newStmt = (Stmt) oldStmtToNewStmt.get(oldStmt);

				if(oldStmt instanceof IfStmt){
					Stmt oldTarget = ((IfStmt) oldStmt).getTarget();
					Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
					((IfStmt) newStmt).setTarget(newTarget);
				}else if(oldStmt instanceof GotoStmt){
					Stmt oldTarget = (Stmt)((GotoStmt) oldStmt).getTarget();
					Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
					((GotoStmt) newStmt).setTarget(newTarget);
				}else if(oldStmt instanceof LookupSwitchStmt){
					List<Stmt> oldTargets = ((LookupSwitchStmt) oldStmt).getTargets();
					List<Stmt> newTargets = new ArrayList<Stmt>();
					for(Stmt oldTarget : oldTargets){
						Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
						newTargets.add(newTarget);
					}						 

					Stmt[] newTargetsArray = new Stmt[newTargets.size()];
					for(int i=0;i<newTargets.size();i++){
						newTargetsArray[i] = newTargets.get(i);
					}
					((LookupSwitchStmt) newStmt).setTargets(newTargetsArray);
					//((LookupSwitchStmt) newStmt).setTargets((Stmt[])newTargets.toArray());

					Stmt oldDefaultTarget = (Stmt)((LookupSwitchStmt) oldStmt).getDefaultTarget();
					Stmt newDefaultTarget = oldStmtToNewStmt.get(oldDefaultTarget);
					((LookupSwitchStmt) newStmt).setDefaultTarget(newDefaultTarget);

				}else if(oldStmt instanceof TableSwitchStmt){
					List<Stmt> oldTargets = ((TableSwitchStmt) oldStmt).getTargets();						
					List<Unit> newTargets = new ArrayList<Unit>();
					for(Stmt oldTarget : oldTargets){
						Stmt newTarget = oldStmtToNewStmt.get(oldTarget);
						newTargets.add(newTarget);
					}						 
					((TableSwitchStmt) newStmt).setTargets(newTargets);

					Stmt oldDefaultTarget = (Stmt)((TableSwitchStmt) oldStmt).getDefaultTarget();
					Stmt newDefaultTarget = oldStmtToNewStmt.get(oldDefaultTarget);
					((TableSwitchStmt) newStmt).setDefaultTarget(newDefaultTarget);
				}


				newUnits.add(newStmt);
			}


			List<Stmt> returnStmts = new ArrayList<Stmt>();
			List<Stmt> returnVoidStmts = new ArrayList<Stmt>();

			Iterator iNewUnits = newUnits.iterator();
			while(iNewUnits.hasNext()){
				Stmt s =(Stmt)iNewUnits.next();
				if(s instanceof IdentityStmt){
					Value lhs = ((IdentityStmt) s).getLeftOp();
					Value rhs = ((IdentityStmt) s).getRightOp();

					if(rhs instanceof ParameterRef){

						if(MyConstants.DEBUG_INFO)
							System.out.println("parameterref");
						int argc = ((ParameterRef)rhs).getIndex();

						if(lhs instanceof Local){

							for(int lc=0;lc<sourceCount;lc++){

								String varName = ((Local) lhs).getName();
								//System.out.println(varName);

								Local taintLocal = null;

								String taintVarName = getTaintVarName(varName, lc);

								boolean hasVar = false;
								for (Local l : newBody.getLocals()) {
									if (l.getName().equals(taintVarName)) {
										hasVar = true;
										taintLocal = l;
									}
								}

								if (!hasVar) {
									taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
									newBody.getLocals().add(taintLocal);
								}

								if (taintLocal != null) {

									Stmt begin = Jimple.v().newAssignStmt(
											taintLocal, Jimple.v().newInstanceFieldRef(
													addedParameterLocals.get(argc), Scene.v().getField(boolField).makeRef()));
									begin.addTag(instrumentationTag);
									begin.addTag(wrapperBeginTag);
									beginAssignStmts.add(begin);
									//System.out.println("begin added: " + begin);

									Stmt end = Jimple.v().newAssignStmt(
											Jimple.v().newInstanceFieldRef(
													addedParameterLocals.get(argc), Scene.v().getField(boolField).makeRef()), taintLocal);
									end.addTag(instrumentationTag);
									end.addTag(wrapperEndTag);
									endAssignStmts.add(end);
									//System.out.println("end added: " + end);
								}

							}

						}

					}else if(rhs instanceof ThisRef){

						if(MyConstants.DEBUG_INFO)
							System.out.println("thisref");
						if(lhs instanceof Local){

							for(int lc=0;lc<sourceCount;lc++){

								String varName = ((Local) lhs).getName();
								//System.out.println(varName);

								Local taintLocal = null;

								String taintVarName = getTaintVarName(varName, lc);

								boolean hasVar = false;
								for (Local l : newBody.getLocals()) {
									if (l.getName().equals(taintVarName)) {
										hasVar = true;
										taintLocal = l;
									}
								}

								if (!hasVar) {
									taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
									newBody.getLocals().add(taintLocal);
								}

								if (taintLocal != null) {

									Stmt begin = Jimple.v().newAssignStmt(
											taintLocal, Jimple.v().newInstanceFieldRef(
													addedThisLocal, Scene.v().getField(boolField).makeRef()));
									begin.addTag(instrumentationTag);
									begin.addTag(wrapperBeginTag);
									beginAssignStmts.add(begin);

									Stmt end = Jimple.v().newAssignStmt(
											Jimple.v().newInstanceFieldRef(
													addedThisLocal, Scene.v().getField(boolField).makeRef()), taintLocal);
									end.addTag(instrumentationTag);
									end.addTag(wrapperEndTag);
									endAssignStmts.add(end);
								}

							}

						}

					}
				}else if(s instanceof ReturnStmt){
					returnStmts.add(s);

					Value op = ((ReturnStmt) s).getOp();
					if(op instanceof Local){

						for(int lc=0;lc<sourceCount;lc++){

							String varName = ((Local) op).getName();
							//System.out.println(varName);

							Local taintLocal = null;

							String taintVarName = getTaintVarName(varName, lc);

							boolean hasVar = false;
							for (Local l : newBody.getLocals()) {
								if (l.getName().equals(taintVarName)) {
									hasVar = true;
									taintLocal = l;
								}
							}

							if (!hasVar) {
								taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
								newBody.getLocals().add(taintLocal);
							}

							if (taintLocal != null) {

								Stmt begin = Jimple.v().newAssignStmt(
										taintLocal, Jimple.v().newInstanceFieldRef(
												addedReturnLocal, Scene.v().getField(boolField).makeRef()));
								begin.addTag(instrumentationTag);
								begin.addTag(wrapperBeginTag);
								beginAssignStmts.add(begin);

								Stmt ret = Jimple.v().newAssignStmt(
										Jimple.v().newInstanceFieldRef(
												addedReturnLocal, Scene.v().getField(boolField).makeRef()), taintLocal);
								ret.addTag(instrumentationTag);
								ret.addTag(wrapperEndTag);
								retAssignStmts.add(ret);
							}
						}
					}

				}else if(s instanceof ReturnVoidStmt){
					returnVoidStmts.add(s);
				}
			}

			Iterator iNewUnits1 = newUnits.iterator();
			while(iNewUnits1.hasNext()){
				Stmt s =(Stmt)iNewUnits1.next();
				if(s instanceof IfStmt){
					Stmt target = ((IfStmt) s).getTarget();
					if(target instanceof ReturnVoidStmt){
						if(!endAssignStmts.isEmpty()){
							((IfStmt) s).setTarget(endAssignStmts.get(0));
						}
					}else if(target instanceof ReturnStmt){
						if(!endAssignStmts.isEmpty()){
							((IfStmt) s).setTarget(endAssignStmts.get(0));
						}else if(!retAssignStmts.isEmpty()){
							((IfStmt) s).setTarget(retAssignStmts.get(0));
						}
					}
				}else if(s instanceof GotoStmt){
					Stmt target = (Stmt)((GotoStmt) s).getTarget();
					if(target instanceof ReturnVoidStmt){
						if(!endAssignStmts.isEmpty()){
							((GotoStmt) s).setTarget(endAssignStmts.get(0));
						}
					}else if(target instanceof ReturnStmt){
						if(!endAssignStmts.isEmpty()){
							((GotoStmt) s).setTarget(endAssignStmts.get(0));
						}else if(!retAssignStmts.isEmpty()){
							((GotoStmt) s).setTarget(retAssignStmts.get(0));
						}
					}
				}
			}

			if(!beginAssignStmts.isEmpty()){
				newUnits.insertBefore(beginAssignStmts, newBody.getFirstNonIdentityStmt());
			}

			if(!addedIdentityStmts.isEmpty()){
				newUnits.insertBefore(addedIdentityStmts, newBody.getFirstNonIdentityStmt());
			}

			for(Stmt s : returnVoidStmts){
				if(!endAssignStmts.isEmpty()){
					newUnits.insertBefore(endAssignStmts, s);
				}
			}

			for(Stmt s : returnStmts){
				if(!endAssignStmts.isEmpty()){
					newUnits.insertBefore(endAssignStmts, s);
				}
				if(!retAssignStmts.isEmpty()){
					newUnits.insertBefore(retAssignStmts, s);
				}
			}
			
			for(Trap t : oldBody.getTraps()){
				Unit oldBegin = t.getBeginUnit();
				Unit oldEnd = t.getEndUnit();
				Unit oldHandler = t.getHandlerUnit();
				SootClass ex = t.getException();

				Unit newBegin = oldStmtToNewStmt.get((Stmt)oldBegin);
				Unit newEnd = oldStmtToNewStmt.get((Stmt)oldEnd);
				Unit newHandler = oldStmtToNewStmt.get((Stmt)oldHandler);

				newBody.getTraps().add(Jimple.v().newTrap(ex, newBegin, newEnd, newHandler));
			}
		}


	}

	
	//type: d/v/w/i/e
	private Stmt logStmt(String type, String tag, String msg){
		
		SootMethod logX = Scene.v().getMethod("<android.util.Log: int " + type + "(java.lang.String,java.lang.String)>");
		Stmt log = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(
				logX.makeRef(), StringConstant.v(tag), StringConstant.v(msg)));
		
		log.addTag(instrumentationTag);
		log.addTag(debuggingTag);
		
		return log;		
	}
	
	private void addLog(JimpleBody body, List<Unit> newInstructions){
		newInstructions.add(logStmt("d", body.getMethod().getDeclaringClass().getName(), body.getMethod().getSignature()));
	}
	
	private void toast(JimpleBody body, List<Unit> newInstructions){
		
		//r0 := @this: TestToast;
		Local r0 = body.getThisLocal();
		
		int localCount = body.getLocalCount();
		Local r1 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("android.widget.Toast"));
        body.getLocals().add(r1);
        
        localCount = body.getLocalCount();
		Local r2 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("android.content.Context"));
        body.getLocals().add(r2);
        
        //$r2 = virtualinvoke r0.<TestToast: android.content.Context getApplicationContext()>();
        SootMethod toCall1 = Scene.v().getMethod("<android.content.Context: android.content.Context getApplicationContext()>");
        newInstructions.add(Jimple.v().newAssignStmt(r2, Jimple.v().newVirtualInvokeExpr(r0, toCall1.makeRef())));
        
        //r1 = staticinvoke <android.widget.Toast: android.widget.Toast makeText(android.content.Context,java.lang.CharSequence,int)>($r2, "hello", 0);
        SootMethod toCall2 = Scene.v().getMethod("<android.widget.Toast: android.widget.Toast makeText(android.content.Context,java.lang.CharSequence,int)>");
        List<Value> args = new ArrayList<Value>();
        args.add(r2);
        args.add(StringConstant.v("hello"));
        args.add(IntConstant.v(0));
        newInstructions.add(Jimple.v().newAssignStmt(r1, Jimple.v().newStaticInvokeExpr(toCall2.makeRef(), args)));
        
        //virtualinvoke r1.<android.widget.Toast: void show()>();
		SootMethod toCall3 = Scene.v().getMethod("<android.widget.Toast: void show()>");
		newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r1, toCall3.makeRef())));
		
	}
	
	private void showDialog(JimpleBody body, List<Unit> newInstructions){
		
		String packageName = body.getMethod().getDeclaringClass().getPackageName();
		
		String listenerClass = "";
        if(packageName.equals("")){
        	listenerClass = MyConstants.dialogListener;
        }else{
        	listenerClass = packageName + "." + MyConstants.dialogListener;
        }
		
		//r0 := @this: ShowDialog;
		Local thisLocal = null;
		
		Iterator it = body.getUnits().iterator();		
		while (it.hasNext()) {
			Stmt s = (Stmt) it.next();
			if(s instanceof IdentityStmt){
				Value rhs = ((IdentityStmt) s).getRightOp();
				if(rhs instanceof ThisRef){
					Value lhs = ((IdentityStmt) s).getLeftOp();
					thisLocal = (Local)lhs;
				}
			}
		}
		
		if(thisLocal==null){
			System.out.println("EXCEPTION: no this reference!");
			return;
		}
		
		//Chain units = body.getUnits();		
		
		int localCount = body.getLocalCount();
		Local r1 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("android.app.AlertDialog$Builder"));
        body.getLocals().add(r1);
        
        localCount = body.getLocalCount();
		Local r2 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("android.app.AlertDialog"));
        body.getLocals().add(r2);
        
        localCount = body.getLocalCount();
		Local r3 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v(listenerClass));
        body.getLocals().add(r3);
        
        localCount = body.getLocalCount();
		Local r4 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v(listenerClass));
        body.getLocals().add(r4);
        
        //$r1 = new android.app.AlertDialog$Builder;        
        newInstructions.add(Jimple.v().newAssignStmt(r1, new JNewExpr(RefType.v("android.app.AlertDialog$Builder"))));

        
        //specialinvoke $r1.<android.app.AlertDialog$Builder: void <init>(android.content.Context)>(r0);
        SootMethod toCall1 = Scene.v().getMethod("<android.app.AlertDialog$Builder: void <init>(android.content.Context)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r1, toCall1.makeRef(), thisLocal)));
        
        
        //r2 = virtualinvoke $r1.<android.app.AlertDialog$Builder: android.app.AlertDialog create()>();
        SootMethod toCall2 = Scene.v().getMethod("<android.app.AlertDialog$Builder: android.app.AlertDialog create()>");
        newInstructions.add(Jimple.v().newAssignStmt(r2, Jimple.v().newVirtualInvokeExpr(r1, toCall2.makeRef())));
        
        //virtualinvoke r2.<android.app.AlertDialog: void setTitle(java.lang.CharSequence)>("Reset...");
        SootMethod toCall3 = Scene.v().getMethod("<android.app.AlertDialog: void setTitle(java.lang.CharSequence)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r2, toCall3.makeRef(), StringConstant.v("Start..."))));
        
        //virtualinvoke r2.<android.app.AlertDialog: void setMessage(java.lang.CharSequence)>("R u sure?");
        SootMethod toCall4 = Scene.v().getMethod("<android.app.AlertDialog: void setMessage(java.lang.CharSequence)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r2, toCall4.makeRef(), StringConstant.v("R u sure?"))));
        
        //$r4 = new MyListener;
        newInstructions.add(Jimple.v().newAssignStmt(r4, new JNewExpr(RefType.v(listenerClass))));
        
        //specialinvoke $r4.<MyListener: void <init>()>();
        SootMethod toCall5 = Scene.v().getMethod("<" + packageName + ".MyListener: void <init>()>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r4, toCall5.makeRef())));
        
        //r3 = $r4;
        newInstructions.add(Jimple.v().newAssignStmt(r3, r4));
        
        //virtualinvoke r2.<android.app.AlertDialog: void setButton(java.lang.CharSequence,android.content.DialogInterface$OnClickListener)>("OK", r3);
        SootMethod toCall6 = Scene.v().getMethod("<android.app.AlertDialog: void setButton(java.lang.CharSequence,android.content.DialogInterface$OnClickListener)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r2, toCall6.makeRef(), StringConstant.v("OK"), r3)));
		
		//virtualinvoke r2.<android.app.AlertDialog: void show()>();
		SootMethod toCall7 = Scene.v().getMethod("<android.app.Dialog: void show()>");
		newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r2, toCall7.makeRef())));
	}
	
	private void addQueryServiceMethod(SootClass hostClass){
		
		String packageName = hostClass.getPackageName();
		
		String serviceReplyClass = "";
        if(packageName.equals("")){
        	serviceReplyClass = MyConstants.ServiceReply;
        }else{
        	serviceReplyClass = packageName + "." + MyConstants.ServiceReply;
        }
        
        String setReply = "<" + serviceReplyClass + ": void setReply(boolean)>";
        String getReply = "<" + serviceReplyClass + ": boolean getReply()>";
        String initReply = "<" + serviceReplyClass + ": void <init>()>";
        
        String bcrClass = "";
        if(packageName.equals("")){
        	bcrClass = MyConstants.BCReceiver;
        }else{
        	bcrClass = packageName + "." + MyConstants.BCReceiver;
        }
        
        String initBcr = "<" + bcrClass + ": void <init>("+ serviceReplyClass +")>";
		
		List<Type> params = new ArrayList<Type>();		
    	params.add(IntType.v());
    	params.add(IntType.v());
    	params.add(RefType.v("java.lang.String"));
    	params.add(RefType.v("java.lang.String"));
    	params.add(RefType.v("android.content.Context"));
        //SootMethod method = new SootMethod("queryService", new ArrayList(), BooleanType.v(), Modifier.PUBLIC);
    	SootMethod method = new SootMethod("queryService", params, BooleanType.v(), Modifier.PUBLIC);
        
    	hostClass.addMethod(method);

        JimpleBody body = Jimple.v().newBody(method);
        method.setActiveBody(body);
        
        Chain units = body.getUnits();
        
        Local r0;        
        r0 = Jimple.v().newLocal("r0", RefType.v(hostClass));
        body.getLocals().add(r0); 
        
        Local p0;
        p0 = Jimple.v().newLocal("p0", IntType.v());
        body.getLocals().add(p0);
        
        Local p1;
        p1 = Jimple.v().newLocal("p1", IntType.v());
        body.getLocals().add(p1);
        
        Local p2;
        p2 = Jimple.v().newLocal("p2", RefType.v("java.lang.String"));
        body.getLocals().add(p2);
        
        Local p3;
        p3 = Jimple.v().newLocal("p3", RefType.v("java.lang.String"));
        body.getLocals().add(p3);
        
        Local c0;
        c0 = Jimple.v().newLocal("c0", RefType.v("android.content.Context"));
        body.getLocals().add(c0);
        
        Local r1;
        r1 = Jimple.v().newLocal("r1", RefType.v(serviceReplyClass));
        body.getLocals().add(r1);
        
        Local r2;
        r2 = Jimple.v().newLocal("r2", RefType.v("android.content.IntentFilter"));
        body.getLocals().add(r2);
        
        Local r3;
        r3 = Jimple.v().newLocal("r3", RefType.v(bcrClass));
        body.getLocals().add(r3);
        
        Local r5;
        r5 = Jimple.v().newLocal("r5", RefType.v("android.content.Intent"));
        body.getLocals().add(r5);
        
        Local r6;
        r6 = Jimple.v().newLocal("r6", RefType.v("android.content.ComponentName"));
        body.getLocals().add(r6);
        
        Local r8;
        r8 = Jimple.v().newLocal("r8", RefType.v("java.lang.String"));
        body.getLocals().add(r8);
        
        Local z0;
        z0 = Jimple.v().newLocal("z0", BooleanType.v());
        body.getLocals().add(z0);
        
        Local r15;
        r15 = Jimple.v().newLocal("r15", RefType.v("java.lang.InterruptedException"));
        body.getLocals().add(r15);
        
        Local r16;
        r16 = Jimple.v().newLocal("r16", RefType.v("java.lang.InterruptedException"));
        body.getLocals().add(r16);
        
        Local r17;
        r17 = Jimple.v().newLocal("r17", RefType.v("java.lang.Throwable"));
        body.getLocals().add(r17);
        
        Local r18;
        r18 = Jimple.v().newLocal("r18", RefType.v("java.lang.Throwable"));
        body.getLocals().add(r18);
        
        units.add(Jimple.v().newIdentityStmt(r0, Jimple.v().newThisRef(RefType.v(hostClass))));
        
        units.add(Jimple.v().newIdentityStmt(p0, Jimple.v().newParameterRef(IntType.v(), 0)));
        units.add(Jimple.v().newIdentityStmt(p1, Jimple.v().newParameterRef(IntType.v(), 1)));
        units.add(Jimple.v().newIdentityStmt(p2, Jimple.v().newParameterRef(RefType.v("java.lang.String"), 2)));
        units.add(Jimple.v().newIdentityStmt(p3, Jimple.v().newParameterRef(RefType.v("java.lang.String"), 3)));
        units.add(Jimple.v().newIdentityStmt(c0, Jimple.v().newParameterRef(RefType.v("android.content.Context"), 4)));
        
        units.add(Jimple.v().newAssignStmt(r1, new JNewExpr(RefType.v(serviceReplyClass))));
        SootMethod toCall1 = Scene.v().getMethod(initReply);
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r1, toCall1.makeRef())));
        
        units.add(Jimple.v().newAssignStmt(r2, new JNewExpr(RefType.v("android.content.IntentFilter"))));
        SootMethod toCall2 = Scene.v().getMethod("<android.content.IntentFilter: void <init>()>");
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r2, toCall2.makeRef())));
        
        SootMethod toCall3 = Scene.v().getMethod("<android.content.IntentFilter: void addAction(java.lang.String)>");
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r2, toCall3.makeRef(), StringConstant.v("com.example.policymanager.REPLY"))));
        
        units.add(Jimple.v().newAssignStmt(r3, new JNewExpr(RefType.v(bcrClass))));
        SootMethod toCall4 = Scene.v().getMethod(initBcr);
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r3, toCall4.makeRef(), r1)));
        
        //SootMethod toCall5 = Scene.v().getMethod(registerReceiver);
        SootMethod toCall5 = Scene.v().getMethod("<android.content.Context: android.content.Intent registerReceiver(android.content.BroadcastReceiver,android.content.IntentFilter)>");
        //units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r0, toCall5.makeRef(), r3, r2)));
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(c0, toCall5.makeRef(), r3, r2)));
        
        units.add(Jimple.v().newAssignStmt(r5, new JNewExpr(RefType.v("android.content.Intent"))));
        SootMethod toCall6 = Scene.v().getMethod("<android.content.Intent: void <init>()>");
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r5, toCall6.makeRef())));
        
        units.add(Jimple.v().newAssignStmt(r6, new JNewExpr(RefType.v("android.content.ComponentName"))));
        SootMethod toCall7 = Scene.v().getMethod("<android.content.ComponentName: void <init>(java.lang.String,java.lang.String)>");
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r6, toCall7.makeRef(), StringConstant.v("com.example.policymanager"), StringConstant.v("com.example.policymanager.MessengerService"))));
        
        SootMethod toCall8 = Scene.v().getMethod("<android.content.Intent: android.content.Intent setComponent(android.content.ComponentName)>");
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall8.makeRef(), r6)));
        
        //SootMethod toCall9 = Scene.v().getMethod(getPackageName);
        SootMethod toCall9 = Scene.v().getMethod("<android.content.Context: java.lang.String getPackageName()>");
        units.add(Jimple.v().newAssignStmt(r8, Jimple.v().newVirtualInvokeExpr(c0, toCall9.makeRef())));
        
        SootMethod toCall10 = Scene.v().getMethod("<android.content.Intent: android.content.Intent putExtra(java.lang.String,java.lang.String)>");
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall10.makeRef(), StringConstant.v("package"), r8)));
        //units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall10.makeRef(), StringConstant.v("type"), StringConstant.v("IMEI"))));
        //units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall10.makeRef(), StringConstant.v("param"), StringConstant.v("http://www.syr.edu/"))));
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall10.makeRef(), StringConstant.v("type"), p2)));
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall10.makeRef(), StringConstant.v("param"), p3)));
        
        SootMethod toCall11 = Scene.v().getMethod("<android.content.Intent: android.content.Intent putExtra(java.lang.String,int)>");
        //units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall11.makeRef(), StringConstant.v("source"), IntConstant.v(0))));
        //units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall11.makeRef(), StringConstant.v("sink"), IntConstant.v(0))));
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall11.makeRef(), StringConstant.v("source"), p0)));
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r5, toCall11.makeRef(), StringConstant.v("sink"), p1)));
        
        //SootMethod toCall12 = Scene.v().getMethod(startService);
        SootMethod toCall12 = Scene.v().getMethod("<android.content.Context: android.content.ComponentName startService(android.content.Intent)>");
        //units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r0, toCall12.makeRef(), r5)));
        units.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(c0, toCall12.makeRef(), r5)));
        
        //entermonitor r1;
        units.add(Jimple.v().newEnterMonitorStmt(r1));
        
        //label0:	        
        SootMethod toCall13 = Scene.v().getMethod("<java.lang.Object: void wait()>");
        Unit label0 = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r1, toCall13.makeRef()));
        units.add(label0);
        
        //label1:
        Unit label1 = Jimple.v().newExitMonitorStmt(r1);
        units.add(label1);
        
        //label2:
        //SootMethod toCall14 = Scene.v().getMethod(unregisterReceiver);
        SootMethod toCall14 = Scene.v().getMethod("<android.content.Context: void unregisterReceiver(android.content.BroadcastReceiver)>");
        //Unit label2 = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r0, toCall14.makeRef(), r3));
        Unit label2 = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(c0, toCall14.makeRef(), r3));
        units.add(label2);
        
        SootMethod toCall15 = Scene.v().getMethod(getReply);
        units.add(Jimple.v().newAssignStmt(z0, Jimple.v().newVirtualInvokeExpr(r1, toCall15.makeRef())));
        
        units.add(Jimple.v().newReturnStmt(z0));
        
        //label3:
        Unit label3 = Jimple.v().newIdentityStmt(r15, Jimple.v().newCaughtExceptionRef());
        units.add(label3);
        units.add(Jimple.v().newAssignStmt(r16, r15));
        
        //label4:
        SootMethod toCall16 = Scene.v().getMethod("<java.lang.Throwable: void printStackTrace()>");
        Unit label4 = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r16, toCall16.makeRef()));
        units.add(label4);
        
        units.add(Jimple.v().newGotoStmt(label1));
        
        //label5:
        Unit label5 = Jimple.v().newIdentityStmt(r17, Jimple.v().newCaughtExceptionRef());
        units.add(label5);
        units.add(Jimple.v().newAssignStmt(r18, r17));
        
        units.add(Jimple.v().newExitMonitorStmt(r1));
        
        //label6:
        Unit label6 = Jimple.v().newThrowStmt(r18);
        units.add(label6);
        
        //exception handler
        SootClass ex1 = Scene.v().getSootClass("java.lang.InterruptedException");
        body.getTraps().add(Jimple.v().newTrap(ex1, label0, label1, label3));
        
        SootClass ex2 = Scene.v().getSootClass("java.lang.Throwable");        	
    	body.getTraps().add(Jimple.v().newTrap(ex2, label0, label1, label5));
    	body.getTraps().add(Jimple.v().newTrap(ex2, label1, label2, label5));
    	body.getTraps().add(Jimple.v().newTrap(ex2, label4, label6, label5));
		
	}
	
	private void queryService(JimpleBody body, List<Unit> newInstructions, int src, int sink, String srcType, String param){
		
		SootClass hostClass = body.getMethod().getDeclaringClass();
		
		String packageName = hostClass.getPackageName();
		
		SootMethod queryMethod = hostClass.getMethod("boolean queryService(int,int,java.lang.String,java.lang.String,android.content.Context)");
		
		String myAppClass = "";
        if(packageName.equals("")){
        	myAppClass = MyConstants.application;
        }else{
        	myAppClass = packageName + "." + MyConstants.application;
        }
		
		
		Local thisLocal = null;
		
		Iterator it = body.getUnits().iterator();		
		while (it.hasNext()) {
			Stmt s = (Stmt) it.next();
			if(s instanceof IdentityStmt){
				Value rhs = ((IdentityStmt) s).getRightOp();
				if(rhs instanceof ThisRef){
					Value lhs = ((IdentityStmt) s).getLeftOp();
					thisLocal = (Local)lhs;
				}
			}
		}
		
		if(thisLocal==null){
			System.out.println("EXCEPTION: no this reference!");
			return;
		}
		
		int localCount = body.getLocalCount();
		Local context = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("android.content.Context"));
        body.getLocals().add(context);
        
        localCount = body.getLocalCount();
		Local ret = Jimple.v().newLocal(MyConstants.tempLocal+localCount, BooleanType.v());
        body.getLocals().add(ret);
		
		SootMethod toCall1 = Scene.v().getMethod("<" + myAppClass + ": android.content.Context getContext()>");
		newInstructions.add(Jimple.v().newAssignStmt(context, Jimple.v().newStaticInvokeExpr(toCall1.makeRef())));
		
		List<Value> args = new ArrayList<Value>();
		args.add(IntConstant.v(src));
		args.add(IntConstant.v(sink));
		args.add(StringConstant.v(srcType));
		args.add(StringConstant.v(param));
		args.add(context);
		newInstructions.add(Jimple.v().newAssignStmt(ret, Jimple.v().newVirtualInvokeExpr(thisLocal, queryMethod.makeRef(), args)));
	}
	
	private void showAlertDialog(JimpleBody body, List<Unit> newInstructions, String message){
		
		String packageName = body.getMethod().getDeclaringClass().getPackageName();
		
		String listenerClass = "";
        if(packageName.equals("")){
        	listenerClass = MyConstants.dialogListener;
        }else{
        	listenerClass = packageName + "." + MyConstants.dialogListener;
        }
        
        //
        String checkboxListenerClass = "";
        if(packageName.equals("")){
        	checkboxListenerClass = MyConstants.onMultiChoiceClickListener;
        }else{
        	checkboxListenerClass = packageName + "." + MyConstants.onMultiChoiceClickListener;
        }
		
		//r0 := @this: ShowDialog;
		Local thisLocal = null;
		
		Iterator it = body.getUnits().iterator();		
		while (it.hasNext()) {
			Stmt s = (Stmt) it.next();
			if(s instanceof IdentityStmt){
				Value rhs = ((IdentityStmt) s).getRightOp();
				if(rhs instanceof ThisRef){
					Value lhs = ((IdentityStmt) s).getLeftOp();
					thisLocal = (Local)lhs;
				}
			}
		}
		
		if(thisLocal==null){
			System.out.println("EXCEPTION: no this reference!");
			return;
		}
		
		//Chain units = body.getUnits();
		
		
		
		int localCount = body.getLocalCount();
		Local r1 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("android.app.AlertDialog$Builder"));
        body.getLocals().add(r1);
        
        localCount = body.getLocalCount();
		Local r2 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("android.app.AlertDialog"));
        body.getLocals().add(r2);
        
        localCount = body.getLocalCount();
		Local r3 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v(listenerClass));
        body.getLocals().add(r3);
        
        localCount = body.getLocalCount();
		Local r4 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v(listenerClass));
        body.getLocals().add(r4);
        
        //
        localCount = body.getLocalCount();
		Local r5 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v(checkboxListenerClass));
        body.getLocals().add(r5);
        
        //
        localCount = body.getLocalCount();
		Local r6 = Jimple.v().newLocal(MyConstants.tempLocal+localCount, ArrayType.v(RefType.v("java.lang.CharSequence"), 1));
		body.getLocals().add(r6);
        
        //$r1 = new android.app.AlertDialog$Builder;        
        newInstructions.add(Jimple.v().newAssignStmt(r1, new JNewExpr(RefType.v("android.app.AlertDialog$Builder"))));

        
        //specialinvoke $r1.<android.app.AlertDialog$Builder: void <init>(android.content.Context)>(r0);
        SootMethod toCall1 = Scene.v().getMethod("<android.app.AlertDialog$Builder: void <init>(android.content.Context)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r1, toCall1.makeRef(), thisLocal)));        
        
        //virtualinvoke r2.<android.app.AlertDialog$Builder: void setTitle(java.lang.CharSequence)>("Reset...");
        SootMethod toCall3 = Scene.v().getMethod("<android.app.AlertDialog$Builder: android.app.AlertDialog$Builder setTitle(java.lang.CharSequence)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r1, toCall3.makeRef(), StringConstant.v("Security Alert:" + message))));
        
        //virtualinvoke r2.<android.app.AlertDialog$Builder: void setMessage(java.lang.CharSequence)>("R u sure?");
        //SootMethod toCall4 = Scene.v().getMethod("<android.app.AlertDialog$Builder: android.app.AlertDialog$Builder setMessage(java.lang.CharSequence)>");
        //newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r1, toCall4.makeRef(), StringConstant.v(message))));
        
        //
        newInstructions.add(Jimple.v().newAssignStmt(r5, new JNewExpr(RefType.v(checkboxListenerClass))));
        SootMethod toCall5_1 = Scene.v().getMethod("<" + packageName + ".MyOnMultiChoiceClickListener: void <init>()>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r5, toCall5_1.makeRef())));
        
        newInstructions.add(Jimple.v().newAssignStmt(r6, new JNewArrayExpr(RefType.v("java.lang.CharSequence"), IntConstant.v(1))));
        newInstructions.add(Jimple.v().newAssignStmt(Jimple.v().newArrayRef(r6, IntConstant.v(0)), StringConstant.v("Remember my choice")));
        
        SootMethod toCall7_1 = Scene.v().getMethod("<android.app.AlertDialog$Builder: android.app.AlertDialog$Builder setMultiChoiceItems(java.lang.CharSequence[],boolean[],android.content.DialogInterface$OnMultiChoiceClickListener)>");
        List<Value> params = new ArrayList<Value>();
        params.add(r6);
        params.add(NullConstant.v());
        params.add(r5);
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r1, toCall7_1.makeRef(), params)));
        
        
        
        //$r4 = new MyListener;
        newInstructions.add(Jimple.v().newAssignStmt(r4, new JNewExpr(RefType.v(listenerClass))));
        
        //specialinvoke $r4.<MyListener: void <init>()>();
        SootMethod toCall5 = Scene.v().getMethod("<" + packageName + ".MyListener: void <init>()>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(r4, toCall5.makeRef())));
        
        //r3 = $r4;
        newInstructions.add(Jimple.v().newAssignStmt(r3, r4));        
        
        //virtualinvoke r2.<android.app.AlertDialog$Builder: void setButton(java.lang.CharSequence,android.content.DialogInterface$OnClickListener)>("OK", r3);
        SootMethod toCall6 = Scene.v().getMethod("<android.app.AlertDialog$Builder: android.app.AlertDialog$Builder setPositiveButton(java.lang.CharSequence,android.content.DialogInterface$OnClickListener)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r1, toCall6.makeRef(), StringConstant.v("Allow"), r3))); 
        
        SootMethod toCall7 = Scene.v().getMethod("<android.app.AlertDialog$Builder: android.app.AlertDialog$Builder setNegativeButton(java.lang.CharSequence,android.content.DialogInterface$OnClickListener)>");
        newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r1, toCall7.makeRef(), StringConstant.v("Deny"), r3)));
        
        //r2 = virtualinvoke $r1.<android.app.AlertDialog$Builder: android.app.AlertDialog create()>();
        SootMethod toCall2 = Scene.v().getMethod("<android.app.AlertDialog$Builder: android.app.AlertDialog create()>");
        newInstructions.add(Jimple.v().newAssignStmt(r2, Jimple.v().newVirtualInvokeExpr(r1, toCall2.makeRef())));
        
		//virtualinvoke r2.<android.app.AlertDialog: void show()>();
		SootMethod toCall8 = Scene.v().getMethod("<android.app.Dialog: void show()>");
		newInstructions.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(r2, toCall8.makeRef())));
	}
	
	private void traceMethods(){
		
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				if(!method.isConcrete()){
					continue;
				}
				
				LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
				LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
				LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();					
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				Stmt first = body.getFirstNonIdentityStmt();
				List<Unit> unitsToAdd = new LinkedList<Unit>();
				addLog(body, unitsToAdd);
				toInstrumentBefore.put(unitsToAdd, first);
				
				Set<List<Unit>> keySet = toInstrumentAfter.keySet();
				Iterator<List<Unit>> keyIterator = keySet.iterator();
				while (keyIterator.hasNext()) {

					List<Unit> toAdd = keyIterator.next();
					Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
					if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
						s = body.getFirstNonIdentityStmt();
						s = (Stmt)body.getUnits().getPredOf(s);
					}					
					body.getUnits().insertAfter(toAdd, s);
				}
				
				Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
				Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
				while (keyIterator1.hasNext()) {

					List<Unit> toAdd = keyIterator1.next();
					Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

					body.getUnits().insertBefore(toAdd, s);
				}
				
				Set<Stmt> keySet2 = toInstrumentAt.keySet();
				Iterator<Stmt> keyIterator2 = keySet2.iterator();
				while (keyIterator2.hasNext()) {

					Stmt toReplace = keyIterator2.next();
					Stmt s = (Stmt) toInstrumentAt.get(toReplace);

					body.getUnits().insertBefore(toReplace, s);
					body.getUnits().remove(s);
				}
			}
		}
	}
	
	private void doInstrumentation() {
		
			
		System.out.println("instrumenting all the instructions with tags after data flow analysis...");

		List<SootField> taintedStaticFields = new ArrayList<SootField>();
		taintedStaticFields.addAll(CallGraphTransformer.taintedStaticFields);
		
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			if(!MyConstants.COUNT_LOC){
				System.out.println("instrumenting " + soot_class.getName() + "..." );
			}
			//System.out.println("package name: " + soot_class.getPackageName());

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				
				//debug
				
				if(method.getSignature().equals("<com.akbur.mathsworkout.SpaceBlaster: void onCreate(android.os.Bundle)>")){
					
					LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();					
					
					JimpleBody body = (JimpleBody) method.retrieveActiveBody();
					
					Stmt first = body.getFirstNonIdentityStmt();
					List<Unit> unitsToAdd = new LinkedList<Unit>();
					showAlertDialog(body, unitsToAdd, "A Component Hijacking Vulnerability Occurs! Someone Else is Exploiting This App and Sending Data to http://www.mathsworkout.net/controller.php. Restart App or Continue Running?");
					toInstrumentBefore.put(unitsToAdd, first);
					
					Set<List<Unit>> keySet = toInstrumentAfter.keySet();
					Iterator<List<Unit>> keyIterator = keySet.iterator();
					while (keyIterator.hasNext()) {

						List<Unit> toAdd = keyIterator.next();
						Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
						if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
							s = body.getFirstNonIdentityStmt();
							s = (Stmt)body.getUnits().getPredOf(s);
						}					
						body.getUnits().insertAfter(toAdd, s);
					}
					
					Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
					Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
					while (keyIterator1.hasNext()) {

						List<Unit> toAdd = keyIterator1.next();
						Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

						body.getUnits().insertBefore(toAdd, s);
					}
					
					Set<Stmt> keySet2 = toInstrumentAt.keySet();
					Iterator<Stmt> keyIterator2 = keySet2.iterator();
					while (keyIterator2.hasNext()) {

						Stmt toReplace = keyIterator2.next();
						Stmt s = (Stmt) toInstrumentAt.get(toReplace);

						body.getUnits().insertBefore(toReplace, s);
						body.getUnits().remove(s);
					}
					
					continue;
				}
				
				if(method.getSignature().equals("<CN.MyPrivateMessages.CallLogs: void onCreate(android.os.Bundle)>")
						|| method.getSignature().equals("<CN.MyPrivateMessages.AllCallLogs: void onCreate(android.os.Bundle)>")){
					
					LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();					
					
					JimpleBody body = (JimpleBody) method.retrieveActiveBody();
					
					Stmt first = body.getFirstNonIdentityStmt();
					List<Unit> unitsToAdd = new LinkedList<Unit>();
					showAlertDialog(body, unitsToAdd, "A Component Hijacking Vulnerability Occurs! Someone Else is Exploiting This App and Updating \"mydb.db\" Database. Restart App or Continue Running?");
					toInstrumentBefore.put(unitsToAdd, first);
					
					Set<List<Unit>> keySet = toInstrumentAfter.keySet();
					Iterator<List<Unit>> keyIterator = keySet.iterator();
					while (keyIterator.hasNext()) {

						List<Unit> toAdd = keyIterator.next();
						Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
						if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
							s = body.getFirstNonIdentityStmt();
							s = (Stmt)body.getUnits().getPredOf(s);
						}					
						body.getUnits().insertAfter(toAdd, s);
					}
					
					Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
					Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
					while (keyIterator1.hasNext()) {

						List<Unit> toAdd = keyIterator1.next();
						Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

						body.getUnits().insertBefore(toAdd, s);
					}
					
					Set<Stmt> keySet2 = toInstrumentAt.keySet();
					Iterator<Stmt> keyIterator2 = keySet2.iterator();
					while (keyIterator2.hasNext()) {

						Stmt toReplace = keyIterator2.next();
						Stmt s = (Stmt) toInstrumentAt.get(toReplace);

						body.getUnits().insertBefore(toReplace, s);
						body.getUnits().remove(s);
					}
					
					continue;
				}
				
				//com.bfs.papertoss.PaperToss.onCreate:(Landroid/os/Bundle;)V
				/*
				if(method.getSignature().equals("<com.bfs.papertoss.PaperToss: void onCreate(android.os.Bundle)>")){
					
					LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();					
					
					JimpleBody body = (JimpleBody) method.retrieveActiveBody();
					
					Stmt first = body.getFirstNonIdentityStmt();
					List<Unit> unitsToAdd = new LinkedList<Unit>();
					showAlertDialog(body, unitsToAdd, "The App is sending IMEI to http://data.flurry.com/aar.do. Do you allow it or not?");
					toInstrumentBefore.put(unitsToAdd, first);
					
					Set<List<Unit>> keySet = toInstrumentAfter.keySet();
					Iterator<List<Unit>> keyIterator = keySet.iterator();
					while (keyIterator.hasNext()) {

						List<Unit> toAdd = keyIterator.next();
						Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
						if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
							s = body.getFirstNonIdentityStmt();
							s = (Stmt)body.getUnits().getPredOf(s);
						}					
						body.getUnits().insertAfter(toAdd, s);
					}
					
					Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
					Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
					while (keyIterator1.hasNext()) {

						List<Unit> toAdd = keyIterator1.next();
						Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

						body.getUnits().insertBefore(toAdd, s);
					}
					
					Set<Stmt> keySet2 = toInstrumentAt.keySet();
					Iterator<Stmt> keyIterator2 = keySet2.iterator();
					while (keyIterator2.hasNext()) {

						Stmt toReplace = keyIterator2.next();
						Stmt s = (Stmt) toInstrumentAt.get(toReplace);

						body.getUnits().insertBefore(toReplace, s);
						body.getUnits().remove(s);
					}
					
					continue;
				}
				
				
				if(method.getSignature().equals("<com.flurry.android.FlurryAgent: boolean a(byte[],java.lang.String)>")){
					
					LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();					
					
					JimpleBody body = (JimpleBody) method.retrieveActiveBody();
					
					Stmt first = body.getFirstNonIdentityStmt();
					List<Unit> unitsToAdd = new LinkedList<Unit>();
					queryService(body, unitsToAdd, 0, 0, "Location", "http://data.flurry.com/aar.do");
					toInstrumentBefore.put(unitsToAdd, first);
					
					Set<List<Unit>> keySet = toInstrumentAfter.keySet();
					Iterator<List<Unit>> keyIterator = keySet.iterator();
					while (keyIterator.hasNext()) {

						List<Unit> toAdd = keyIterator.next();
						Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
						if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
							s = body.getFirstNonIdentityStmt();
							s = (Stmt)body.getUnits().getPredOf(s);
						}					
						body.getUnits().insertAfter(toAdd, s);
					}
					
					Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
					Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
					while (keyIterator1.hasNext()) {

						List<Unit> toAdd = keyIterator1.next();
						Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

						body.getUnits().insertBefore(toAdd, s);
					}
					
					Set<Stmt> keySet2 = toInstrumentAt.keySet();
					Iterator<Stmt> keyIterator2 = keySet2.iterator();
					while (keyIterator2.hasNext()) {

						Stmt toReplace = keyIterator2.next();
						Stmt s = (Stmt) toInstrumentAt.get(toReplace);

						body.getUnits().insertBefore(toReplace, s);
						body.getUnits().remove(s);
					}
					
					continue;
				}
				*/
				
				if(method.getSignature().equals("<com.mobclix.android.sdk.Mobclix$FetchResponseThread: void run()>")){
					
					LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();					
					
					JimpleBody body = (JimpleBody) method.retrieveActiveBody();
					
					Stmt first = body.getFirstNonIdentityStmt();
					List<Unit> unitsToAdd = new LinkedList<Unit>();
					queryService(body, unitsToAdd, 0, 0, "IMEI", "url");
					toInstrumentBefore.put(unitsToAdd, first);
					
					Set<List<Unit>> keySet = toInstrumentAfter.keySet();
					Iterator<List<Unit>> keyIterator = keySet.iterator();
					while (keyIterator.hasNext()) {

						List<Unit> toAdd = keyIterator.next();
						Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
						if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
							s = body.getFirstNonIdentityStmt();
							s = (Stmt)body.getUnits().getPredOf(s);
						}					
						body.getUnits().insertAfter(toAdd, s);
					}
					
					Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
					Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
					while (keyIterator1.hasNext()) {

						List<Unit> toAdd = keyIterator1.next();
						Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

						body.getUnits().insertBefore(toAdd, s);
					}
					
					Set<Stmt> keySet2 = toInstrumentAt.keySet();
					Iterator<Stmt> keyIterator2 = keySet2.iterator();
					while (keyIterator2.hasNext()) {

						Stmt toReplace = keyIterator2.next();
						Stmt s = (Stmt) toInstrumentAt.get(toReplace);

						body.getUnits().insertBefore(toReplace, s);
						body.getUnits().remove(s);
					}
					
					continue;
				}
				
				/*
				if(method.getName().equals("doSearchReport")){// || method.getName().equals("getSearchTask") || method.getName().equals("reportState")){
						
					continue;
				}
				*/
				
				/*
				if(method.getSignature().equals("<com.google.ssearch.SearchService: void onCreate()>")){
					
					LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
					LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();
					//Vector<Local> newLocals = new Vector<Local>();
					
					
					
					
					JimpleBody body = (JimpleBody) method.retrieveActiveBody();
					Iterator it = body.getUnits().iterator();
					
					
					
					while (it.hasNext()) {
						Stmt s = (Stmt) it.next();
						if(s==body.getFirstNonIdentityStmt()){
							
							Stmt log = logStmt("d", method.getSignature(), "onCreate() begins.");
							
							List<Unit> unitsToAdd = new LinkedList<Unit>();
							unitsToAdd.add(log);
							//showDialog(body, unitsToAdd);
							toast(body,unitsToAdd);
							//unitsToAdd.add(log);
							toInstrumentBefore.put(unitsToAdd, s);
							
						}else if(s instanceof InvokeStmt){
							InvokeExpr invokeExpr = s.getInvokeExpr();
							SootMethod invokeMethod = invokeExpr.getMethod();
							if(invokeMethod.getSignature().equals("<com.google.ssearch.SearchService: void doSearchReport()>")){
								
								Stmt log = logStmt("d", method.getSignature(), "onCreate() calls doSearchReport()");
								
								List<Unit> unitsToAdd = new LinkedList<Unit>();
								unitsToAdd.add(log);
								toInstrumentBefore.put(unitsToAdd, s);
							}
						}else if(s instanceof DefinitionStmt){
							
							Value rhs = ((DefinitionStmt) s).getRightOp();
							if(rhs instanceof InvokeExpr){
								SootMethod invokeMethod = ((InvokeExpr) rhs).getMethod();
								
								if (invokeMethod.getSignature().equals("<java.lang.System: long currentTimeMillis()>")){
									Stmt log = logStmt("d", method.getSignature(), "currentTimeMillis passed.");
									
									List<Unit> unitsToAdd = new LinkedList<Unit>();
									unitsToAdd.add(log);
									toInstrumentAfter.put(unitsToAdd, s);
								}
							}
							
							
						}else if(s instanceof IfStmt){
							Value cond = ((IfStmt) s).getCondition();
							Stmt target = ((IfStmt) s).getTarget();
							Value op1 = ((ConditionExpr)cond).getOp1();
							
							Stmt log = logStmt("d", method.getSignature(), 
									"[" + cond.toString() + "] is FALSE, FALLTHROUGH instead of targeting [" + target.toString() + "]");
							
							List<Unit> unitsToAdd = new LinkedList<Unit>();
							unitsToAdd.add(log);
							toInstrumentAfter.put(unitsToAdd, s);
							
							((IfStmt) s).setCondition(Jimple.v().newNeExpr(IntConstant.v(0), IntConstant.v(0)));
								
							
						}
						
					}
					
					Set<List<Unit>> keySet = toInstrumentAfter.keySet();
					Iterator<List<Unit>> keyIterator = keySet.iterator();
					while (keyIterator.hasNext()) {

						List<Unit> toAdd = keyIterator.next();
						Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
						if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
							s = body.getFirstNonIdentityStmt();
							s = (Stmt)body.getUnits().getPredOf(s);
						}					
						body.getUnits().insertAfter(toAdd, s);
					}
					
					Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
					Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
					while (keyIterator1.hasNext()) {

						List<Unit> toAdd = keyIterator1.next();
						Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

						body.getUnits().insertBefore(toAdd, s);
					}
					
					Set<Stmt> keySet2 = toInstrumentAt.keySet();
					Iterator<Stmt> keyIterator2 = keySet2.iterator();
					while (keyIterator2.hasNext()) {

						Stmt toReplace = keyIterator2.next();
						Stmt s = (Stmt) toInstrumentAt.get(toReplace);

						body.getUnits().insertBefore(toReplace, s);
						body.getUnits().remove(s);
					}
					
					continue;
				}
				*/
				
				/*
				if(method.getName().equals("<init>")){
					continue;
				}
				*/
				if(!method.isConcrete()){
					continue;
				}

				if(!MyConstants.COUNT_LOC){
					System.out.println("instrumenting " + method.getSignature() + "...");
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);
		        MyReachingDefinition mrd = new MyReachingDefinition(eug);

				Iterator it = body.getUnits().iterator();

				LinkedHashMap<List<Unit>, Stmt> toInstrumentAfter = new LinkedHashMap<List<Unit>, Stmt>();
				LinkedHashMap<List<Unit>, Stmt> toInstrumentBefore = new LinkedHashMap<List<Unit>, Stmt>();
				LinkedHashMap<Stmt, Stmt> toInstrumentAt = new LinkedHashMap<Stmt, Stmt>();
				
				Vector<Local> newLocals = new Vector<Local>();
				Vector<Local> localsDefInIdentity = new Vector<Local>();
				
				/*
				String boolWrapper = "";
				if(soot_class.getPackageName().equals("")){
					boolWrapper = MyConstants.boolWrapper;
				}else{				
					boolWrapper = soot_class.getPackageName() + "." + MyConstants.boolWrapper;
					//System.out.println("soot_class:" + soot_class + "|boolWrapper:" + boolWrapper);
				}
				
				String boolField = "<" + boolWrapper + ": boolean b>";
				String boolInit = "<" + boolWrapper + ": void <init>()>";
				*/

				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();				
					
					
					//find out all the locals defined in identity statements
					if(s instanceof IdentityStmt){
						if(((IdentityStmt)s).getLeftOp() instanceof Local){
							Local l = (Local)((IdentityStmt)s).getLeftOp();
							localsDefInIdentity.add(l);
						}
					}
					
					Vector<Integer> labels = new Vector<Integer>();
					
					for(Tag tag : s.getTags()){
						if(taintTagReverseMap.containsKey(tag)){
							Integer label = new Integer(((TaintTag)tag).getLabel());
							if(!labels.contains(label)){
								labels.add(label);
							}
						}else if(extraDefTagReverseMap.containsKey(tag)){
							Integer label = new Integer(((TaintTag)tag).getLabel());
							if(!labels.contains(label)){
								labels.add(label);
							}
						}								
					}
					
					if (!s.getTags().contains(generalTaintTag)
							&& !s.getTags().contains(generalExtraDefTag)) {
						
						if(s instanceof DefinitionStmt){
							Value lhs = ((DefinitionStmt) s).getLeftOp();
							if(lhs instanceof StaticFieldRef){
								
								SootField field = ((StaticFieldRef) lhs).getField();
								
								if(taintedStaticFields.contains(field)){
									
									if(!field.getDeclaringClass().isApplicationClass()){
										continue;
									}
									
									if(field.getDeclaringClass().isPhantom()){
										continue;
									}
									
									Chain<SootField> allFieldsOfClass = field.getDeclaringClass().getFields();
									for(SootField oneField : allFieldsOfClass){
										if(oneField.getName().startsWith(field.getName()+"_s")){
											
											SootField taintField = oneField;
											//SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName()));
											
											
											AssignStmt toAdd1 = Jimple.v().newAssignStmt(
													Jimple.v().newStaticFieldRef(taintField.makeRef()), IntConstant.v(0));
											//new
											/*
											int localCount = body.getLocalCount();
											Local vLocal = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("java.util.Vector"));
							                body.getLocals().add(vLocal);
											
											Stmt toAdd1 = Jimple.v().newAssignStmt(vLocal, Jimple.v().newStaticFieldRef(taintField.makeRef()));
											
											SootMethod toCall = Scene.v().getMethod("<java.util.Vector: void removeAllElements()>");
											Stmt toAdd2 = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(vLocal, toCall.makeRef()));
											*/
											
																				
											toAdd1.addTag(instrumentationTag);
											toAdd1.addTag(referenceTag);
											List<Unit> unitsToAdd = new LinkedList<Unit>();
											unitsToAdd.add(toAdd1);
											toInstrumentAfter.put(unitsToAdd, s);
											
											
											//new
											/*
											toAdd1.addTag(instrumentationTag);
											toAdd1.addTag(referenceTag);
											
											toAdd2.addTag(instrumentationTag);
											toAdd2.addTag(referenceTag);
											
											List<Unit> unitsToAdd = new LinkedList<Unit>();
											unitsToAdd.add(toAdd1);
											unitsToAdd.add(toAdd2);
											toInstrumentAfter.put(unitsToAdd, s);
											*/
										}
									}									
								}
							}
							
							//
							if(lhs instanceof InstanceFieldRef){
								
								Value base = ((InstanceFieldRef) lhs).getBase();
								
								SootField field = ((InstanceFieldRef) lhs).getField();
								
								if(taintedStaticFields.contains(field)){
									
									if(!field.getDeclaringClass().isApplicationClass()){
										continue;
									}
									
									Chain<SootField> allFieldsOfClass = field.getDeclaringClass().getFields();
									for(SootField oneField : allFieldsOfClass){
										if(oneField.getName().startsWith(field.getName()+"_s")){
											
											SootField taintField = oneField;
											//SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName()));
											
											
											AssignStmt toAdd1 = Jimple.v().newAssignStmt(
													Jimple.v().newInstanceFieldRef(base, taintField.makeRef()), IntConstant.v(0));
											
											
											//new									
											/*
											int localCount = body.getLocalCount();
											Local vLocal = Jimple.v().newLocal(MyConstants.tempLocal+localCount, RefType.v("java.util.Vector"));
							                body.getLocals().add(vLocal);
											
											Stmt toAdd1 = Jimple.v().newAssignStmt(vLocal, Jimple.v().newInstanceFieldRef(base, taintField.makeRef()));
											
											SootMethod toCall = Scene.v().getMethod("<java.util.Vector: void removeAllElements()>");
											Stmt toAdd2 = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(vLocal, toCall.makeRef()));
											*/
											
											
											toAdd1.addTag(instrumentationTag);
											toAdd1.addTag(referenceTag);
											List<Unit> unitsToAdd = new LinkedList<Unit>();
											unitsToAdd.add(toAdd1);
											toInstrumentAfter.put(unitsToAdd, s);
											
											
											//new
											/*
											toAdd1.addTag(instrumentationTag);
											toAdd1.addTag(referenceTag);
											
											toAdd2.addTag(instrumentationTag);
											toAdd2.addTag(referenceTag);
											
											List<Unit> unitsToAdd = new LinkedList<Unit>();
											unitsToAdd.add(toAdd1);
											unitsToAdd.add(toAdd2);
											toInstrumentAfter.put(unitsToAdd, s);
											*/
										}
									}
								}									
								
							}
							
						}
					
					}
					
					else if (s.getTags().contains(generalTaintTag)) {
						
						// instrument it
						if (s instanceof InvokeStmt) {

							InvokeExpr rhs = s.getInvokeExpr();

							SootClass sClass = rhs.getMethod().getDeclaringClass();
							String boolWrapper = "";
							if(sClass.getPackageName().equals("")){
								boolWrapper = MyConstants.boolWrapper;
							}else{				
								boolWrapper = sClass.getPackageName() + "." + MyConstants.boolWrapper;
								//System.out.println("soot_class:" + soot_class + "|boolWrapper:" + boolWrapper);
							}

							String boolField = "<" + boolWrapper + ": boolean b>";
							String boolInit = "<" + boolWrapper + ": void <init>()>";
							//String union = "<" + boolWrapper + ": void union(java.util.Vector,java.util.Vector)>";
							//String query = "<" + boolWrapper + ": void queryPolicyFromService()>";


							//if (((InvokeExpr) rhs).getMethod().getName().equals("send")) {
							//if (((InvokeExpr) rhs).getMethod().getSignature().equals("<java.io.OutputStream: void write(byte[],int,int)>")) {

							//need fixing
							if(sinks.contains(((InvokeExpr) rhs).getMethod().getSignature())){

								if(!MyConstants.TO_ENFORCE_CONTROL){
									continue;
								}

								if(!MyConstants.COUNT_LOC){
									System.out.println("taint sink:" + ((InvokeExpr) rhs).getMethod());
								}


								Value arg0;
								
								if(((InvokeExpr) rhs).getMethod().getSignature().equals(
										"<java.net.URL: java.net.URLConnection openConnection()>")){
									arg0 = ((InstanceInvokeExpr) rhs).getBase();
								}else{
									//sensitive parameter
									arg0 = ((InvokeExpr) rhs).getArg(0);
								}
								if(arg0 instanceof Local){
									
									LinkedHashMap<Integer, Local> taintMap = new LinkedHashMap<Integer, Local>();
									
									for(int sc=0;sc<sourceCount;sc++){
										String argName = ((Local)arg0).getName();
	
										Local argTaintLocal = null;
										String taintArgName = getTaintVarName(argName, sc);
	
										boolean hasVar = false;
										for (Local l : body.getLocals()) {
											if (l.getName().equals(taintArgName)) {
												hasVar = true;
												argTaintLocal = l;
											}
										}
	
										if (!hasVar) {
											argTaintLocal = Jimple.v().newLocal(taintArgName, BooleanType.v());
											//argTaintLocal = Jimple.v().newLocal(taintArgName, RefType.v("java.util.Vector"));
											body.getLocals().add(argTaintLocal);
										}
	
										if(argTaintLocal!= null){
	
											taintMap.put(new Integer(sc), argTaintLocal);
											
											if(!newLocals.contains(argTaintLocal)){
												newLocals.add(argTaintLocal);
											}
										}
									}
									
									/*
									{

										//assume there is only one successor, which is true for sink methods
										boolean foundJumpTarget = false;
										Stmt targetPred = s;

										if(!MyConstants.COUNT_LOC){
											System.out.println("INSTRUMENT sink method:");
										}
										while(!foundJumpTarget){

											if(MyConstants.DEBUG_INFO)
												System.out.println("CURRENT TARGET is " + targetPred);

											if(targetPred.getDefBoxes().size()>0){
												Local ret = (Local)targetPred.getDefBoxes().get(0).getValue();

												if(eug.getUnexceptionalSuccsOf(targetPred).size()==1){


													Stmt succ = (Stmt)eug.getUnexceptionalSuccsOf(targetPred).get(0);
													if(mrd.hasDefsAt(ret, succ)){

														if(mrd.getDefsOfAt(ret, succ).size()==1){

															if(mrd.getDefsOfAt(ret, succ).get(0).equals(targetPred)){
																targetPred = succ;
															}else{
																if(MyConstants.DEBUG_INFO)
																	System.out.println("Not: mrd.getDefsOfAt(ret, succ).get(0).equals(targetPred)");
																foundJumpTarget = true;
															}


														}else{
															if(MyConstants.DEBUG_INFO)
																System.out.println("Not: mrd.getDefsOfAt(ret, succ).size()==1");
															foundJumpTarget = true;
														}


													}else{
														if(MyConstants.DEBUG_INFO)
															System.out.println("Not: mrd.hasDefsAt(ret, succ)");
														foundJumpTarget = true;
													}

												}else{
													if(MyConstants.DEBUG_INFO)
														System.out.println("Not: eug.getSuccsOf(targetPred).size()==1 |" + eug.getSuccsOf(targetPred));
													foundJumpTarget = true;
												}
											}else{
												if(MyConstants.DEBUG_INFO)
													System.out.println("Not: targetPred.getDefBoxes().size()>0");
												foundJumpTarget = true;
											}

										}

										
										Stmt target = null;
										if(eug.getUnexceptionalSuccsOf(targetPred).size()>1){
											if(targetPred instanceof IfStmt){
												Value cond = ((IfStmt) targetPred).getCondition();
												Stmt targ = ((IfStmt)targetPred).getTarget();
												if(cond instanceof NeExpr){
													Value op2 = ((NeExpr) cond).getOp2();
													if(op2.equivTo(IntConstant.v(-1))){
														target = (Stmt)body.getUnits().getSuccOf(targetPred);
													}else{
														target = targ;
													}
												}else if(cond instanceof EqExpr){
													Value op2 = ((EqExpr) cond).getOp2();
													if(op2.equivTo(IntConstant.v(-1))){
														target = targ;															
													}else{
														target = (Stmt)body.getUnits().getSuccOf(targetPred);
													}
												}
											}
										}else{
											if(body.getUnits().getSuccOf(targetPred)==null){
												target = targetPred;
											}else{
												target = (Stmt)eug.getUnexceptionalSuccsOf(targetPred).get(0);
											}
										}

										*/

										List<Unit> unitsToAdd = new LinkedList<Unit>();
										
										

										//need fix
										/*
										if(MyConstants.TO_ENFORCE_CONTROL){
										*/
											/*
											//need fix, will cause inconsistency. should add fieldsToAdd list
											SootField access = new SootField("ACCESS", BooleanType.v(), Modifier.PUBLIC | Modifier.STATIC);
											body.getMethod().getDeclaringClass().addField(access);


											AssignStmt toAdd_InitAccess = Jimple.v().newAssignStmt(
													Jimple.v().newStaticFieldRef(access.makeRef()), IntConstant.v(0));
											//send intent to check policy

											SootMethod callQuery = Scene.v().getMethod(query);
											Stmt toAdd = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(callQuery.makeRef()));

											//add onActivityResult callback to receive result from policy manager, and set ACCESS bool

											IfStmt branch1 = Jimple.v().newIfStmt(
													Jimple.v().newEqExpr(Jimple.v().newStaticFieldRef(access.makeRef()), IntConstant.v(0)), target);

											toAdd_InitAccess.addTag(instrumentationTag);
											toAdd_InitAccess.addTag(checkTaintTag);

											toAdd.addTag(instrumentationTag);
											toAdd.addTag(checkTaintTag);

											branch1.addTag(instrumentationTag);
											branch1.addTag(checkTaintTag);
											 */
											/*
											IfStmt branch1 = Jimple.v().newIfStmt(
													Jimple.v().newEqExpr(argTaintLocal, IntConstant.v(1)), 
													target);



											branch1.addTag(instrumentationTag);
											branch1.addTag(checkTaintTag);


											Stmt log1 = logStmt("d", method.getSignature(), 
													"BLOCKING sink: " + ((InvokeExpr) rhs).getMethod().getSignature());

											Stmt log2 = logStmt("d", method.getSignature(), "BLOCKING BYPASSED :(");

											//unitsToAdd.add(toAdd_InitAccess);
											//unitsToAdd.add(toAdd);
											unitsToAdd.add(log1);
											unitsToAdd.add(branch1);
											unitsToAdd.add(log2);


											//unitsToAdd.add(goto1);
											//unitsToAdd.add(toAdd3);



										}else{

											//SootClass logClass = Scene.v().loadClassAndSupport("android.util.Log");
											//SootMethod logD = logClass.getMethod("int d(java.lang.String,java.lang.String)");
											SootMethod logD = Scene.v().getMethod("<android.util.Log: int d(java.lang.String,java.lang.String)>");
											Stmt log = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(
													logD.makeRef(), 
													StringConstant.v(method.getSignature()), 
													StringConstant.v("sink: " + ((InvokeExpr) rhs).getMethod().getSignature())));

											log.addTag(instrumentationTag);
											log.addTag(checkTaintTag);

											unitsToAdd.add(log);

										}

										toInstrumentBefore.put(unitsToAdd, s);

									}
									*/
								}
								

							}else if(((InvokeExpr) rhs).getMethod().getDeclaringClass().isApplicationClass()==false){

								if(!MyConstants.COUNT_LOC){
									System.out.println("step into instrumentation of " + ((InvokeExpr) rhs).getMethod());
								}
								SootMethod libMethod = ((InvokeExpr) rhs).getMethod();

								LinkedHashMap<Integer, List<Integer>> stod = AndroidFunctionSummary.lookupFunctionSummary(libMethod.getSignature());
								if(stod==null){
									//s is an invoke statement, with no return value
								}else{
									Set<Integer> sources = stod.keySet();
									Iterator<Integer> iterSources = sources.iterator();

									List<Unit> unitsToAddAfter = new LinkedList<Unit>();

									while(iterSources.hasNext()){
										Integer source = iterSources.next();
										List<Integer> dests = stod.get(source);

										for(Integer dest:dests){
											
											for(Integer label : labels){

												//source
												String srcName = "";
	
												if(source.intValue()==MyConstants.thisObject){
													Value base = ((InstanceInvokeExpr)rhs).getBase();
													if(base instanceof Local){
														srcName = ((Local)base).getName();
													}
												}else if(source.intValue()>=0){
													Value arg = ((InvokeExpr) rhs).getArg(source.intValue());
													if(arg instanceof Local){
														srcName = ((Local)arg).getName();
													}
												}
	
	
												//dest
												String destName = "";
	
												if(dest.intValue()==MyConstants.thisObject){
													Value base = ((InstanceInvokeExpr)rhs).getBase();
													if(base instanceof Local){
														destName = ((Local)base).getName();
													}
												}else if(dest.intValue()>=0){
													Value arg = ((InvokeExpr) rhs).getArg(source.intValue());
													if(arg instanceof Local){
														destName = ((Local)arg).getName();
													}
												}
	
												if(destName.equals("")){
													continue;
												}
	
												Local destTaintLocal = null;
												String destTaintName = getTaintVarName(destName, label.intValue());
												boolean hasVar = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(destTaintName)) {
														hasVar = true;
														destTaintLocal = l;
													}
												}
	
												if (!hasVar) {
													destTaintLocal = Jimple.v().newLocal(destTaintName, BooleanType.v());
													//destTaintLocal = Jimple.v().newLocal(destTaintName, RefType.v("java.util.Vector"));
													body.getLocals().add(destTaintLocal);
												}
	
												if(srcName.equals("")){
													if(destTaintLocal!=null){
	
														if(!newLocals.contains(destTaintLocal)){
															newLocals.add(destTaintLocal);
														}
	
														Stmt toAdd = null;
	
														//special cases
														if(libMethod.getSignature().equals("<java.util.List: boolean add(java.lang.Object)>")){
															toAdd = Jimple.v().newAssignStmt(destTaintLocal, Jimple.v().newOrExpr(destTaintLocal, IntConstant.v(0)));
	
														}else{
															toAdd = Jimple.v().newAssignStmt(destTaintLocal, IntConstant.v(0));
	
															//SootMethod callClear = Scene.v().getMethod("<java.util.Vector: void removeAllElements()>");
															//toAdd = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(destTaintLocal, callClear.makeRef()));
														}
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("statement to add: " + toAdd);
	
														toAdd.addTag(instrumentationTag);
	
	
														unitsToAddAfter.add(toAdd);												
	
													}
	
													continue;
												}
	
												Local srcTaintLocal = null;
												String srcTaintName = getTaintVarName(srcName, label.intValue());
												hasVar = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(srcTaintName)) {
														hasVar = true;
														srcTaintLocal = l;
													}
												}
	
												if (!hasVar) {
													srcTaintLocal = Jimple.v().newLocal(srcTaintName, BooleanType.v());
													//srcTaintLocal = Jimple.v().newLocal(srcTaintName, RefType.v("java.util.Vector"));
													body.getLocals().add(srcTaintLocal);
												}										
	
	
												//formula
												if(srcTaintLocal!=null && destTaintLocal!=null){
	
													if(!newLocals.contains(srcTaintLocal)){
														newLocals.add(srcTaintLocal);
													}
	
													if(!newLocals.contains(destTaintLocal)){
														newLocals.add(destTaintLocal);
													}
	
													Stmt toAdd = null;
	
													//special cases
													if(libMethod.getSignature().equals("<java.util.List: boolean add(java.lang.Object)>")){
														toAdd = Jimple.v().newAssignStmt(destTaintLocal, Jimple.v().newOrExpr(destTaintLocal, srcTaintLocal));
	
														//SootMethod callUnion = Scene.v().getMethod(union);
														//toAdd = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(callUnion.makeRef(), destTaintLocal, srcTaintLocal));
													}else{
														toAdd = Jimple.v().newAssignStmt(destTaintLocal, srcTaintLocal);
	
														//SootMethod callUnion = Scene.v().getMethod(union);
														//toAdd = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(callUnion.makeRef(), destTaintLocal, srcTaintLocal));
													}
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("statement to add: " + toAdd);
	
													toAdd.addTag(instrumentationTag);
	
	
													unitsToAddAfter.add(toAdd);
	
	
												}
											}
										}
									}

									if(MyConstants.DEBUG_INFO)
										System.out.println("new to add after: " + unitsToAddAfter.get(0));
									toInstrumentAfter.put(unitsToAddAfter, s);
								}
							}						

							else{

								int nargc = 0;

								List<Value> nargs = new ArrayList<Value>();
								for(Value v: ((InvokeExpr) rhs).getArgs()){
									nargs.add(v);
								}
								
								List<Value> args = ((InvokeExpr) rhs).getArgs();
								for(Value v : args){
									
									for(int sc=0;sc<sourceCount;sc++){									
										
										if(v instanceof Local){
											String argName = ((Local)v).getName();
	
											Local argTaintLocal = null;
											String taintArgName = getTaintVarName(argName, sc);
	
											boolean hasVar = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintArgName)) {
													hasVar = true;
													argTaintLocal = l;
												}
											}
	
											if (!hasVar) {
												argTaintLocal = Jimple.v().newLocal(taintArgName, BooleanType.v());
												//argTaintLocal = Jimple.v().newLocal(taintArgName, RefType.v("java.util.Vector"));
												body.getLocals().add(argTaintLocal);
											}
	
											/*
											if(argTaintLocal!= null){
												if(!newLocals.contains(argTaintLocal)){
													newLocals.add(argTaintLocal);
												}
	
												nargs.add(argTaintLocal);
												nargc++;
	
											}else{
												System.out.println("fail to create taint local variable for return value");
											}
											 */
	
	
											Local argTaintWrapperLocal = null;
											String taintWrapperArgName = getTaintWrapperName(taintArgName);
	
											boolean hasWrapper = false;
											for(Local l : body.getLocals()){
												if(l.getName().equals(taintWrapperArgName)){
													hasWrapper = true;
													argTaintWrapperLocal = l;
												}
											}
	
											if(!hasWrapper){
												//System.out.println("hasWrapper:" + taintWrapperArgName);
												//System.out.println("wrapper name:" + soot_class.getPackageName() + "." + MyConstants.boolWrapper);
												argTaintWrapperLocal = Jimple.v().newLocal(taintWrapperArgName, RefType.v(boolWrapper));
												body.getLocals().add(argTaintWrapperLocal);
											}
	
											if(argTaintLocal!= null && argTaintWrapperLocal!=null){
	
												if(!newLocals.contains(argTaintLocal)){
													newLocals.add(argTaintLocal);
												}
	
												JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(argTaintWrapperLocal, newBoolWrapper);
	
	
												SootMethod toCall = Scene.v().getMethod(boolInit);
												InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
														Jimple.v().newSpecialInvokeExpr(argTaintWrapperLocal, toCall.makeRef()));
	
												AssignStmt toAdd3 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(
																argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), argTaintLocal);
	
												toAdd1.addTag(instrumentationTag);
												toAdd2.addTag(instrumentationTag);
												toAdd3.addTag(instrumentationTag);
	
												toAdd1.addTag(beforeWrapperTag);
												toAdd2.addTag(beforeWrapperTag);
												toAdd3.addTag(beforeWrapperTag);
	
												List<Unit> unitsToAdd = new LinkedList<Unit>();
												unitsToAdd.add(toAdd1);
												unitsToAdd.add(toAdd2);
												unitsToAdd.add(toAdd3);
												toInstrumentBefore.put(unitsToAdd, s);
	
												AssignStmt toAdd4 = Jimple.v().newAssignStmt(argTaintLocal, 
														Jimple.v().newInstanceFieldRef(
																argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));
	
												toAdd4.addTag(instrumentationTag);
												toAdd4.addTag(afterWrapperTag);
	
												List<Unit> unitsToAddAfter = new LinkedList<Unit>();
												unitsToAddAfter.add(toAdd4);
												toInstrumentAfter.put(unitsToAddAfter, s);
	
												nargs.add(argTaintWrapperLocal);
												nargc++;
											}else{
												System.out.println("fail to create taint local variable for return value");
											}
	
	
										}else if(v instanceof Constant){


											int localCount = body.getLocalCount();
											String taintArgName = getTaintVarName("tmp" + localCount, sc);
											Local argTaintLocal = Jimple.v().newLocal(taintArgName, BooleanType.v());
											body.getLocals().add(argTaintLocal);

											String taintWrapperArgName = getTaintWrapperName(taintArgName);
											Local argTaintWrapperLocal = Jimple.v().newLocal(taintWrapperArgName, RefType.v(boolWrapper));
											body.getLocals().add(argTaintWrapperLocal);



											if(argTaintLocal!= null && argTaintWrapperLocal!=null){

												if(!newLocals.contains(argTaintLocal)){
													newLocals.add(argTaintLocal);
												}

												JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(argTaintWrapperLocal, newBoolWrapper);


												SootMethod toCall = Scene.v().getMethod(boolInit);
												InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
														Jimple.v().newSpecialInvokeExpr(argTaintWrapperLocal, toCall.makeRef()));

												AssignStmt toAdd3 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(
																argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), argTaintLocal);

												toAdd1.addTag(instrumentationTag);
												toAdd2.addTag(instrumentationTag);
												toAdd3.addTag(instrumentationTag);

												toAdd1.addTag(beforeWrapperTag);
												toAdd2.addTag(beforeWrapperTag);
												toAdd3.addTag(beforeWrapperTag);

												List<Unit> unitsToAdd = new LinkedList<Unit>();
												unitsToAdd.add(toAdd1);
												unitsToAdd.add(toAdd2);
												unitsToAdd.add(toAdd3);
												toInstrumentBefore.put(unitsToAdd, s);

												AssignStmt toAdd4 = Jimple.v().newAssignStmt(argTaintLocal, 
														Jimple.v().newInstanceFieldRef(
																argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));

												toAdd4.addTag(instrumentationTag);
												toAdd4.addTag(afterWrapperTag);

												List<Unit> unitsToAddAfter = new LinkedList<Unit>();
												unitsToAddAfter.add(toAdd4);
												toInstrumentAfter.put(unitsToAddAfter, s);

												nargs.add(argTaintWrapperLocal);
												nargc++;


											}else{
												System.out.println("fail to create taint local variable");
											}


	
										}
	
										else{
											System.out.println("MISSING an argument: " + v);
										}
										
									}
								}

								if(rhs instanceof InstanceInvokeExpr){

									Value v = ((InstanceInvokeExpr)rhs).getBase();
									
									for(int sc=0;sc<sourceCount;sc++){
										
										if(v instanceof Local){										
											
											String thisName = ((Local)v).getName();
	
											Local thisTaintLocal = null;
											String taintThisName = getTaintVarName(thisName, sc);
	
											boolean hasVar = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintThisName)) {
													hasVar = true;
													thisTaintLocal = l;
												}
											}
	
											if (!hasVar) {
												thisTaintLocal = Jimple.v().newLocal(taintThisName, BooleanType.v());
												body.getLocals().add(thisTaintLocal);
											}
	
											Local thisTaintWrapperLocal = null;
											String taintWrapperThisName = getTaintWrapperName(taintThisName);
	
											boolean hasWrapper = false;
											for(Local l : body.getLocals()){
												if(l.getName().equals(taintWrapperThisName)){
													hasWrapper = true;
													thisTaintWrapperLocal = l;
												}
											}
	
											if(!hasWrapper){
												//System.out.println("hasWrapper:" + taintWrapperArgName);
												//System.out.println("wrapper name:" + soot_class.getPackageName() + "." + MyConstants.boolWrapper);
												thisTaintWrapperLocal = Jimple.v().newLocal(taintWrapperThisName, RefType.v(boolWrapper));
												body.getLocals().add(thisTaintWrapperLocal);
											}
	
											if(thisTaintLocal!=null && thisTaintWrapperLocal!=null){
	
												if(!newLocals.contains(thisTaintLocal)){
													newLocals.add(thisTaintLocal);
												}
	
												JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(thisTaintWrapperLocal, newBoolWrapper);
	
	
												SootMethod toCall = Scene.v().getMethod(boolInit);
												InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
														Jimple.v().newSpecialInvokeExpr(thisTaintWrapperLocal, toCall.makeRef()));
	
												AssignStmt toAdd3 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(
																thisTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), thisTaintLocal);
	
												toAdd1.addTag(instrumentationTag);
												toAdd2.addTag(instrumentationTag);
												toAdd3.addTag(instrumentationTag);
	
												toAdd1.addTag(beforeWrapperTag);
												toAdd2.addTag(beforeWrapperTag);
												toAdd3.addTag(beforeWrapperTag);
	
												List<Unit> unitsToAdd = new LinkedList<Unit>();
												unitsToAdd.add(toAdd1);
												unitsToAdd.add(toAdd2);
												unitsToAdd.add(toAdd3);
												toInstrumentBefore.put(unitsToAdd, s);
	
												AssignStmt toAdd4 = Jimple.v().newAssignStmt(thisTaintLocal, 
														Jimple.v().newInstanceFieldRef(
																thisTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));
	
												toAdd4.addTag(instrumentationTag);
												toAdd4.addTag(afterWrapperTag);
	
												List<Unit> unitsToAddAfter = new LinkedList<Unit>();
												unitsToAddAfter.add(toAdd4);
												toInstrumentAfter.put(unitsToAddAfter, s);
	
												nargs.add(thisTaintWrapperLocal);
												nargc++;
											}
	
										}else{
	
										}
										
									}

								}

								if(!(rhs.getMethod().getReturnType().equals(VoidType.v()))){
									
									for(int sc=0;sc<sourceCount;sc++){

										int localCount = body.getLocalCount();
										String taintArgName = getTaintVarName("tmp" + localCount, sc);
										Local argTaintLocal = Jimple.v().newLocal(taintArgName, BooleanType.v());
										body.getLocals().add(argTaintLocal);
	
										String taintWrapperArgName = getTaintWrapperName(taintArgName);
										Local argTaintWrapperLocal = Jimple.v().newLocal(taintWrapperArgName, RefType.v(boolWrapper));
										body.getLocals().add(argTaintWrapperLocal);
	
	
	
										if(argTaintLocal!= null && argTaintWrapperLocal!=null){
	
											if(!newLocals.contains(argTaintLocal)){
												newLocals.add(argTaintLocal);
											}
	
											JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
											AssignStmt toAdd1 = Jimple.v().newAssignStmt(argTaintWrapperLocal, newBoolWrapper);
	
	
											SootMethod toCall = Scene.v().getMethod(boolInit);
											InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
													Jimple.v().newSpecialInvokeExpr(argTaintWrapperLocal, toCall.makeRef()));
	
											AssignStmt toAdd3 = Jimple.v().newAssignStmt(
													Jimple.v().newInstanceFieldRef(
															argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), argTaintLocal);
	
											toAdd1.addTag(instrumentationTag);
											toAdd2.addTag(instrumentationTag);
											toAdd3.addTag(instrumentationTag);
	
											toAdd1.addTag(beforeWrapperTag);
											toAdd2.addTag(beforeWrapperTag);
											toAdd3.addTag(beforeWrapperTag);
	
											List<Unit> unitsToAdd = new LinkedList<Unit>();
											unitsToAdd.add(toAdd1);
											unitsToAdd.add(toAdd2);
											unitsToAdd.add(toAdd3);
											toInstrumentBefore.put(unitsToAdd, s);
	
											AssignStmt toAdd4 = Jimple.v().newAssignStmt(argTaintLocal, 
													Jimple.v().newInstanceFieldRef(
															argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));
	
											toAdd4.addTag(instrumentationTag);
											toAdd4.addTag(afterWrapperTag);
	
											List<Unit> unitsToAddAfter = new LinkedList<Unit>();
											unitsToAddAfter.add(toAdd4);
											toInstrumentAfter.put(unitsToAddAfter, s);
	
											nargs.add(argTaintWrapperLocal);
											nargc++;
										}else{
											System.out.println("fail to create taint local variable");
										}

									}

								}

								SootMethod oldMethod = ((InvokeExpr) rhs).getMethod();
								String oldMethodName = oldMethod.getName();
								SootClass oldMethodClass = oldMethod.getDeclaringClass();
								Type oldReturnType = oldMethod.getReturnType();


								List<Type> oldParameterTypes = oldMethod.getParameterTypes();


								List<Type> nargsType = new ArrayList<Type>();
								for(Type t : oldParameterTypes){
									nargsType.add(t);
								}
								for(int c=0;c<nargc;c++){
									nargsType.add(RefType.v(boolWrapper));
								}

								if(MyConstants.DEBUG_INFO)
									System.out.println("nargc=" + nargc + ", " + "nargsType=" + nargsType);
								SootMethod toCall = Scene.v().getMethod(SootMethod.getSignature(
										oldMethodClass, getWrapperMethodName(oldMethodName), nargsType, oldReturnType));
								if(rhs instanceof StaticInvokeExpr){

									InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(toCall.makeRef(), nargs));
									nStmt.addTag(instrumentationTag);
									nStmt.addTag(invokeWrapperTag);
									toInstrumentAt.put(nStmt, s);
								}else if(rhs instanceof VirtualInvokeExpr){
									Value base = ((VirtualInvokeExpr) rhs).getBase();
									if(base instanceof Local){
										InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}else if(rhs instanceof SpecialInvokeExpr){
									Value base = ((SpecialInvokeExpr) rhs).getBase();
									if(base instanceof Local){
										InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}else if(rhs instanceof InterfaceInvokeExpr){
									Value base = ((InterfaceInvokeExpr) rhs).getBase();
									if(base instanceof Local){
										InvokeStmt nStmt = Jimple.v().newInvokeStmt(Jimple.v().newInterfaceInvokeExpr((Local)base, toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}
								}

							}

						} else if (s instanceof DefinitionStmt) {

							Value rhs = ((DefinitionStmt) s).getRightOp();
							Value lhs = ((DefinitionStmt) s).getLeftOp();

							//need fix
							if (rhs instanceof InvokeExpr) {
								// invocation definition statements

								SootClass sClass = ((InvokeExpr)rhs).getMethod().getDeclaringClass();
								String boolWrapper = "";
								if(sClass.getPackageName().equals("")){
									boolWrapper = MyConstants.boolWrapper;
								}else{				
									boolWrapper = sClass.getPackageName() + "." + MyConstants.boolWrapper;
									//System.out.println("soot_class:" + soot_class + "|boolWrapper:" + boolWrapper);
								}

								String boolField = "<" + boolWrapper + ": boolean b>";
								String boolInit = "<" + boolWrapper + ": void <init>()>";

								//initialize taint
								if(srcs.contains(((InvokeExpr) rhs).getMethod().getSignature())){
									
									int sc = CallGraphExample.sources.get(((InvokeExpr) rhs).getMethod().getSignature()).intValue();

									if(!MyConstants.COUNT_LOC){
										System.out.println("taint initialization:" + ((InvokeExpr) rhs).getMethod().getSignature());
									}

									if (lhs instanceof Local) {
										String varName = ((Local) lhs).getName();

										if(MyConstants.DEBUG_INFO)
											System.out.println(varName);

										Local taintLocal = null;

										String taintVarName = getTaintVarName(varName, sc);

										boolean hasVar = false;
										for (Local l : body.getLocals()) {
											if (l.getName().equals(taintVarName)) {
												hasVar = true;
												taintLocal = l;
											}
										}

										if (!hasVar) {
											taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
											body.getLocals().add(taintLocal);
										}

										if (taintLocal != null) {

											if(!newLocals.contains(taintLocal)){
												newLocals.add(taintLocal);
											}

											AssignStmt toAdd1 = Jimple.v().newAssignStmt(taintLocal, IntConstant.v(1));
											toAdd1.addTag(instrumentationTag);
											toAdd1.addTag(initTaintTag);
											List<Unit> unitsToAdd = new LinkedList<Unit>();
											unitsToAdd.add(toAdd1);
											toInstrumentAfter.put(unitsToAdd, s);
										}

									}
									//taint sink
									//}else if (((InvokeExpr) rhs).getMethod().getName().equals("send")) {
									//getSignature().equals("<java.io.OutputStream: void write(byte[],int,int)>")
									//}else if (((InvokeExpr) rhs).getMethod().getSignature().equals("<java.io.OutputStream: void write(byte[],int,int)>")) {
								}else if(sinks.contains(((InvokeExpr) rhs).getMethod().getSignature())){

									if(!MyConstants.TO_ENFORCE_CONTROL){
										continue;
									}

									if(!MyConstants.COUNT_LOC){
										System.out.println("taint sink:" + ((InvokeExpr) rhs).getMethod());
									}

									Value arg0;
									if(((InvokeExpr) rhs).getMethod().getSignature().equals(
											"<java.net.URL: java.net.URLConnection openConnection()>")){
										arg0 = ((InstanceInvokeExpr) rhs).getBase();
									}else{									
										//sensitive parameter, but which
										arg0 = ((InvokeExpr) rhs).getArg(0);
									}
									if(arg0 instanceof Local){
										
										for(int sc=0;sc<sourceCount;sc++){
											String argName = ((Local)arg0).getName();
	
											Local argTaintLocal = null;
											String taintArgName = getTaintVarName(argName, sc);
	
											boolean hasVar = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintArgName)) {
													hasVar = true;
													argTaintLocal = l;
												}
											}
	
											if (!hasVar) {
												argTaintLocal = Jimple.v().newLocal(taintArgName, BooleanType.v());
												body.getLocals().add(argTaintLocal);
											}
	
											if(argTaintLocal!= null){
	
												if(!newLocals.contains(argTaintLocal)){
													newLocals.add(argTaintLocal);
												}
												
											}
										}
										
										/*
										{

											//assume there is only one successor, which is true for sink methods
											boolean foundJumpTarget = false;
											Stmt targetPred = s;

											if(!MyConstants.COUNT_LOC){
												System.out.println("INSTRUMENT sink method:");
											}
											while(!foundJumpTarget){

												if(MyConstants.DEBUG_INFO)
													System.out.println("CURRENT TARGET is " + targetPred);

												if(targetPred.getDefBoxes().size()>0){
													Local ret = (Local)targetPred.getDefBoxes().get(0).getValue();

													if(eug.getUnexceptionalSuccsOf(targetPred).size()==1){


														Stmt succ = (Stmt)eug.getUnexceptionalSuccsOf(targetPred).get(0);
														if(mrd.hasDefsAt(ret, succ)){

															if(mrd.getDefsOfAt(ret, succ).size()==1){

																if(mrd.getDefsOfAt(ret, succ).get(0).equals(targetPred)){
																	targetPred = succ;
																}else{
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("Not: mrd.getDefsOfAt(ret, succ).get(0).equals(targetPred)");
																	foundJumpTarget = true;
																}


															}else{
																if(MyConstants.DEBUG_INFO)
																	System.out.println("Not: mrd.getDefsOfAt(ret, succ).size()==1");
																foundJumpTarget = true;
															}


														}else{
															if(MyConstants.DEBUG_INFO)
																System.out.println("Not: mrd.hasDefsAt(ret, succ)");
															foundJumpTarget = true;
														}

													}else{
														if(MyConstants.DEBUG_INFO)
															System.out.println("Not: eug.getSuccsOf(targetPred).size()==1 |" + eug.getSuccsOf(targetPred));
														foundJumpTarget = true;
													}
												}else{
													if(MyConstants.DEBUG_INFO)
														System.out.println("Not: targetPred.getDefBoxes().size()>0");
													foundJumpTarget = true;
												}

											}

											Stmt target = null;
											if(eug.getUnexceptionalSuccsOf(targetPred).size()>1){
												if(targetPred instanceof IfStmt){
													Value cond = ((IfStmt) targetPred).getCondition();
													Stmt targ = ((IfStmt)targetPred).getTarget();
													if(cond instanceof NeExpr){
														Value op2 = ((NeExpr) cond).getOp2();
														if(op2.equivTo(IntConstant.v(-1))){
															target = (Stmt)body.getUnits().getSuccOf(targetPred);
														}else{
															target = targ;
														}
													}else if(cond instanceof EqExpr){
														Value op2 = ((EqExpr) cond).getOp2();
														if(op2.equivTo(IntConstant.v(-1))){
															target = targ;															
														}else{
															target = (Stmt)body.getUnits().getSuccOf(targetPred);
														}
													}
												}
											}else{
												if(body.getUnits().getSuccOf(targetPred)==null){
													target = targetPred;
												}else{
													target = (Stmt)eug.getUnexceptionalSuccsOf(targetPred).get(0);
												}
											}

											List<Unit> unitsToAdd = new LinkedList<Unit>();


											if(MyConstants.TO_ENFORCE_CONTROL){

												IfStmt branch1 = Jimple.v().newIfStmt(
														Jimple.v().newEqExpr(argTaintLocal, IntConstant.v(1)), 
														target);

												branch1.addTag(instrumentationTag);
												branch1.addTag(checkTaintTag);

												//GotoStmt goto1 = Jimple.v().newGotoStmt(body.getUnits().getSuccOf(s));
												//goto1.addTag(instrumentationTag);

												
												//Stmt log1 = logStmt("d", method.getSignature(), 
												//		"BLOCKING sink: " + ((InvokeExpr) rhs).getMethod().getSignature());

												//Stmt log2 = logStmt("d", method.getSignature(), "BLOCKING BYPASSED :(");
												 

												//unitsToAdd.add(log1);
												unitsToAdd.add(branch1);
												//unitsToAdd.add(log2);


												//unitsToAdd.add(goto1);
												//unitsToAdd.add(toAdd3);



											}else{

												//SootClass logClass = Scene.v().loadClassAndSupport("android.util.Log");
												//SootMethod logD = logClass.getMethod("int d(java.lang.String,java.lang.String)");
												SootMethod logD = Scene.v().getMethod("<android.util.Log: int d(java.lang.String,java.lang.String)>");
												Stmt log = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(
														logD.makeRef(), 
														StringConstant.v(method.getSignature()), 
														StringConstant.v("sink: " + ((InvokeExpr) rhs).getMethod().getSignature())));

												log.addTag(instrumentationTag);
												log.addTag(checkTaintTag);

												unitsToAdd.add(log);

											}

											toInstrumentBefore.put(unitsToAdd, s);

										}
										*/
									}
								}
								else if(((InvokeExpr) rhs).getMethod().getDeclaringClass().isApplicationClass()==false){

									if(!MyConstants.COUNT_LOC){
										System.out.println("step into instrumentation of " + ((InvokeExpr) rhs).getMethod());	
									}
									SootMethod libMethod = ((InvokeExpr) rhs).getMethod();

									LinkedHashMap<Integer, List<Integer>> stod = AndroidFunctionSummary.lookupFunctionSummary(libMethod.getSignature());
									String srcName = "";
									String destName = "";



									if(stod==null){
										
										for(Integer label : labels){

											//List<Unit> unitsToAddAfter = new LinkedList<Unit>();
	
											destName = "";
	
											if(lhs instanceof Local){
												destName = ((Local)lhs).getName();
											}
											Local destTaintLocal = null;
											String destTaintName = getTaintVarName(destName, label.intValue());
											boolean hasVar = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(destTaintName)) {
													hasVar = true;
													destTaintLocal = l;
												}
											}
	
											if (!hasVar) {
												destTaintLocal = Jimple.v().newLocal(destTaintName, BooleanType.v());
												body.getLocals().add(destTaintLocal);
											}
	
											List<Unit> unitsToAddAfter = new LinkedList<Unit>();
	
											srcName = "";
	
											List<Value> args = ((InvokeExpr) rhs).getArgs();
											if(args.size()>0){
												Value arg0 = args.get(0);
	
												if(arg0 instanceof Local){
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("arg is a local");
	
													srcName = ((Local) arg0).getName();
	
													Local srcTaintLocal = null;
													String srcTaintName = getTaintVarName(srcName, label.intValue());
													hasVar = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(srcTaintName)) {
															hasVar = true;
															srcTaintLocal = l;
														}
													}
	
													if (!hasVar) {
														srcTaintLocal = Jimple.v().newLocal(srcTaintName, BooleanType.v());
														body.getLocals().add(srcTaintLocal);
													}
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("srcTaintLocal:" + srcTaintLocal + "|destTaintLocal:" + destTaintLocal);
													if(srcTaintLocal!=null && destTaintLocal!=null){
	
														if(!newLocals.contains(srcTaintLocal)){
															newLocals.add(srcTaintLocal);
														}
	
														if(!newLocals.contains(destTaintLocal)){
															newLocals.add(destTaintLocal);
														}
	
														Stmt toAdd = Jimple.v().newAssignStmt(destTaintLocal, srcTaintLocal);
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("statement to add: " + toAdd);
	
														toAdd.addTag(instrumentationTag);
	
	
														unitsToAddAfter.add(toAdd);
	
	
													}
												}else if(arg0 instanceof Constant){
													if(destTaintLocal!=null){
	
														if(!newLocals.contains(destTaintLocal)){
															newLocals.add(destTaintLocal);
														}
	
														Stmt toAdd = Jimple.v().newAssignStmt(destTaintLocal, IntConstant.v(0));
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("statement to add: " + toAdd);
	
														toAdd.addTag(instrumentationTag);
	
														//List<Unit> unitsToAddAfter = new LinkedList<Unit>();
														unitsToAddAfter.add(toAdd);
	
	
													}
												}
	
												for(Value arg:args){
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("arg:" + arg);
													if(arg instanceof Local){
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("arg is a local");
	
														srcName = ((Local) arg).getName();
	
														Local srcTaintLocal = null;
														String srcTaintName = getTaintVarName(srcName, label.intValue());
														hasVar = false;
														for (Local l : body.getLocals()) {
															if (l.getName().equals(srcTaintName)) {
																hasVar = true;
																srcTaintLocal = l;
															}
														}
	
														if (!hasVar) {
															srcTaintLocal = Jimple.v().newLocal(srcTaintName, BooleanType.v());
															body.getLocals().add(srcTaintLocal);
														}
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("srcTaintLocal:" + srcTaintLocal + "|destTaintLocal:" + destTaintLocal);
														if(destTaintLocal!=null && srcTaintLocal!=null){
	
															if(!newLocals.contains(srcTaintLocal)){
																newLocals.add(srcTaintLocal);
															}
	
															if(!newLocals.contains(destTaintLocal)){
																newLocals.add(destTaintLocal);
															}
	
															Stmt toAdd = Jimple.v().newAssignStmt(
																	destTaintLocal, Jimple.v().newOrExpr(srcTaintLocal, destTaintLocal));
	
															if(MyConstants.DEBUG_INFO)
																System.out.println("statement to add: " + toAdd);
	
															toAdd.addTag(instrumentationTag);
	
															//List<Unit> unitsToAddAfter = new LinkedList<Unit>();
															unitsToAddAfter.add(toAdd);
	
	
														}
													}
												}
	
												if(rhs instanceof InstanceInvokeExpr){
													Value base = ((InstanceInvokeExpr) rhs).getBase();
	
													srcName = ((Local) base).getName();
	
													Local srcTaintLocal = null;
													String srcTaintName = getTaintVarName(srcName, label.intValue());
													hasVar = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(srcTaintName)) {
															hasVar = true;
															srcTaintLocal = l;
														}
													}
	
													if (!hasVar) {
														srcTaintLocal = Jimple.v().newLocal(srcTaintName, BooleanType.v());
														body.getLocals().add(srcTaintLocal);
													}
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("srcTaintLocal:" + srcTaintLocal + "|destTaintLocal:" + destTaintLocal);
													if(srcTaintLocal!=null && destTaintLocal!=null){
	
														if(!newLocals.contains(srcTaintLocal)){
															newLocals.add(srcTaintLocal);
														}
	
														if(!newLocals.contains(destTaintLocal)){
															newLocals.add(destTaintLocal);
														}
	
														Stmt toAdd = Jimple.v().newAssignStmt(
																destTaintLocal, Jimple.v().newOrExpr(srcTaintLocal, destTaintLocal));
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("statement to add: " + toAdd);
	
														toAdd.addTag(instrumentationTag);
	
														//List<Unit> unitsToAddAfter = new LinkedList<Unit>();
														unitsToAddAfter.add(toAdd);
	
	
													}
												}
	
	
	
											}else if(rhs instanceof InstanceInvokeExpr){
	
												//List<Unit> unitsToAddAfter = new LinkedList<Unit>();
	
												Value base = ((InstanceInvokeExpr) rhs).getBase();
	
												{
													srcName = ((Local) base).getName();
	
													Local srcTaintLocal = null;
													String srcTaintName = getTaintVarName(srcName, label.intValue());
													hasVar = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(srcTaintName)) {
															hasVar = true;
															srcTaintLocal = l;
														}
													}
	
													if (!hasVar) {
														srcTaintLocal = Jimple.v().newLocal(srcTaintName, BooleanType.v());
														body.getLocals().add(srcTaintLocal);
													}
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("srcTaintLocal:" + srcTaintLocal + "|destTaintLocal:" + destTaintLocal);
													if(srcTaintLocal!=null && destTaintLocal!=null){
	
														if(!newLocals.contains(srcTaintLocal)){
															newLocals.add(srcTaintLocal);
														}
	
														if(!newLocals.contains(destTaintLocal)){
															newLocals.add(destTaintLocal);
														}
	
														Stmt toAdd = Jimple.v().newAssignStmt(destTaintLocal, srcTaintLocal);
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("statement to add: " + toAdd);
	
														toAdd.addTag(instrumentationTag);
	
														//List<Unit> unitsToAddAfter = new LinkedList<Unit>();
														unitsToAddAfter.add(toAdd);
														//toInstrumentAfter.put(unitsToAddAfter1, s);
	
													}
												}
	
	
												for(Value arg:args){
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("arg:" + arg);
	
													if(arg instanceof Local){
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("arg is a local");
	
														srcName = ((Local) arg).getName();
	
														Local srcTaintLocal = null;
														String srcTaintName = getTaintVarName(srcName, label.intValue());
														hasVar = false;
														for (Local l : body.getLocals()) {
															if (l.getName().equals(srcTaintName)) {
																hasVar = true;
																srcTaintLocal = l;
															}
														}
	
														if (!hasVar) {
															srcTaintLocal = Jimple.v().newLocal(srcTaintName, BooleanType.v());
															body.getLocals().add(srcTaintLocal);
														}
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("srcTaintLocal:" + srcTaintLocal + "|destTaintLocal:" + destTaintLocal);
														if(destTaintLocal!=null && srcTaintLocal!=null){
	
															if(!newLocals.contains(srcTaintLocal)){
																newLocals.add(srcTaintLocal);
															}
	
															if(!newLocals.contains(destTaintLocal)){
																newLocals.add(destTaintLocal);
															}
	
															Stmt toAdd = Jimple.v().newAssignStmt(
																	destTaintLocal, Jimple.v().newOrExpr(srcTaintLocal, destTaintLocal));
	
															if(MyConstants.DEBUG_INFO)
																System.out.println("statement to add: " + toAdd);
	
															toAdd.addTag(instrumentationTag);
	
															//List<Unit> unitsToAddAfter = new LinkedList<Unit>();
															unitsToAddAfter.add(toAdd);
															//toInstrumentAfter.put(unitsToAddAfter1, s);
	
														}
													}
												}
											}
	
											toInstrumentAfter.put(unitsToAddAfter, s);
										
										}

									}else{

										if(MyConstants.DEBUG_INFO)
											System.out.println(((InvokeExpr) rhs).getMethod() + "has function summary");

										for(Integer label : labels){
										
											Set<Integer> sources = stod.keySet();
											Iterator<Integer> iterSources = sources.iterator();
	
	
	
											while(iterSources.hasNext()){
												Integer source = iterSources.next();
												List<Integer> dests = stod.get(source);
	
												List<Unit> unitsToAddAfter = new LinkedList<Unit>();
	
												for(Integer dest:dests){
	
	
	
	
													//dest
													destName = "";
	
													if(dest.intValue()==MyConstants.thisObject){
														Value base = ((InstanceInvokeExpr)rhs).getBase();
														if(base instanceof Local){
															destName = ((Local)base).getName();
														}
													}else if(dest.intValue()==MyConstants.returnValue){
														if(lhs instanceof Local){
															destName = ((Local)lhs).getName();
														}
													}else if(dest.intValue()>=0){
														Value arg = ((InvokeExpr) rhs).getArg(dest.intValue());
														if(arg instanceof Local){
															destName = ((Local)arg).getName();
														}
													}
	
													Local destTaintLocal = null;
													String destTaintName = getTaintVarName(destName, label.intValue());
													boolean hasVar = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(destTaintName)) {
															hasVar = true;
															destTaintLocal = l;
														}
													}
	
													if (!hasVar) {
														destTaintLocal = Jimple.v().newLocal(destTaintName, BooleanType.v());
														body.getLocals().add(destTaintLocal);
													}
	
													if(destName.equals("")){
														continue;
													}
	
	
	
													//source
													srcName = "";
	
													if(source.intValue()==MyConstants.thisObject){
														Value base = ((InstanceInvokeExpr)rhs).getBase();
														if(base instanceof Local){
															srcName = ((Local)base).getName();
														}
													}else if(source.intValue()>=0){
														Value arg = ((InvokeExpr) rhs).getArg(source.intValue());
														if(arg instanceof Local){
															srcName = ((Local)arg).getName();
														}
													}
	
	
													if(srcName.equals("")){
	
														if(destTaintLocal!=null){
	
															if(!newLocals.contains(destTaintLocal)){
																newLocals.add(destTaintLocal);
															}
	
															Stmt toAdd = Jimple.v().newAssignStmt(destTaintLocal, IntConstant.v(0));
	
															if(MyConstants.DEBUG_INFO)
																System.out.println("statement to add: " + toAdd);
	
															toAdd.addTag(instrumentationTag);
	
	
															unitsToAddAfter.add(toAdd);
	
	
														}
	
														continue;
													}
	
													Local srcTaintLocal = null;
													String srcTaintName = getTaintVarName(srcName, label.intValue());
													hasVar = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(srcTaintName)) {
															hasVar = true;
															srcTaintLocal = l;
														}
													}
	
													if (!hasVar) {
														srcTaintLocal = Jimple.v().newLocal(srcTaintName, BooleanType.v());
														body.getLocals().add(srcTaintLocal);
													}
	
	
													//formula
													if(srcTaintLocal!=null && destTaintLocal!=null){
	
														if(!newLocals.contains(srcTaintLocal)){
															newLocals.add(srcTaintLocal);
														}
	
														if(!newLocals.contains(destTaintLocal)){
															newLocals.add(destTaintLocal);
														}
	
														Stmt toAdd = Jimple.v().newAssignStmt(destTaintLocal, srcTaintLocal);
	
														if(MyConstants.DEBUG_INFO)
															System.out.println("statement to add: " + toAdd);
	
														toAdd.addTag(instrumentationTag);
	
	
														unitsToAddAfter.add(toAdd);
	
	
													}
												}
	
												if(MyConstants.DEBUG_INFO)
													System.out.println("new to add after: " + unitsToAddAfter.get(0));
												toInstrumentAfter.put(unitsToAddAfter, s);
											}
											
										
										}
									}

								}else{

									Value nlhs = lhs;

									int nargc = 0;
									List<Value> nargs = new ArrayList<Value>();
									for(Value v: ((InvokeExpr) rhs).getArgs()){
										nargs.add(v);
									}

									if(MyConstants.DEBUG_INFO)
										System.out.println("nargs: " + nargs);

									List<Value> args = ((InvokeExpr) rhs).getArgs();
									for(Value v : args){
										
										for(int sc=0;sc<sourceCount;sc++){
										
											if(v instanceof Local){
												String argName = ((Local)v).getName();
	
												Local argTaintLocal = null;
												String taintArgName = getTaintVarName(argName, sc);
	
												boolean hasVar = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintArgName)) {
														hasVar = true;
														argTaintLocal = l;
													}
												}
	
												if (!hasVar) {
													argTaintLocal = Jimple.v().newLocal(taintArgName, BooleanType.v());
													body.getLocals().add(argTaintLocal);
												}
	
												Local argTaintWrapperLocal = null;
												String taintWrapperArgName = getTaintWrapperName(taintArgName);
	
												boolean hasWrapper = false;
												for(Local l : body.getLocals()){
													if(l.getName().equals(taintWrapperArgName)){
														hasWrapper = true;
														argTaintWrapperLocal = l;
													}
												}
	
												if(!hasWrapper){
													//System.out.println("hasWrapper:" + taintWrapperArgName);
													//System.out.println("wrapper name:" + soot_class.getPackageName() + "." + MyConstants.boolWrapper);
													argTaintWrapperLocal = Jimple.v().newLocal(taintWrapperArgName, RefType.v(boolWrapper));
													body.getLocals().add(argTaintWrapperLocal);
												}
	
												if(argTaintLocal!= null && argTaintWrapperLocal!=null){
	
													if(!newLocals.contains(argTaintLocal)){
														newLocals.add(argTaintLocal);
													}
	
													JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(argTaintWrapperLocal, newBoolWrapper);
	
	
													SootMethod toCall = Scene.v().getMethod(boolInit);
													InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
															Jimple.v().newSpecialInvokeExpr(argTaintWrapperLocal, toCall.makeRef()));
	
													AssignStmt toAdd3 = Jimple.v().newAssignStmt(
															Jimple.v().newInstanceFieldRef(
																	argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), argTaintLocal);
	
													toAdd1.addTag(instrumentationTag);
													toAdd2.addTag(instrumentationTag);
													toAdd3.addTag(instrumentationTag);
	
													toAdd1.addTag(beforeWrapperTag);
													toAdd2.addTag(beforeWrapperTag);
													toAdd3.addTag(beforeWrapperTag);
	
													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													unitsToAdd.add(toAdd2);
													unitsToAdd.add(toAdd3);
													toInstrumentBefore.put(unitsToAdd, s);
	
													AssignStmt toAdd4 = Jimple.v().newAssignStmt(argTaintLocal, 
															Jimple.v().newInstanceFieldRef(
																	argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));
	
													toAdd4.addTag(instrumentationTag);
													toAdd4.addTag(afterWrapperTag);
	
													List<Unit> unitsToAddAfter = new LinkedList<Unit>();
													unitsToAddAfter.add(toAdd4);
													toInstrumentAfter.put(unitsToAddAfter, s);
	
													nargs.add(argTaintWrapperLocal);
													nargc++;
	
													//System.out.println("nargs: " + nargs + " nargc++:" + nargc);
												}
	
											}else if(v instanceof Constant){
	
												int localCount = body.getLocalCount();
												String taintArgName = getTaintVarName("tmp" + localCount, sc);
												Local argTaintLocal = Jimple.v().newLocal(taintArgName, BooleanType.v());
												body.getLocals().add(argTaintLocal);
	
												String taintWrapperArgName = getTaintWrapperName(taintArgName);
												Local argTaintWrapperLocal = Jimple.v().newLocal(taintWrapperArgName, RefType.v(boolWrapper));
												body.getLocals().add(argTaintWrapperLocal);
	
	
	
												if(argTaintLocal!= null && argTaintWrapperLocal!=null){
	
													if(!newLocals.contains(argTaintLocal)){
														newLocals.add(argTaintLocal);
													}
	
													JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(argTaintWrapperLocal, newBoolWrapper);
	
	
													SootMethod toCall = Scene.v().getMethod(boolInit);
													InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
															Jimple.v().newSpecialInvokeExpr(argTaintWrapperLocal, toCall.makeRef()));
	
													AssignStmt toAdd3 = Jimple.v().newAssignStmt(
															Jimple.v().newInstanceFieldRef(
																	argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), argTaintLocal);
	
													toAdd1.addTag(instrumentationTag);
													toAdd2.addTag(instrumentationTag);
													toAdd3.addTag(instrumentationTag);
	
													toAdd1.addTag(beforeWrapperTag);
													toAdd2.addTag(beforeWrapperTag);
													toAdd3.addTag(beforeWrapperTag);
	
													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													unitsToAdd.add(toAdd2);
													unitsToAdd.add(toAdd3);
													toInstrumentBefore.put(unitsToAdd, s);
	
													AssignStmt toAdd4 = Jimple.v().newAssignStmt(argTaintLocal, 
															Jimple.v().newInstanceFieldRef(
																	argTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));
	
													toAdd4.addTag(instrumentationTag);
													toAdd4.addTag(afterWrapperTag);
	
													List<Unit> unitsToAddAfter = new LinkedList<Unit>();
													unitsToAddAfter.add(toAdd4);
													toInstrumentAfter.put(unitsToAddAfter, s);
	
													nargs.add(argTaintWrapperLocal);
													nargc++;
												}else{
													System.out.println("fail to create taint local variable");
												}
	
											}
	
											else{
												System.out.println("MISSING an argument: " + v);
											}
										
										}
									}


									if(rhs instanceof InstanceInvokeExpr){
										
										for(int sc=0;sc<sourceCount;sc++){
										
											Value v = ((InstanceInvokeExpr)rhs).getBase();
											if(v instanceof Local){
												String thisName = ((Local)v).getName();
	
												Local thisTaintLocal = null;
												String taintThisName = getTaintVarName(thisName, sc);
	
												boolean hasVar = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintThisName)) {
														hasVar = true;
														thisTaintLocal = l;
													}
												}
	
												if (!hasVar) {
													thisTaintLocal = Jimple.v().newLocal(taintThisName, BooleanType.v());
													body.getLocals().add(thisTaintLocal);
												}
	
												Local thisTaintWrapperLocal = null;
												String taintWrapperThisName = getTaintWrapperName(taintThisName);
	
												boolean hasWrapper = false;
												for(Local l : body.getLocals()){
													if(l.getName().equals(taintWrapperThisName)){
														hasWrapper = true;
														thisTaintWrapperLocal = l;
													}
												}
	
												if(!hasWrapper){
													//System.out.println("hasWrapper:" + taintWrapperArgName);
													//System.out.println("wrapper name:" + soot_class.getPackageName() + "." + MyConstants.boolWrapper);
													thisTaintWrapperLocal = Jimple.v().newLocal(taintWrapperThisName, RefType.v(boolWrapper));
													body.getLocals().add(thisTaintWrapperLocal);
												}
	
												if(thisTaintLocal!=null && thisTaintWrapperLocal!=null){
	
													if(!newLocals.contains(thisTaintLocal)){
														newLocals.add(thisTaintLocal);
													}
	
													JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(thisTaintWrapperLocal, newBoolWrapper);
	
	
													SootMethod toCall = Scene.v().getMethod(boolInit);
													InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
															Jimple.v().newSpecialInvokeExpr(thisTaintWrapperLocal, toCall.makeRef()));
	
													AssignStmt toAdd3 = Jimple.v().newAssignStmt(
															Jimple.v().newInstanceFieldRef(
																	thisTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), thisTaintLocal);
	
													toAdd1.addTag(instrumentationTag);
													toAdd2.addTag(instrumentationTag);
													toAdd3.addTag(instrumentationTag);
	
													toAdd1.addTag(beforeWrapperTag);
													toAdd2.addTag(beforeWrapperTag);
													toAdd3.addTag(beforeWrapperTag);
	
													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													unitsToAdd.add(toAdd2);
													unitsToAdd.add(toAdd3);
													toInstrumentBefore.put(unitsToAdd, s);
	
													AssignStmt toAdd4 = Jimple.v().newAssignStmt(thisTaintLocal, 
															Jimple.v().newInstanceFieldRef(
																	thisTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));
	
													toAdd4.addTag(instrumentationTag);
													toAdd4.addTag(afterWrapperTag);
	
													List<Unit> unitsToAddAfter = new LinkedList<Unit>();
													unitsToAddAfter.add(toAdd4);
													toInstrumentAfter.put(unitsToAddAfter, s);
	
													nargs.add(thisTaintWrapperLocal);
													nargc++;
													//System.out.println("rhs instanceof InstanceInvokeExpr nargc++:" + nargc);
												}
	
											}else{
	
											}
										
										}

									}


									/*
									List<ValueBox> uses = rhs.getUseBoxes();
									for(ValueBox vb : uses){
										Value v = vb.getValue();
										if(v instanceof Local){
											if(!args.contains(v)){
												String thisName = ((Local)v).getName();

												Local thisTaintLocal = null;
												String taintThisName = getTaintVarName(thisName);

												boolean hasVar = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintThisName)) {
														hasVar = true;
														thisTaintLocal = l;
													}
												}

												if (!hasVar) {
													thisTaintLocal = Jimple.v().newLocal(taintThisName, BooleanType.v());
													body.getLocals().add(thisTaintLocal);
												}

												Local thisTaintWrapperLocal = null;
												String taintWrapperThisName = getTaintWrapperName(taintThisName);

												boolean hasWrapper = false;
												for(Local l : body.getLocals()){
													if(l.getName().equals(taintWrapperThisName)){
														hasWrapper = true;
														thisTaintWrapperLocal = l;
													}
												}

												if(!hasWrapper){
													//System.out.println("hasWrapper:" + taintWrapperArgName);
													//System.out.println("wrapper name:" + soot_class.getPackageName() + "." + MyConstants.boolWrapper);
													thisTaintWrapperLocal = Jimple.v().newLocal(taintWrapperThisName, RefType.v(boolWrapper));
													body.getLocals().add(thisTaintWrapperLocal);
												}

												if(thisTaintLocal!=null && thisTaintWrapperLocal!=null){

													if(!newLocals.contains(thisTaintLocal)){
														newLocals.add(thisTaintLocal);
													}

													JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(thisTaintWrapperLocal, newBoolWrapper);


													SootMethod toCall = Scene.v().getMethod(boolInit);
									                InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
									                		Jimple.v().newSpecialInvokeExpr(thisTaintWrapperLocal, toCall.makeRef()));

													AssignStmt toAdd3 = Jimple.v().newAssignStmt(
															Jimple.v().newInstanceFieldRef(
																	thisTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), thisTaintLocal);

													toAdd1.addTag(instrumentationTag);
													toAdd2.addTag(instrumentationTag);
													toAdd3.addTag(instrumentationTag);

													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													unitsToAdd.add(toAdd2);
													unitsToAdd.add(toAdd3);
													toInstrumentBefore.put(unitsToAdd, s);

													AssignStmt toAdd4 = Jimple.v().newAssignStmt(thisTaintLocal, 
															Jimple.v().newInstanceFieldRef(
																	thisTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));

													toAdd4.addTag(instrumentationTag);
													List<Unit> unitsToAddAfter = new LinkedList<Unit>();
													unitsToAddAfter.add(toAdd4);
													toInstrumentAfter.put(unitsToAddAfter, s);

													nargs.add(thisTaintWrapperLocal);
												}
											}
										}else{

										}
									}
									 */

									if(lhs instanceof Local){
										
										for(int sc=0;sc<sourceCount;sc++){

											String lVarName = ((Local)lhs).getName();
	
											Local lTaintLocal = null;
											String taintLVarName = getTaintVarName(lVarName, sc);
	
											boolean hasVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintLVarName)) {
													hasVar1 = true;
													lTaintLocal = l;
												}
											}
	
											if (!hasVar1) {
												lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
												body.getLocals().add(lTaintLocal);
											}
	
											Local lTaintWrapperLocal = null;
											String taintWrapperLVarName = getTaintWrapperName(taintLVarName);
	
											boolean hasWrapper = false;
											for(Local l : body.getLocals()){
												if(l.getName().equals(taintWrapperLVarName)){
													hasWrapper = true;
													lTaintWrapperLocal = l;
												}
											}
	
											if(!hasWrapper){
												lTaintWrapperLocal = Jimple.v().newLocal(taintWrapperLVarName, RefType.v(boolWrapper));
												body.getLocals().add(lTaintWrapperLocal);
											}
	
	
											if(lTaintLocal!=null && lTaintWrapperLocal!=null){
	
												if(!newLocals.contains(lTaintLocal)){
													newLocals.add(lTaintLocal);
												}
	
												JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintWrapperLocal, newBoolWrapper);
	
												//System.out.println("<"+boolWrapper+": boolean b>");
												//System.out.println(Scene.v().getField("<"+boolWrapper+": boolean b>").makeRef());
	
												SootMethod toCall = Scene.v().getMethod(boolInit);
												InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
														Jimple.v().newSpecialInvokeExpr(lTaintWrapperLocal, toCall.makeRef()));
	
												AssignStmt toAdd3 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(
																lTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), lTaintLocal);
	
												toAdd1.addTag(instrumentationTag);
												toAdd2.addTag(instrumentationTag);
												toAdd3.addTag(instrumentationTag);
	
												toAdd1.addTag(beforeWrapperTag);
												toAdd2.addTag(beforeWrapperTag);
												toAdd3.addTag(beforeWrapperTag);
	
												List<Unit> unitsToAddBefore = new LinkedList<Unit>();
												unitsToAddBefore.add(toAdd1);
												unitsToAddBefore.add(toAdd2);
												unitsToAddBefore.add(toAdd3);
												toInstrumentBefore.put(unitsToAddBefore, s);
	
	
												AssignStmt toAdd4 = Jimple.v().newAssignStmt(lTaintLocal, 
														Jimple.v().newInstanceFieldRef(
																lTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));
	
												toAdd4.addTag(instrumentationTag);
												toAdd4.addTag(afterWrapperTag);
	
												List<Unit> unitsToAddAfter = new LinkedList<Unit>();
												unitsToAddAfter.add(toAdd4);
												toInstrumentAfter.put(unitsToAddAfter, s);
	
												nargs.add(lTaintWrapperLocal);
												nargc++;
												//System.out.println("lhs instanceof Local nargc++:" + nargc);
											}
										
										}

									}else if(lhs instanceof InstanceFieldRef){

										//System.out.println("lhs instanceof InstanceFieldRef");

										/*
										String absoluteName = "";
										String absoluteBase = "";
										Stack<String> fieldNameStack = new Stack<String>();

										Value base = ((InstanceFieldRef) lhs).getBase();
										SootField field = ((InstanceFieldRef) lhs).getField();




										if(base instanceof Local){

											absoluteBase = ((Local) base).getName();
											fieldNameStack.push(field.getName());

											boolean hasDef = false;
											Stmt def0 = s;
											{
												List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
												if(defs0.size()==1){
													def0 = (Stmt)defs0.get(0);
													hasDef = true;
												}
											}

											while(hasDef){
												System.out.println("def0:" + def0);


												if(def0 instanceof DefinitionStmt){
													Value def0lhs = ((DefinitionStmt) def0).getLeftOp();
													Value def0rhs = ((DefinitionStmt) def0).getRightOp();

													if(def0rhs instanceof InstanceFieldRef){
														//System.out.print("instance field expression: " + def0);
														Value def0base = ((InstanceFieldRef) def0rhs).getBase();
														SootField def0field = ((InstanceFieldRef) def0rhs).getField();

														System.out.println("base+field:" + def0base + "|" + def0field);

														if(def0base instanceof Local){

															absoluteBase = ((Local) def0base).getName();
															fieldNameStack.push(def0field.getName());

															List<Unit> defs0 = mrd.getDefsOfAt((Local)def0base, def0);
															if(defs0.size()==1){

																def0 = (Stmt)defs0.get(0);

															}else{
																hasDef = false;
															}

														}else{
															hasDef = false;
														}


													}

													else{
														hasDef = false;
													}

												}else{
													hasDef = false;
												}
											}

											if((!absoluteBase.equals("")) && (!fieldNameStack.isEmpty())){
												absoluteName = absoluteBase;
												while(!fieldNameStack.isEmpty()){
													String fieldName = fieldNameStack.pop();



													absoluteName += ("_" + fieldName);
													System.out.println("absoluteName:" + absoluteName);
												}

											}

											String lVarName = "";
											if(!absoluteName.isEmpty()){
												lVarName = absoluteName;
											}else{

												lVarName = ((Local)base).getName()+ "_" + field.getName();
											}

											Local lTaintLocal = null;
											String taintLVarName = getTaintVarName(lVarName);

											boolean hasVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintLVarName)) {
													hasVar1 = true;
													lTaintLocal = l;
												}
											}

											if (!hasVar1) {
												lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
												body.getLocals().add(lTaintLocal);
											}

											Local lTaintWrapperLocal = null;
											String taintWrapperLVarName = getTaintWrapperName(taintLVarName);

											boolean hasWrapper = false;
											for(Local l : body.getLocals()){
												if(l.getName().equals(taintWrapperLVarName)){
													hasWrapper = true;
													lTaintWrapperLocal = l;
												}
											}

											if(!hasWrapper){
												lTaintWrapperLocal = Jimple.v().newLocal(taintWrapperLVarName, RefType.v(boolWrapper));
												body.getLocals().add(lTaintWrapperLocal);
											}


											if(lTaintLocal!=null && lTaintWrapperLocal!=null){

												if(!newLocals.contains(lTaintLocal)){
													newLocals.add(lTaintLocal);
												}

												JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintWrapperLocal, newBoolWrapper);

												//System.out.println("<"+boolWrapper+": boolean b>");
												//System.out.println(Scene.v().getField("<"+boolWrapper+": boolean b>").makeRef());

												SootMethod toCall = Scene.v().getMethod(boolInit);
								                InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
								                		Jimple.v().newSpecialInvokeExpr(lTaintWrapperLocal, toCall.makeRef()));

												AssignStmt toAdd3 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(
																lTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), lTaintLocal);

												toAdd1.addTag(instrumentationTag);
												toAdd2.addTag(instrumentationTag);
												toAdd3.addTag(instrumentationTag);

												toAdd1.addTag(beforeWrapperTag);
												toAdd2.addTag(beforeWrapperTag);
												toAdd3.addTag(beforeWrapperTag);

												List<Unit> unitsToAddBefore = new LinkedList<Unit>();
												unitsToAddBefore.add(toAdd1);
												unitsToAddBefore.add(toAdd2);
												unitsToAddBefore.add(toAdd3);
												toInstrumentBefore.put(unitsToAddBefore, s);


												AssignStmt toAdd4 = Jimple.v().newAssignStmt(lTaintLocal, 
														Jimple.v().newInstanceFieldRef(
																lTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));

												toAdd4.addTag(instrumentationTag);
												toAdd4.addTag(afterWrapperTag);

												List<Unit> unitsToAddAfter = new LinkedList<Unit>();
												unitsToAddAfter.add(toAdd4);
												toInstrumentAfter.put(unitsToAddAfter, s);

												nargs.add(lTaintWrapperLocal);
												nargc++;
											}
										}
										 */

									}else if(lhs instanceof ArrayRef){
										/*
										Value base = ((ArrayRef) lhs).getBase();

										if(base instanceof Local){

											String lVarName = ((Local)base).getName();

											Local lTaintLocal = null;
											String taintLVarName = getTaintVarName(lVarName);

											boolean hasVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintLVarName)) {
													hasVar1 = true;
													lTaintLocal = l;
												}
											}

											if (!hasVar1) {
												lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
												body.getLocals().add(lTaintLocal);
											}

											Local lTaintWrapperLocal = null;
											String taintWrapperLVarName = getTaintWrapperName(taintLVarName);

											boolean hasWrapper = false;
											for(Local l : body.getLocals()){
												if(l.getName().equals(taintWrapperLVarName)){
													hasWrapper = true;
													lTaintWrapperLocal = l;
												}
											}

											if(!hasWrapper){
												lTaintWrapperLocal = Jimple.v().newLocal(taintWrapperLVarName, RefType.v(boolWrapper));
												body.getLocals().add(lTaintWrapperLocal);
											}


											if(lTaintLocal!=null && lTaintWrapperLocal!=null){

												if(!newLocals.contains(lTaintLocal)){
													newLocals.add(lTaintLocal);
												}

												JNewExpr newBoolWrapper = new JNewExpr(RefType.v(boolWrapper));
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintWrapperLocal, newBoolWrapper);

												//System.out.println("<"+boolWrapper+": boolean b>");
												//System.out.println(Scene.v().getField("<"+boolWrapper+": boolean b>").makeRef());

												SootMethod toCall = Scene.v().getMethod(boolInit);
												InvokeStmt toAdd2 = Jimple.v().newInvokeStmt(
														Jimple.v().newSpecialInvokeExpr(lTaintWrapperLocal, toCall.makeRef()));

												AssignStmt toAdd3 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(
																lTaintWrapperLocal, Scene.v().getField(boolField).makeRef()), lTaintLocal);

												toAdd1.addTag(instrumentationTag);
												toAdd2.addTag(instrumentationTag);
												toAdd3.addTag(instrumentationTag);

												toAdd1.addTag(beforeWrapperTag);
												toAdd2.addTag(beforeWrapperTag);
												toAdd3.addTag(beforeWrapperTag);

												List<Unit> unitsToAddBefore = new LinkedList<Unit>();
												unitsToAddBefore.add(toAdd1);
												unitsToAddBefore.add(toAdd2);
												unitsToAddBefore.add(toAdd3);
												toInstrumentBefore.put(unitsToAddBefore, s);


												AssignStmt toAdd4 = Jimple.v().newAssignStmt(lTaintLocal, 
														Jimple.v().newInstanceFieldRef(
																lTaintWrapperLocal, Scene.v().getField(boolField).makeRef()));

												toAdd4.addTag(instrumentationTag);
												toAdd4.addTag(afterWrapperTag);

												List<Unit> unitsToAddAfter = new LinkedList<Unit>();
												unitsToAddAfter.add(toAdd4);
												toInstrumentAfter.put(unitsToAddAfter, s);

												nargs.add(lTaintWrapperLocal);
												nargc++;
												//System.out.println("lhs instanceof ArrayRef: nargc++:" + nargc);
											}
										}
										*/

									}

									else{

									}

									SootMethod oldMethod = ((InvokeExpr) rhs).getMethod();
									String oldMethodName = oldMethod.getName();
									SootClass oldMethodClass = oldMethod.getDeclaringClass();
									Type oldReturnType = oldMethod.getReturnType();
									List<Type> oldParameterTypes = oldMethod.getParameterTypes();


									List<Type> nargsType = new ArrayList<Type>();
									for(Type t : oldParameterTypes){
										nargsType.add(t);
									}
									for(int c=0;c<nargc;c++){
										nargsType.add(RefType.v(boolWrapper));
									}

									SootMethod toCall = Scene.v().getMethod(SootMethod.getSignature(
											oldMethodClass, getWrapperMethodName(oldMethodName), nargsType, oldReturnType));

									if(MyConstants.DEBUG_INFO)
										System.out.println("nargsType: " + nargsType);

									if(rhs instanceof StaticInvokeExpr){
										AssignStmt nStmt = Jimple.v().newAssignStmt(
												nlhs, Jimple.v().newStaticInvokeExpr(toCall.makeRef(), nargs));
										nStmt.addTag(instrumentationTag);
										nStmt.addTag(invokeWrapperTag);
										toInstrumentAt.put(nStmt, s);
									}else if(rhs instanceof VirtualInvokeExpr){
										Value base = ((VirtualInvokeExpr) rhs).getBase();
										if(base instanceof Local){
											AssignStmt nStmt = Jimple.v().newAssignStmt(
													nlhs, Jimple.v().newVirtualInvokeExpr((Local)base, toCall.makeRef(), nargs));
											nStmt.addTag(instrumentationTag);
											nStmt.addTag(invokeWrapperTag);
											toInstrumentAt.put(nStmt, s);
										}
									}else if(rhs instanceof SpecialInvokeExpr){
										Value base = ((SpecialInvokeExpr) rhs).getBase();
										if(base instanceof Local){
											AssignStmt nStmt = Jimple.v().newAssignStmt(
													nlhs, Jimple.v().newSpecialInvokeExpr((Local)base, toCall.makeRef(), nargs));
											nStmt.addTag(instrumentationTag);
											nStmt.addTag(invokeWrapperTag);
											toInstrumentAt.put(nStmt, s);
										}
									}else if(rhs instanceof InterfaceInvokeExpr){
										Value base = ((InterfaceInvokeExpr) rhs).getBase();
										if(base instanceof Local){
											AssignStmt nStmt = Jimple.v().newAssignStmt(
													nlhs, Jimple.v().newInterfaceInvokeExpr((Local)base, toCall.makeRef(), nargs));
											nStmt.addTag(instrumentationTag);
											nStmt.addTag(invokeWrapperTag);
											toInstrumentAt.put(nStmt, s);
										}
									}

								}

							} else {
								// regular definition statements
								

								for(Integer label : labels){
									
									if(rhs instanceof Local){
										
										String rVarName = ((Local)(rhs)).getName();
	
										Local rTaintLocal = null;
										String taintRVarName = getTaintVarName(rVarName, label.intValue());
	
										boolean hasVar = false;
										for (Local l : body.getLocals()) {
											if (l.getName().equals(taintRVarName)) {
												hasVar = true;
												rTaintLocal = l;
											}
										}
	
										if (!hasVar) {
											rTaintLocal = Jimple.v().newLocal(taintRVarName, BooleanType.v());
											body.getLocals().add(rTaintLocal);
										}
	
										InstanceFieldRef rFieldRef = null;
										if(rhs.getType() instanceof RefLikeType){
											List<Unit> defs = mrd.getDefsOfAt((Local)rhs, s);
											if(defs.size()==1){
												Stmt def = (Stmt)defs.get(0);
												if(def instanceof DefinitionStmt){
													Value rDef = ((DefinitionStmt) def).getRightOp();
													if(rDef instanceof InstanceFieldRef){
														rFieldRef = (InstanceFieldRef)rDef;										
													}
												}
	
											}
										}
	
										if(lhs instanceof Local){
											String lVarName = ((Local)lhs).getName();
	
											Local lTaintLocal = null;
											String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
											boolean hasVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintLVarName)) {
													hasVar1 = true;
													lTaintLocal = l;
												}
											}
	
											if (!hasVar1) {
												lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
												body.getLocals().add(lTaintLocal);
											}
	
											if(rTaintLocal!=null && lTaintLocal !=null){
	
												if(!newLocals.contains(lTaintLocal)){
													newLocals.add(lTaintLocal);
												}
	
												if(!newLocals.contains(rTaintLocal)){
													newLocals.add(rTaintLocal);
												}
	
												List<Unit> unitsToAdd = new LinkedList<Unit>();
	
												if(rFieldRef==null){											
	
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
													toAdd1.addTag(instrumentationTag);												
													unitsToAdd.add(toAdd1);
	
												}else{
													SootField rField = rFieldRef.getField();
													SootField rTaintField = rField.getDeclaringClass().getFieldByName(getTaintVarName(rField.getName(), label.intValue()));
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(
															rTaintLocal, Jimple.v().newInstanceFieldRef(rFieldRef.getBase(), rTaintField.makeRef()));
													AssignStmt toAdd2 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
	
													toAdd1.addTag(instrumentationTag);
													toAdd1.addTag(referenceTag);
													toAdd2.addTag(instrumentationTag);
	
													unitsToAdd.add(toAdd1);
													unitsToAdd.add(toAdd2);
	
												}
	
												toInstrumentAfter.put(unitsToAdd, s);
											}
	
										}else if(lhs instanceof InstanceFieldRef){
	
											/*
											Value base = ((InstanceFieldRef) lhs).getBase();
											SootField field = ((InstanceFieldRef) lhs).getField();
											SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarNamefield.getName()));
	
	
											if(rTaintLocal!=null){
	
												if(!newLocals.contains(rTaintLocal)){
													newLocals.add(rTaintLocal);
												}
	
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(base, taintField.makeRef()), rTaintLocal);
												toAdd1.addTag(instrumentationTag);
												toAdd1.addTag(referenceTag);
												List<Unit> unitsToAdd = new LinkedList<Unit>();
												unitsToAdd.add(toAdd1);
												toInstrumentAfter.put(unitsToAdd, s);
	
											}
											 */
	
	
											Stack<SootField> fieldStack = new Stack<SootField>();
											Stack<Value> baseStack = new Stack<Value>();
	
											Value base = ((InstanceFieldRef) lhs).getBase();
											SootField field = ((InstanceFieldRef) lhs).getField();										
	
											if(!field.getDeclaringClass().isApplicationClass()){
												System.out.println("Problem: instrumenting a field in a non-application class");
												continue;
											}
	
											SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName(), label.intValue()));
	
	
	
											if(base instanceof Local){
	
												baseStack.push(base);
												fieldStack.push(taintField);
	
												boolean hasDef = false;
												Stmt def0 = s;
												{
													List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
													if(defs0.size()==1){
														def0 = (Stmt)defs0.get(0);
														hasDef = true;
													}
												}
	
												while(hasDef){
	
													if(MyConstants.DEBUG_INFO)
														System.out.println("def0:" + def0);
	
	
													if(def0 instanceof DefinitionStmt){
														Value def0lhs = ((DefinitionStmt) def0).getLeftOp();
														Value def0rhs = ((DefinitionStmt) def0).getRightOp();
	
														if(def0rhs instanceof InstanceFieldRef){
															//System.out.print("instance field expression: " + def0);
															Value def0base = ((InstanceFieldRef) def0rhs).getBase();
															SootField def0field = ((InstanceFieldRef) def0rhs).getField();
	
															if(!def0field.getDeclaringClass().isApplicationClass()){
																System.out.println("Problem: instrumenting a field in a non-application class");
																break;												
															}
	
															SootField def0taintField = def0field.getDeclaringClass().getFieldByName(getTaintVarName(def0field.getName(), label.intValue()));
	
															if(MyConstants.DEBUG_INFO)
																System.out.println("base+field:" + def0base + "|" + def0field);
	
															if(def0base instanceof Local){
	
																baseStack.push(def0base);
																fieldStack.push(def0taintField);
	
																List<Unit> defs0 = mrd.getDefsOfAt((Local)def0base, def0);
																if(defs0.size()==1){
	
																	def0 = (Stmt)defs0.get(0);
	
																}else{
																	hasDef = false;
																}
	
															}else{
																hasDef = false;
															}
	
	
														}
	
														else{
															hasDef = false;
														}
	
													}else{
														hasDef = false;
													}
												}
	
												while(!baseStack.isEmpty()){
	
													base = baseStack.pop();
													taintField = fieldStack.pop();
	
													String lVarName = ((Local)base).getName();
	
													Local lTaintLocal = null;
													String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
													boolean hasVar1 = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(taintLVarName)) {
															hasVar1 = true;
															lTaintLocal = l;
														}
													}
	
													if (!hasVar1) {
														lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
														body.getLocals().add(lTaintLocal);
													}
	
	
													if(rTaintLocal!=null && lTaintLocal!=null){
	
														if(!newLocals.contains(rTaintLocal)){
															newLocals.add(rTaintLocal);
														}
	
														if(!newLocals.contains(lTaintLocal)){
															newLocals.add(lTaintLocal);
														}
	
	
	
														List<Unit> unitsToAdd = new LinkedList<Unit>();
	
	
														if(rFieldRef==null){											
	
															AssignStmt toAdd1 = Jimple.v().newAssignStmt(
																	Jimple.v().newInstanceFieldRef(base, taintField.makeRef()), rTaintLocal);
															AssignStmt toAdd2 = Jimple.v().newAssignStmt(
																	lTaintLocal, rTaintLocal);
	
															toAdd1.addTag(instrumentationTag);
															toAdd1.addTag(referenceTag);
															toAdd2.addTag(instrumentationTag);
															//toAdd2.addTag(referenceTag);											
	
															unitsToAdd.add(toAdd1);
															unitsToAdd.add(toAdd2);
	
														}else{
	
															SootField rField = rFieldRef.getField();
	
															if(!rField.getDeclaringClass().isApplicationClass()){
																System.out.println("Problem: instrumenting a field in a non-application class");
																continue;
															}
	
															SootField rTaintField = rField.getDeclaringClass().getFieldByName(getTaintVarName(rField.getName(), label.intValue()));
															AssignStmt toAdd1 = Jimple.v().newAssignStmt(
																	rTaintLocal, Jimple.v().newInstanceFieldRef(rFieldRef.getBase(), rTaintField.makeRef()));
															AssignStmt toAdd2 = Jimple.v().newAssignStmt(
																	Jimple.v().newInstanceFieldRef(base, taintField.makeRef()), rTaintLocal);
															AssignStmt toAdd3 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
	
															toAdd1.addTag(instrumentationTag);
															toAdd1.addTag(referenceTag);
															toAdd2.addTag(instrumentationTag);
															toAdd2.addTag(referenceTag);
															toAdd3.addTag(instrumentationTag);
															//toAdd3.addTag(referenceTag);
	
															unitsToAdd.add(toAdd1);
															unitsToAdd.add(toAdd2);
															unitsToAdd.add(toAdd3);
	
														}
	
														toInstrumentAfter.put(unitsToAdd, s);
													}
	
												}
											}
	
	
										}else if(lhs instanceof ArrayRef){
	
											Value base = ((ArrayRef) lhs).getBase();
	
											if(base instanceof Local){
	
												String lVarName = ((Local)base).getName();
	
												Local lTaintLocal = null;
												String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
												boolean hasVar1 = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintLVarName)) {
														hasVar1 = true;
														lTaintLocal = l;
													}
												}
	
												if (!hasVar1) {
													lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
													body.getLocals().add(lTaintLocal);
												}
	
												if(rTaintLocal!=null && lTaintLocal !=null){
	
													if(!newLocals.contains(rTaintLocal)){
														newLocals.add(rTaintLocal);
													}
	
													if(!newLocals.contains(lTaintLocal)){
														newLocals.add(lTaintLocal);
													}
	
													List<Unit> unitsToAdd = new LinkedList<Unit>();
	
													if(rFieldRef==null){											
	
														AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
														toAdd1.addTag(instrumentationTag);												
														unitsToAdd.add(toAdd1);
	
													}else{
														SootField rField = rFieldRef.getField();
	
														if(!rField.getDeclaringClass().declaresFieldByName(getTaintVarName(rField.getName(), label.intValue()))){
															continue;
														}
	
														SootField rTaintField = rField.getDeclaringClass().getFieldByName(getTaintVarName(rField.getName(), label.intValue()));
														AssignStmt toAdd1 = Jimple.v().newAssignStmt(
																rTaintLocal, Jimple.v().newInstanceFieldRef(rFieldRef.getBase(), rTaintField.makeRef()));
														AssignStmt toAdd2 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
	
														toAdd1.addTag(instrumentationTag);
														toAdd1.addTag(referenceTag);
														toAdd2.addTag(instrumentationTag);
	
														unitsToAdd.add(toAdd1);
														unitsToAdd.add(toAdd2);
	
													}
	
													toInstrumentAfter.put(unitsToAdd, s);
	
												}
											}
	
										}else if(lhs instanceof StaticFieldRef){
	
											SootField field = ((StaticFieldRef) lhs).getField();
											SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName(), label.intValue()));
	
											if(rTaintLocal!=null){
	
												if(!newLocals.contains(rTaintLocal)){
													newLocals.add(rTaintLocal);
												}
	
	
												List<Unit> unitsToAdd = new LinkedList<Unit>();
	
												if(rFieldRef==null){											
	
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(
															Jimple.v().newStaticFieldRef(taintField.makeRef()), rTaintLocal);
													toAdd1.addTag(instrumentationTag);
													toAdd1.addTag(referenceTag);
													unitsToAdd.add(toAdd1);
	
												}else{
													SootField rField = rFieldRef.getField();
	
													if(!rField.getDeclaringClass().isApplicationClass()){
														System.out.println("Problem: instrumenting a field in a non-application class");
														continue;
													}
	
													SootField rTaintField = rField.getDeclaringClass().getFieldByName(getTaintVarName(rField.getName(), label.intValue()));
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(
															rTaintLocal, Jimple.v().newInstanceFieldRef(rFieldRef.getBase(), rTaintField.makeRef()));
													AssignStmt toAdd2 = Jimple.v().newAssignStmt(
															Jimple.v().newStaticFieldRef(taintField.makeRef()), rTaintLocal);
	
													toAdd1.addTag(instrumentationTag);
													toAdd1.addTag(referenceTag);
													toAdd2.addTag(instrumentationTag);
													toAdd2.addTag(referenceTag);
	
													unitsToAdd.add(toAdd1);
													unitsToAdd.add(toAdd2);
	
												}
	
												toInstrumentAfter.put(unitsToAdd, s);
	
											}
	
										}
	
										else{
	
										}
									}else if(rhs instanceof CastExpr){
										Value op = ((CastExpr) rhs).getOp();
										if(op instanceof Local){
											String rVarName = ((Local)op).getName();
	
											Local rTaintLocal = null;
											String taintRVarName = getTaintVarName(rVarName, label.intValue());
	
											boolean hasVar = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintRVarName)) {
													hasVar = true;
													rTaintLocal = l;
												}
											}
	
											if (!hasVar) {
												rTaintLocal = Jimple.v().newLocal(taintRVarName, BooleanType.v());
												body.getLocals().add(rTaintLocal);
											}
	
											if(lhs instanceof Local){
												String lVarName = ((Local)lhs).getName();
	
												Local lTaintLocal = null;
												String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
												boolean hasVar1 = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintLVarName)) {
														hasVar1 = true;
														lTaintLocal = l;
													}
												}
	
												if (!hasVar1) {
													lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
													body.getLocals().add(lTaintLocal);
												}
	
												if(rTaintLocal!=null && lTaintLocal !=null){
	
													if(!newLocals.contains(rTaintLocal)){
														newLocals.add(rTaintLocal);
													}
	
													if(!newLocals.contains(lTaintLocal)){
														newLocals.add(lTaintLocal);
													}
	
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
													toAdd1.addTag(instrumentationTag);
													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													toInstrumentAfter.put(unitsToAdd, s);
												}
											}else{
	
											}
										}
									}
	
	
									else if(rhs instanceof UnopExpr){
										if(((UnopExpr) rhs).getOp() instanceof Local){
											String rVarName = ((Local)(((UnopExpr) rhs).getOp())).getName();
	
											Local rTaintLocal = null;
											String taintRVarName = getTaintVarName(rVarName, label.intValue());
	
											boolean hasVar = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintRVarName)) {
													hasVar = true;
													rTaintLocal = l;
												}
											}
	
											if (!hasVar) {
												rTaintLocal = Jimple.v().newLocal(taintRVarName, BooleanType.v());
												body.getLocals().add(rTaintLocal);
											}
	
											if(lhs instanceof Local){
												String lVarName = ((Local)lhs).getName();
	
												Local lTaintLocal = null;
												String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
												boolean hasVar1 = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintLVarName)) {
														hasVar1 = true;
														lTaintLocal = l;
													}
												}
	
												if (!hasVar1) {
													lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
													body.getLocals().add(lTaintLocal);
												}
	
												if(rTaintLocal!=null && lTaintLocal !=null){
	
													if(!newLocals.contains(rTaintLocal)){
														newLocals.add(rTaintLocal);
													}
	
													if(!newLocals.contains(lTaintLocal)){
														newLocals.add(lTaintLocal);
													}
	
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
													toAdd1.addTag(instrumentationTag);
													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													toInstrumentAfter.put(unitsToAdd, s);
												}
											}else{
	
											}
										}else{
											//lhs is static field
										}
									}else if(rhs instanceof BinopExpr){
										//rhs:op1
										if(((BinopExpr) rhs).getOp1() instanceof Local){
											String rVarName1 = ((Local)(((BinopExpr) rhs).getOp1())).getName();
	
											Local rTaintLocal1 = null;
											String taintRVarName1 = getTaintVarName(rVarName1, label.intValue());
	
											boolean hasRVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintRVarName1)) {
													hasRVar1 = true;
													rTaintLocal1 = l;
												}
											}
	
											if (!hasRVar1) {
												rTaintLocal1 = Jimple.v().newLocal(taintRVarName1, BooleanType.v());
												body.getLocals().add(rTaintLocal1);
											}
	
											//rhs:op2
											if(((BinopExpr) rhs).getOp2() instanceof Local){
	
												String rVarName2 = ((Local)(((BinopExpr) rhs).getOp2())).getName();
	
												Local rTaintLocal2 = null;
												String taintRVarName2 = getTaintVarName(rVarName2, label.intValue());
	
												boolean hasRVar2 = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintRVarName2)) {
														hasRVar2 = true;
														rTaintLocal2 = l;
													}
												}
	
												if (!hasRVar2) {
													rTaintLocal2 = Jimple.v().newLocal(taintRVarName2, BooleanType.v());
													body.getLocals().add(rTaintLocal2);
												}
	
	
												//lhs
												if(lhs instanceof Local){
													String lVarName = ((Local)lhs).getName();
	
													Local lTaintLocal = null;
													String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
													boolean hasVar1 = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(taintLVarName)) {
															hasVar1 = true;
															lTaintLocal = l;
														}
													}
	
													if (!hasVar1) {
														lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
														body.getLocals().add(lTaintLocal);
													}
	
													if(rTaintLocal1!=null && rTaintLocal2!=null && lTaintLocal !=null){
	
														if(!newLocals.contains(rTaintLocal1)){
															newLocals.add(rTaintLocal1);
														}
	
														if(!newLocals.contains(rTaintLocal2)){
															newLocals.add(rTaintLocal2);
														}
	
														if(!newLocals.contains(lTaintLocal)){
															newLocals.add(lTaintLocal);
														}
	
														OrExpr orExpr = Jimple.v().newOrExpr(rTaintLocal1, rTaintLocal2);
														AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintLocal, orExpr);
														toAdd1.addTag(instrumentationTag);
														List<Unit> unitsToAdd = new LinkedList<Unit>();
														unitsToAdd.add(toAdd1);
														toInstrumentAfter.put(unitsToAdd, s);
													}
	
												}else{
	
												}
											}
										}else{
											//lhs is static field
										}
									}else if(rhs instanceof InstanceFieldRef){
										
										//initialize taint
										if(srcs.contains(((InstanceFieldRef) rhs).getField().getSignature())){
											
											int sc = CallGraphExample.sources.get(((InstanceFieldRef) rhs).getField().getSignature()).intValue();

											if(!MyConstants.COUNT_LOC){
												System.out.println("taint initialization:" + ((InstanceFieldRef) rhs).getField().getSignature());
											}

											if (lhs instanceof Local) {
												String varName = ((Local) lhs).getName();

												if(MyConstants.DEBUG_INFO)
													System.out.println(varName);

												Local taintLocal = null;

												String taintVarName = getTaintVarName(varName, sc);

												boolean hasVar = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintVarName)) {
														hasVar = true;
														taintLocal = l;
													}
												}

												if (!hasVar) {
													taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
													body.getLocals().add(taintLocal);
												}

												if (taintLocal != null) {

													if(!newLocals.contains(taintLocal)){
														newLocals.add(taintLocal);
													}

													AssignStmt toAdd1 = Jimple.v().newAssignStmt(taintLocal, IntConstant.v(1));
													toAdd1.addTag(instrumentationTag);
													toAdd1.addTag(initTaintTag);
													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													toInstrumentAfter.put(unitsToAdd, s);
												}

											}
											continue;
										}
										
										/*
										if(lhs.getType() instanceof RefLikeType){
											continue;
										}
										 */
	
										Value base = ((InstanceFieldRef) rhs).getBase();
										SootField field = ((InstanceFieldRef) rhs).getField();
	
										if(MyConstants.DEBUG_INFO)
											System.out.println("SootField: " + field);
	
										if(!field.getDeclaringClass().isApplicationClass()){
											System.out.println("Problem: instrumenting a field in a non-application class");
											continue;
										}
	
										SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName(), label.intValue()));
	
										if(lhs instanceof Local){
											String lVarName = ((Local)lhs).getName();
	
											Local lTaintLocal = null;
											String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
											boolean hasVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintLVarName)) {
													hasVar1 = true;
													lTaintLocal = l;
												}
											}
	
											if (!hasVar1) {
												lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
												body.getLocals().add(lTaintLocal);
											}
	
											if(lTaintLocal !=null){
	
												if(!newLocals.contains(lTaintLocal)){
													newLocals.add(lTaintLocal);
												}
	
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(
														lTaintLocal, Jimple.v().newInstanceFieldRef(base, taintField.makeRef()));
												toAdd1.addTag(instrumentationTag);
												toAdd1.addTag(referenceTag);
												List<Unit> unitsToAdd = new LinkedList<Unit>();
												unitsToAdd.add(toAdd1);
												toInstrumentAfter.put(unitsToAdd, s);
											}
										}else{
											//lhs is static field
										}
	
	
	
										/*
	
										String absoluteName = "";
										String absoluteBase = "";
										Stack<String> fieldNameStack = new Stack<String>();
	
										Value base = ((InstanceFieldRef) rhs).getBase();
										SootField field = ((InstanceFieldRef) rhs).getField();
	
	
	
	
										if(base instanceof Local){
	
											absoluteBase = ((Local) base).getName();
											fieldNameStack.push(field.getName());
	
											boolean hasDef = false;
											Stmt def0 = s;
											{
												List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
												if(defs0.size()==1){
													def0 = (Stmt)defs0.get(0);
													hasDef = true;
												}
											}
	
											while(hasDef){
												System.out.println("def0:" + def0);
	
	
												if(def0 instanceof DefinitionStmt){
													Value def0lhs = ((DefinitionStmt) def0).getLeftOp();
													Value def0rhs = ((DefinitionStmt) def0).getRightOp();
	
													if(def0rhs instanceof InstanceFieldRef){
														//System.out.print("instance field expression: " + def0);
														Value def0base = ((InstanceFieldRef) def0rhs).getBase();
														SootField def0field = ((InstanceFieldRef) def0rhs).getField();
	
														System.out.println("base+field:" + def0base + "|" + def0field);
	
														if(def0base instanceof Local){
	
															absoluteBase = ((Local) def0base).getName();
															fieldNameStack.push(def0field.getName());
	
															List<Unit> defs0 = mrd.getDefsOfAt((Local)def0base, def0);
															if(defs0.size()==1){
	
																def0 = (Stmt)defs0.get(0);
	
															}else{
																hasDef = false;
															}
	
														}else{
															hasDef = false;
														}
	
	
													}
	
													else{
														hasDef = false;
													}
	
												}else{
													hasDef = false;
												}
											}
	
											//List<String> fieldNames = new ArrayList<String>();
											if((!absoluteBase.equals("")) && (!fieldNameStack.isEmpty())){
												absoluteName = absoluteBase;
												//fieldNames.add(absoluteName);
	
												while(!fieldNameStack.isEmpty()){
													String fieldName = fieldNameStack.pop();
	
													absoluteName += ("_" + fieldName);
													//fieldNames.add(absoluteName);
													System.out.println("absoluteName:" + absoluteName);
												}
	
											}
	
	
											String rVarName = "";
											if(!absoluteName.isEmpty()){
												rVarName = absoluteName;
											}else{
	
												rVarName = ((Local)base).getName()+ "_" + field.getName();
											}
	
	
											//for(String rVarName : fieldNames){
	
	
												Local rTaintLocal = null;
												String taintRVarName = getTaintVarName(rVarName);
	
												boolean hasVar = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintRVarName)) {
														hasVar = true;
														rTaintLocal = l;
													}
												}
	
												if (!hasVar) {
													rTaintLocal = Jimple.v().newLocal(taintRVarName, BooleanType.v());
													body.getLocals().add(rTaintLocal);
												}
	
												if(lhs instanceof Local){
													String lVarName = ((Local)lhs).getName();
	
													Local lTaintLocal = null;
													String taintLVarName = getTaintVarName(lVarName);
	
													boolean hasVar1 = false;
													for (Local l : body.getLocals()) {
														if (l.getName().equals(taintLVarName)) {
															hasVar1 = true;
															lTaintLocal = l;
														}
													}
	
													if (!hasVar1) {
														lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
														body.getLocals().add(lTaintLocal);
													}
	
													if(rTaintLocal!=null && lTaintLocal !=null){
	
														if(!newLocals.contains(rTaintLocal)){
															newLocals.add(rTaintLocal);
														}
	
														if(!newLocals.contains(lTaintLocal)){
															newLocals.add(lTaintLocal);
														}
	
														AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
														toAdd1.addTag(instrumentationTag);
														List<Unit> unitsToAdd = new LinkedList<Unit>();
														unitsToAdd.add(toAdd1);
														toInstrumentAfter.put(unitsToAdd, s);
													}
												}else{
													//lhs is static field
												}
	
											//}
										}
	
										 */
									}else if(rhs instanceof ArrayRef){
										Value base = ((ArrayRef) rhs).getBase();
	
										if(base instanceof Local){
	
											String rVarName = ((Local)(base)).getName();
	
											Local rTaintLocal = null;
											String taintRVarName = getTaintVarName(rVarName, label.intValue());
	
											boolean hasVar = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintRVarName)) {
													hasVar = true;
													rTaintLocal = l;
												}
											}
	
											if (!hasVar) {
												rTaintLocal = Jimple.v().newLocal(taintRVarName, BooleanType.v());
												body.getLocals().add(rTaintLocal);
											}
	
											if(lhs instanceof Local){
												String lVarName = ((Local)lhs).getName();
	
												Local lTaintLocal = null;
												String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
												boolean hasVar1 = false;
												for (Local l : body.getLocals()) {
													if (l.getName().equals(taintLVarName)) {
														hasVar1 = true;
														lTaintLocal = l;
													}
												}
	
												if (!hasVar1) {
													lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
													body.getLocals().add(lTaintLocal);
												}
	
												if(rTaintLocal!=null && lTaintLocal !=null){
	
													if(!newLocals.contains(rTaintLocal)){
														newLocals.add(rTaintLocal);
													}
	
													if(!newLocals.contains(lTaintLocal)){
														newLocals.add(lTaintLocal);
													}
	
													AssignStmt toAdd1 = Jimple.v().newAssignStmt(lTaintLocal, rTaintLocal);
													toAdd1.addTag(instrumentationTag);
													List<Unit> unitsToAdd = new LinkedList<Unit>();
													unitsToAdd.add(toAdd1);
													toInstrumentAfter.put(unitsToAdd, s);
												}
											}else{
												//lhs is static field
											}
										}
	
									}else if(rhs instanceof StaticFieldRef){
	
										SootField field = ((StaticFieldRef) rhs).getField();									
										SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName(), label.intValue()));
	
										if(lhs instanceof Local){
											String lVarName = ((Local)lhs).getName();
	
											Local lTaintLocal = null;
											String taintLVarName = getTaintVarName(lVarName, label.intValue());
	
											boolean hasVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintLVarName)) {
													hasVar1 = true;
													lTaintLocal = l;
												}
											}
	
											if (!hasVar1) {
												lTaintLocal = Jimple.v().newLocal(taintLVarName, BooleanType.v());
												body.getLocals().add(lTaintLocal);
											}
	
											if(lTaintLocal !=null){
	
												if(!newLocals.contains(lTaintLocal)){
													newLocals.add(lTaintLocal);
												}
	
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(
														lTaintLocal, Jimple.v().newStaticFieldRef(taintField.makeRef()));
												toAdd1.addTag(instrumentationTag);
												toAdd1.addTag(referenceTag);
												List<Unit> unitsToAdd = new LinkedList<Unit>();
												unitsToAdd.add(toAdd1);
												toInstrumentAfter.put(unitsToAdd, s);
											}
										}else{
	
										}
									}
	
	
									else{
	
									}
									
								}
								
							}//end else //regular definition statements

						} else if (s instanceof ReturnStmt) {

						}


							
						
					}
					else if(s.getTags().contains(generalExtraDefTag)){
						if(s instanceof DefinitionStmt){
							
							for(Integer label : labels){
							
								Value lhs = ((DefinitionStmt) s).getLeftOp();
								if (lhs instanceof Local) {
									String varName = ((Local) lhs).getName();
									//System.out.println(varName);
	
									Local taintLocal = null;
	
									String taintVarName = getTaintVarName(varName, label.intValue());
									
									boolean hasVar = false;
									for (Local l : body.getLocals()) {
										if (l.getName().equals(taintVarName)) {
											hasVar = true;
											taintLocal = l;
										}
									}
	
									if (!hasVar) {
										taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
										body.getLocals().add(taintLocal);
									}
	
									if (taintLocal != null) {
										
										if(!newLocals.contains(taintLocal)){
											newLocals.add(taintLocal);
										}
										
										AssignStmt toAdd1 = Jimple.v().newAssignStmt(taintLocal, IntConstant.v(0));
										toAdd1.addTag(instrumentationTag);
										List<Unit> unitsToAdd = new LinkedList<Unit>();
										unitsToAdd.add(toAdd1);
										toInstrumentAfter.put(unitsToAdd, s);
									}
	
								}else if(lhs instanceof InstanceFieldRef){
									
									/*
									Value base = ((InstanceFieldRef) lhs).getBase();
									SootField field = ((InstanceFieldRef) lhs).getField();
									SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName()));
									
									AssignStmt toAdd1 = Jimple.v().newAssignStmt(
											Jimple.v().newInstanceFieldRef(base, taintField.makeRef()), IntConstant.v(0));
									toAdd1.addTag(instrumentationTag);
									toAdd1.addTag(referenceTag);
									List<Unit> unitsToAdd = new LinkedList<Unit>();
									unitsToAdd.add(toAdd1);
									toInstrumentAfter.put(unitsToAdd, s);
									*/
									
									
									Stack<SootField> fieldStack = new Stack<SootField>();
									Stack<Value> baseStack = new Stack<Value>();
									
									Value base = ((InstanceFieldRef) lhs).getBase();
									SootField field = ((InstanceFieldRef) lhs).getField();
									SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName(), label.intValue()));		
									
									
														
									
									if(base instanceof Local){
										
										baseStack.push(base);
										fieldStack.push(taintField);
										
										boolean hasDef = false;
										Stmt def0 = s;
										{
											List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
											if(defs0.size()==1){
												def0 = (Stmt)defs0.get(0);
												hasDef = true;
											}
										}
										
										while(hasDef){
											
											if(MyConstants.DEBUG_INFO)
												System.out.println("def0:" + def0);
											
											
											if(def0 instanceof DefinitionStmt){
												Value def0lhs = ((DefinitionStmt) def0).getLeftOp();
												Value def0rhs = ((DefinitionStmt) def0).getRightOp();
												
												if(def0rhs instanceof InstanceFieldRef){
													//System.out.print("instance field expression: " + def0);
													Value def0base = ((InstanceFieldRef) def0rhs).getBase();
													SootField def0field = ((InstanceFieldRef) def0rhs).getField();
													SootField def0taintField = def0field.getDeclaringClass().getFieldByName(getTaintVarName(def0field.getName(), label.intValue()));		
													
													if(MyConstants.DEBUG_INFO)
														System.out.println("base+field:" + def0base + "|" + def0field);
													
													if(def0base instanceof Local){
														
														baseStack.push(def0base);
														fieldStack.push(def0taintField);
														
														List<Unit> defs0 = mrd.getDefsOfAt((Local)def0base, def0);
														if(defs0.size()==1){
															
															def0 = (Stmt)defs0.get(0);
															
														}else{
															hasDef = false;
														}
														
													}else{
														hasDef = false;
													}
													
												
												}
												
												else{
													hasDef = false;
												}
												
											}else{
												hasDef = false;
											}
										}
										
										if(!baseStack.isEmpty()){
											
											base = baseStack.pop();
											taintField = fieldStack.pop();
	
											Local taintLocal = null;
											
											String varName = ((Local)base).getName();
											
											String taintVarName = getTaintVarName(varName, label.intValue());
												
											boolean hasVar1 = false;
											for (Local l : body.getLocals()) {
												if (l.getName().equals(taintVarName)) {
													hasVar1 = true;
													taintLocal = l;
												}
											}
	
											if (!hasVar1) {
												taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
												body.getLocals().add(taintLocal);
											}
											
											if(taintLocal!=null){
												
												if(!newLocals.contains(taintLocal)){
													newLocals.add(taintLocal);
												}
		
												AssignStmt toAdd1 = Jimple.v().newAssignStmt(
														Jimple.v().newInstanceFieldRef(base, taintField.makeRef()), IntConstant.v(0));
												AssignStmt toAdd2 = Jimple.v().newAssignStmt(
														taintLocal, IntConstant.v(0));
												
												toAdd1.addTag(instrumentationTag);
												toAdd1.addTag(referenceTag);
												toAdd2.addTag(instrumentationTag);
												toAdd2.addTag(referenceTag);
												
												List<Unit> unitsToAdd = new LinkedList<Unit>();
												unitsToAdd.add(toAdd1);
												unitsToAdd.add(toAdd2);
												
												toInstrumentAfter.put(unitsToAdd, s);
											}
										
										}
									}
									
								}else if(lhs instanceof ArrayRef){
									
									Value base = ((ArrayRef) lhs).getBase();
									
									if(base instanceof Local){
									
										String varName = ((Local) base).getName();
										//System.out.println(varName);
	
										Local taintLocal = null;
	
										String taintVarName = getTaintVarName(varName, label.intValue());
										
										boolean hasVar = false;
										for (Local l : body.getLocals()) {
											if (l.getName().equals(taintVarName)) {
												hasVar = true;
												taintLocal = l;
											}
										}
	
										if (!hasVar) {
											taintLocal = Jimple.v().newLocal(taintVarName, BooleanType.v());
											body.getLocals().add(taintLocal);
										}
	
										if (taintLocal != null) {
											
											if(!newLocals.contains(taintLocal)){
												newLocals.add(taintLocal);
											}
											
											AssignStmt toAdd1 = Jimple.v().newAssignStmt(taintLocal, IntConstant.v(0));
											toAdd1.addTag(instrumentationTag);
											List<Unit> unitsToAdd = new LinkedList<Unit>();
											unitsToAdd.add(toAdd1);
											toInstrumentAfter.put(unitsToAdd, s);
										}
									}
									
								}else if(lhs instanceof StaticFieldRef){
									
									
									SootField field = ((StaticFieldRef) lhs).getField();
									SootField taintField = field.getDeclaringClass().getFieldByName(getTaintVarName(field.getName(), label.intValue()));
									
									AssignStmt toAdd1 = Jimple.v().newAssignStmt(
											Jimple.v().newStaticFieldRef(taintField.makeRef()), IntConstant.v(0));
									toAdd1.addTag(instrumentationTag);
									toAdd1.addTag(referenceTag);
									List<Unit> unitsToAdd = new LinkedList<Unit>();
									unitsToAdd.add(toAdd1);
									toInstrumentAfter.put(unitsToAdd, s);
								}
							
							}
						}
					}
				}// end while (it.hasNext())

				Set<List<Unit>> keySet = toInstrumentAfter.keySet();
				Iterator<List<Unit>> keyIterator = keySet.iterator();
				while (keyIterator.hasNext()) {

					List<Unit> toAdd = keyIterator.next();
					Stmt s = (Stmt) toInstrumentAfter.get(toAdd);
					if(body.getUnits().getSuccOf(s) instanceof IdentityStmt){
						s = body.getFirstNonIdentityStmt();
						s = (Stmt)body.getUnits().getPredOf(s);
					}					
					body.getUnits().insertAfter(toAdd, s);
				}
				
				Set<List<Unit>> keySet1 = toInstrumentBefore.keySet();
				Iterator<List<Unit>> keyIterator1 = keySet1.iterator();
				while (keyIterator1.hasNext()) {

					List<Unit> toAdd = keyIterator1.next();
					Stmt s = (Stmt) toInstrumentBefore.get(toAdd);

					body.getUnits().insertBefore(toAdd, s);
				}
				
				Set<Stmt> keySet2 = toInstrumentAt.keySet();
				Iterator<Stmt> keyIterator2 = keySet2.iterator();
				while (keyIterator2.hasNext()) {

					Stmt toReplace = keyIterator2.next();
					Stmt s = (Stmt) toInstrumentAt.get(toReplace);

					body.getUnits().insertBefore(toReplace, s);
					body.getUnits().remove(s);
				}
				
				
				
				//add initialization for new added taint variables
				if(method.getTags().contains(isWrapperTag)){
					Vector<Local> toRemove = new Vector<Local>();
					for(Local l : newLocals){
						String taintVarName = l.getName();
						for(Local l1 : localsDefInIdentity){
							String varName = l1.getName();
							
							for(int sc=0;sc<sourceCount;sc++){
								String tVarName = getTaintVarName(varName, sc);
								if(tVarName.equals(taintVarName)){
									toRemove.add(l);
									break;
								}
							}
						}
					}
					newLocals.removeAll(toRemove);
				}
				
				if(!newLocals.isEmpty()){
					List<Unit> unitsToAdd = new LinkedList<Unit>();
					for(Local l : newLocals){
						AssignStmt toAdd1 = Jimple.v().newAssignStmt(l, IntConstant.v(0));
						toAdd1.addTag(instrumentationTag);
						toAdd1.addTag(initialLocalTag);
						unitsToAdd.add(toAdd1);
					}
					
					Unit firstNonIdentityStmt = body.getFirstNonIdentityStmt();
					body.getUnits().insertBefore(unitsToAdd, firstNonIdentityStmt);
					
				}

			}
		}

	}

	
	private void dumpOneMethod(String signature) {

		System.out
				.println("printing out a method with tags after data flow analysis...");

		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}			

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {

				if(!method.getSignature().equals(signature)){
					continue;
				}
				
				if(!method.isConcrete()){
					System.out.println("Method given is not a concrete one!");
					continue;
				}
				
				System.out.println("\n-------------------------");
				System.out.println(soot_class.getName());
				System.out.println("-------------------------");
				
				System.out.println(method.getSignature() + ":");

				JimpleBody body = (JimpleBody) method.retrieveActiveBody();

				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					System.out.println(s + "|tags:" + s.getTags());
				}
			}
		}
	}
	
	private void dumpAllInstructions() {

		System.out
				.println("printing out all the instructions with tags after data flow analysis...");

		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}
			
			System.out.println("\n-------------------------");
			System.out.println(soot_class.getName());
			System.out.println("-------------------------");

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {

				if(!method.isConcrete()){
					continue;
				}
				System.out.println(method.getSignature() + ":");
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				//body.validateLocals();
				System.out.println("Local Table[" + body.getLocalCount() + "]: " + body.getLocals());

				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					System.out.println(s + "|tags:" + s.getTags());
				}
			}
		}
	}
	
	private int countChopLOC(){
		
		int loc = 0;
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {

				if(!method.isConcrete()){
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					
					if(s.getTags().contains(generalTaintTag) || s.getTags().contains(generalExtraDefTag)){
						loc++;
					}
				}
			}
		}
		
		return loc;
	}
	
	private int countLOC() {

		int loc = 0;
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {

				if(!method.isConcrete()){
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					loc++;
				}
			}
		}
		
		return loc;
	}
	
	private void addTaintField(SootField sField, Vector<Integer> labels){
		
		for(Integer label : labels){
			if(sField.getDeclaringClass().declaresFieldByName(getTaintVarName(sField.getName(), label.intValue())) == true){
				if(MyConstants.DEBUG_INFO)
					System.out.println(sField + "is already there");
				continue;
			}
			
			if(!MyConstants.COUNT_LOC){
				System.out.println("adding tainted fields for " + sField);
			}
			
			String fieldName = sField.getName();
			String taintFieldName = getTaintVarName(fieldName, label.intValue());
			SootClass sClass = sField.getDeclaringClass();
			
			SootField taintField = null;
			if(sField.isStatic()){
				taintField = new SootField(taintFieldName, BooleanType.v(), Modifier.PUBLIC | Modifier.STATIC);
			}else{
				taintField = new SootField(taintFieldName, BooleanType.v(), Modifier.PUBLIC);
			}
			
			if(taintField==null){
				System.err.println("Cannot create new taint field.");
				System.exit(-1);
			}
	        sClass.addField(taintField);
	        
	        
	        
	        if(sField.isStatic()){
	        	
	        	//System.out.println("static field:");
	        	
	        	/*
	        	SootMethod clinit = null;
	        	JimpleBody body = null;
	        	if(sClass.declaresMethodByName("<clinit>")){
	        		clinit = sClass.getMethodByName("<clinit>");
	        		body = (JimpleBody)clinit.getActiveBody();
	        		
	        		Chain units = body.getUnits();
	                
	                System.out.println(sClass + "|" + clinit);
	                Stmt first = (Stmt)units.getFirst();
	                
	                Stmt toAdd = Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(
	            			taintField.makeRef()), IntConstant.v(0));
	                units.insertBefore(toAdd, first);
	        		
	        	}else{
	        		SootMethod clinitMethod = new SootMethod("<clinit>",
	        				new ArrayList(), VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);
	                sClass.addMethod(clinitMethod);
	                
	                
	                   
	                body = Jimple.v().newBody(clinitMethod);
	                clinitMethod.setActiveBody(body);
	                
	                Chain units = body.getUnits();
	                Stmt toAdd = Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(
	            			taintField.makeRef()), IntConstant.v(0));
	                
	                units.add(toAdd);
	                
	        	}
	            */
	            
	            
	            
	        	
	        	/*
	        	Stmt toAdd = Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(
	        			taintField.makeRef()), IntConstant.v(0));
	        	units.insertBefore(toAdd, first);
	        	*/
	        	
	        }else{
	        	
	        	//System.out.println("non static field:");
	        	
	        	List<SootMethod> methods = sClass.getMethods();
	        	for(SootMethod m : methods){
	        		if(m.getName().equals("<init>")){
	        			
	        			//SootMethod init = sClass.getMethodByName("<init>");
	                    SootMethod init = m;
	                    
	                    JimpleBody body = (JimpleBody)init.getActiveBody();
	                    Chain units = body.getUnits();
	                                
	                    //System.out.println(sClass + "|" + init);
	                    Stmt first = body.getFirstNonIdentityStmt();
	                	
	                	
	                	Value base = null;
	                    
	                    Iterator iter = units.iterator();
	                    while(iter.hasNext()){
	                    	Stmt s = (Stmt)iter.next();
	                    	
	                    	//System.out.println(s);
	                    	
	                    	if(s instanceof IdentityStmt){
	                    		Value rhs = ((IdentityStmt) s).getRightOp();
	                    		if(rhs instanceof ThisRef){
	                    			base = ((IdentityStmt) s).getLeftOp();        			
	                    		}
	                    	}
	                    }
	                    
	                    if(base!=null){	        	
	        	        	Stmt toAdd = Jimple.v().newAssignStmt(Jimple.v().newInstanceFieldRef(
	        	        			base, taintField.makeRef()), IntConstant.v(0));
	        	        	units.insertBefore(toAdd, first);
	        	        	//units.add(toAdd);
	                    }
	        			
	        			
	        		}
	        	}
	        	
	        	
	        }
		}
        
        
	}
	
	private void doControlFlowAnalysis(){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();

			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);
				System.out.println("BEGIN [CFG] - " + method + "\n");
				System.out.println(eug.toString());
				System.out.println("END [CFG]");
			}
		}
	}

	private void doDataFlowAnalysis() {
		
		Set<String> sourceKey = CallGraphExample.sourcesLocationMap.keySet();
		Iterator<String> sourceIter = sourceKey.iterator();
		while(sourceIter.hasNext()){
			
			String leakSource = sourceIter.next();
			LinkedHashMap<String, String> entryPointsString = CallGraphExample.sourcesLocationMap.get(leakSource);
			
			TaintTag taintTag = taintTagMap.get(leakSource);
			TaintTag extraDefTag = extraDefTagMap.get(leakSource);

			if(!MyConstants.COUNT_LOC){
				System.out.println("dataflow analysis");

				System.out.println("loading function summaries");
			}
			AndroidFunctionSummary.buildFunctionSummary();

			List<SootMethod> entryPoints = new ArrayList<SootMethod>();
			//List<SootField> instanceFields = new ArrayList<SootField>();
			//List<SootField> staticFields = new ArrayList<SootField>();
			
			LinkedHashMap<SootField, Vector<Integer>> instanceFieldMap = new LinkedHashMap<SootField, Vector<Integer>>();
			LinkedHashMap<SootField, Vector<Integer>> staticFieldMap = new LinkedHashMap<SootField, Vector<Integer>>();

			List<SootField> taintedStaticFields = new ArrayList<SootField>();

			//set entry points for dataflow
			Set<String> keySet = entryPointsString.keySet();
			Iterator<String> keyIterator = keySet.iterator();
			while (keyIterator.hasNext()) {
				String mClass = keyIterator.next();
				String method = entryPointsString.get(mClass);

				mClass = mClass.substring(0, mClass.indexOf("|"));			
				SootClass entryClass = Scene.v().loadClassAndSupport(mClass);

				if(!MyConstants.COUNT_LOC){
					System.out.println("loading method " + method + " from " + entryClass);
				}
				SootMethod entryMethod = entryClass.getMethod(method);			
				entryMethod.setDeclaringClass(entryClass);
				entryPoints.add(entryMethod);
			}

			Queue<SootMethod> worklist = new LinkedList<SootMethod>();
			List<SootMethod> fullWorklist = new LinkedList<SootMethod>();

			worklist.addAll(entryPoints);
			fullWorklist.addAll(entryPoints);

			//If dataflow reaches a "return", we put caller name into sourceMethods. Further we track the dataflow in caller, starting from such function call.
			List<SootMethod> sourceMethods = new ArrayList<SootMethod>();

			//dataflow analysis phase one
			while(!worklist.isEmpty()){

				SootMethod sMethod = worklist.remove();			

				//setup equivalent table
				boolean hasEquivTable = false;
				LinkedHashMap<Stmt, List<Stmt>> equivTable = null;

				if(methodToEquiv.containsKey(sMethod)){
					hasEquivTable = true;
					equivTable = methodToEquiv.get(sMethod);
				}

				if(!MyConstants.COUNT_LOC){
					System.out.println();
					System.out.println("analyzing method:" + sMethod.getSignature());
				}
				// System.out.println(sMethod.getSource());
				// System.out.println(sMethod.getBytecodeParms());

				JimpleBody body = (JimpleBody) sMethod.retrieveActiveBody();
				ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);

				/*
				if(CFG==true){
					System.out.println("BEGIN [CFG] - " + sMethod + "\n");
					System.out.println(eug.toString());
					System.out.println("END [CFG]");
				}
				 */

				MyReachingDefinition mrd = new MyReachingDefinition(eug);

				/*
				if(REACH_DEF==true){
					System.out.println("BEGIN [Reaching Definition Analysis] - " + sMethod + "\n");
					dumpReachingDefs(mrd, body);
					System.out.println("END [Reaching Definition Analysis]");
				}
				 */

				//Stack<Stmt> defsStack = new Stack<Stmt>();
				//Vector<Stmt> taintedRefDefs = new Vector<Stmt>();
				Stack<DefWithScope> defsStack = new Stack<DefWithScope>();
				Vector<DefWithScope> taintedRefDefs = new Vector<DefWithScope>();

				//Vector<Stmt> defs = new Vector<Stmt>();
				//Vector<DefWithScope> defs = new Vector<DefWithScope>();

				//hashmap to record all analyzed definitions. key is definition, object is the scope(s).
				LinkedHashMap<Stmt, Vector<Stmt>> defs = new LinkedHashMap<Stmt, Vector<Stmt>>();

				Stmt source = null;

				//identify "sources" in current method
				{
					Iterator it = body.getUnits().iterator();
					while (it.hasNext()) {
						Stmt s = (Stmt) it.next();
						
						if(s instanceof DefinitionStmt){
							Value rhs = ((DefinitionStmt) s).getRightOp();
							if(rhs instanceof InstanceFieldRef){
								if(((InstanceFieldRef) rhs).getField().getSignature().equals(leakSource)){

									DefWithScope sWS = new DefWithScope(s);
									if(!defs.containsKey(s)){
										defs.put(s, new Vector<Stmt>());
										defsStack.push(sWS);
										if(MyConstants.DEBUG_INFO)
											System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
										source = s;
									}
								}
							}
						}

						Iterator useIt = s.getUseBoxes().iterator();
						while (useIt.hasNext()) {
							ValueBox vBox = (ValueBox) useIt.next();
							if (vBox.getValue() instanceof InvokeExpr) {
								if (((InvokeExpr) vBox.getValue()).getMethod().getSignature().equals(leakSource)
										|| sourceMethods.contains(((InvokeExpr) vBox.getValue()).getMethod())) {

									DefWithScope sWS = new DefWithScope(s);
									if(!defs.containsKey(s)){
										defs.put(s, new Vector<Stmt>());
										defsStack.push(sWS);
										if(MyConstants.DEBUG_INFO)
											System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
										source = s;
									}

								}
							}
						}
					}
				}

				while(!defsStack.isEmpty()){

					DefWithScope defWS = defsStack.pop();
					System.out.println("POP from def stack: " + defWS.dump());

					if(hasEquivTable){

						if(MyConstants.DEBUG_INFO)
							System.out.println(sMethod + "has equivTable: " + equivTable);
						if(equivTable.containsKey(defWS.getDef())){

							List<Stmt> equivs = equivTable.get(defWS.getDef());

							if(MyConstants.DEBUG_INFO)
								System.out.println("EQUIV found: " + defWS.getDef() + "|" + equivs);

							for(Stmt equiv : equivs){
								DefWithScope equivWS = new DefWithScope(equiv);
								if (!defs.containsKey(equiv)) {
									defs.put(equiv, new Vector<Stmt>());
									defsStack.push(equivWS);
									if(MyConstants.DEBUG_INFO)
										System.out.println("def stack doesn't contain " + equivWS.dump() + ". Push it.");
								}
							}
						}
					}

					//def-use analysis
					Iterator it = body.getUnits().iterator();
					while (it.hasNext()) {
						Stmt s = (Stmt) it.next();

						if(defWS.getScopeBegin()!=null){
							if(!isInScope(eug, s, defWS.getScopeBegin())){
								if(MyConstants.DEBUG_INFO){
									System.out.println(s + " is NOT in the scope: " + defWS.getScopeBegin());
								}
								continue;
							}
						}

						Iterator usesIt = s.getUseBoxes().iterator();
						while (usesIt.hasNext()) {
							ValueBox vbox = (ValueBox) usesIt.next();
							if (vbox.getValue() instanceof Local) {
								Local l = (Local) vbox.getValue();
								//System.out.println("l: " + l);

								Iterator rDefsIt = mrd.getDefsOfAt(l, s).iterator();
								while (rDefsIt.hasNext()) {
									Stmt next = (Stmt) rDefsIt.next();
									//System.out.println("next: " + next);
									//System.out.println("defs: " + defs);

									//if (defs.contains(next)) {
									if(next == defWS.getDef()){

										if (s instanceof InvokeStmt) {

											//to pass the index of tainted parameter. in fact one taint a time.
											Vector<Integer> taintVector = new Vector<Integer>();

											Iterator defIt2 = next.getDefBoxes().iterator();
											while (defIt2.hasNext()) {
												ValueBox vbox2 = (ValueBox) defIt2.next();
												if (vbox2.getValue() instanceof Local) {
													// System.out.println(vbox2.getValue());
													InvokeExpr invokeEx = s.getInvokeExpr();
													int argCount = invokeEx.getArgCount();
													for (int i = 0; i < argCount; i++) {
														if (invokeEx.getArg(i) == vbox2.getValue()) {
															taintVector.add(new Integer(i));
														}												
													}

													//for instance invoke, consider this reference too.
													if(invokeEx instanceof InstanceInvokeExpr){
														if(((InstanceInvokeExpr) invokeEx).getBase() == vbox2.getValue()){

															//special invoke doesn't count
															if(invokeEx instanceof SpecialInvokeExpr){
																if(next instanceof DefinitionStmt){
																	Value rhs = ((DefinitionStmt) next).getRightOp();
																	if(rhs instanceof NewExpr){
																		continue;
																	}
																}
															}

															taintVector.add(new Integer(MyConstants.thisObject));
														}
													}
												}
											}

											if(taintVector.isEmpty()){

												if(MyConstants.DEBUG_INFO)
													System.out.println("No parameters: " + s);
												continue;
											}

											if(sinks.contains(s.getInvokeExpr().getMethod().getSignature())){	

												DefWithScope sWS = new DefWithScope(s);
												if (!defs.containsKey(s)) {
													defs.put(s, new Vector<Stmt>());
												}

												if(taintVector.contains(new Integer(0))
														|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}else if(taintVector.contains(new Integer(3))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}else if(taintVector.contains(new Integer(2))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}else if(taintVector.contains(new Integer(2))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}else if(taintVector.contains(new Integer(2))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}
												else{

													if(MyConstants.DEBUG_INFO)
														System.out.println(s.getInvokeExpr().getMethod()
																+ " found, but tainted index is " + taintVector);
												}

											}

											Iterator targets = new Targets(this.cg.edgesOutOf(s));

											if(!targets.hasNext()){

												if(MyConstants.DEBUG_INFO)
													System.out.println(s + " does NOT have a target. add a DEFAULT one");
												//System.out.println("BUT it invokes sth. : " + s.getInvokeExpr().getMethod());
												List<SootMethod> defaultTargets = new ArrayList<SootMethod>();
												defaultTargets.add(s.getInvokeExpr().getMethod());
												targets = defaultTargets.iterator();
											}

											while (targets.hasNext()) {
												SootMethod target = (SootMethod) targets.next();

												//if(MyConstants.DEBUG_INFO)
												if(!MyConstants.COUNT_LOC){
													if(DATAFLOW==true)
														System.out.println("call target is " + target);
												}

												// check for sink
												if(sinks.contains(target.getSignature())){
													if(taintVector.contains(new Integer(0))
															|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
														//if(!MyConstants.COUNT_LOC){
														System.out.println("SINK found in " + sMethod + " : " + target);
														//}
														continue;
													}else if(taintVector.contains(new Integer(3))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}
													else{
														if(MyConstants.DEBUG_INFO)
															System.out.println(target + " found, but tainted index is " + taintVector);
													}

													//DefWithScope sWS = new DefWithScope(s);
													if (!defs.containsKey(s)) {
														defs.put(s, new Vector<Stmt>());
													}
												} else {

													boolean noNewTaint = true;
													if(!propagationHistory.containsKey(sMethod.getSignature()+"|"+s.toString())){
														noNewTaint = false;
														List<Integer> sources = new ArrayList<Integer>();
														sources.addAll(taintVector);
														propagationHistory.put(sMethod.getSignature()+"|"+s.toString(), sources);
													}else{
														List<Integer> sources = propagationHistory.get(sMethod.getSignature()+"|"+s.toString());

														for(Integer taint : taintVector){
															if(!sources.contains(taint)){
																noNewTaint = false;
																sources.add(taint);
															}
														}

													}

													DefWithScope sWS = new DefWithScope(s);
													if (!defs.containsKey(s)) {
														defs.put(s, new Vector<Stmt>());
														defsStack.push(sWS);
														if(MyConstants.DEBUG_INFO)
															System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
													}else{
														if(noNewTaint){
															break;
														}
													}


													if(!MyConstants.COUNT_LOC){
														if(DATAFLOW==true){
															System.out.println("PROPAGATING from METHOD: " + sMethod);
															System.out.println("PROPAGATING from STATEMENT: " + s);
														}
													}

													CallGraphTransformer.taintedFieldsInCaller.addAll(taintedStaticFields);


													Vector<Integer> tainted = propagate(target, taintVector, leakSource);
													for(SootField sf : CallGraphTransformer.taintedFieldsInCallee){
														if(!taintedStaticFields.contains(sf)){
															taintedStaticFields.add(sf);
														}
													}
													CallGraphTransformer.taintedFieldsInCallee.clear();

													//if(MyConstants.DEBUG_INFO)
													if(!MyConstants.COUNT_LOC){
														if(DATAFLOW==true)
															System.out.println(s + " |taint:" + taintVector + "| PROPAGATION result: " + tainted);
													}
													if ((tainted!=null) && (!tainted.isEmpty())) {

														for(Integer i : tainted){
															int index = i.intValue();

															if(index == MyConstants.returnValue){
																if(s instanceof DefinitionStmt){
																	Value taintedRet = ((DefinitionStmt) s).getLeftOp();
																	if(taintedRet instanceof Local){

																		if (!defs.containsKey(s)) {

																			if(MyConstants.DEBUG_INFO)
																				System.out.println("adding def of return value:" + s);

																			defs.put(s, new Vector<Stmt>());
																			defsStack.push(sWS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
																		}
																	}
																}

															}else if(index == MyConstants.thisObject){
																if(s.getInvokeExpr() instanceof InstanceInvokeExpr){
																	Value taintedThisRef = ((InstanceInvokeExpr)s.getInvokeExpr()).getBase();

																	boolean hasDef = false;
																	Stmt def0 = s;
																	if(taintedThisRef instanceof Local){
																		List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedThisRef, def0);
																		if(defs0.size()==1){
																			def0 = (Stmt)defs0.get(0);
																			hasDef = true;

																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																		}else{
																			//not very good solution :(
																			for(Unit defn : defs0){																			
																				DefWithScope defnWS = new DefWithScope((Stmt)defn, s);
																				if(!defs.containsKey(defn)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put((Stmt)defn, scopes);
																					defsStack.push(defnWS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																				}else if(!(defs.get(defn).contains(s))){
																					defs.get(defn).add(s);
																					defsStack.push(defnWS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																				}
																			}
																		}
																	}

																	//iteratively find the first definition of an object
																	//e.g., a = new object;
																	//		b = a.field;
																	//		c = b.field;
																	//		if c is tainted, a, b both are tainted and require tracking.
																	//here, i only consider linear definition, meaning i don't consider branch while tracing back.
																	while(hasDef){																	

																		if(def0 instanceof DefinitionStmt){
																			Value lhs = ((DefinitionStmt) def0).getLeftOp();
																			Value rhs = ((DefinitionStmt) def0).getRightOp();

																			if(rhs instanceof InstanceFieldRef){

																				if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																					if(!taintedStaticFields.contains(def0)){
																						taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																					}
																				}
																				//System.out.print("instance field expression: " + def0);
																				Value base = ((InstanceFieldRef) rhs).getBase();
																				if(base instanceof Local){
																					List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																					if(defs0.size()==1){
																						def0 = (Stmt)defs0.get(0);

																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																					}else{
																						hasDef = false;
																					}

																				}else{
																					hasDef = false;
																				}


																			}else if(rhs instanceof ArrayRef){
																				Value base = ((ArrayRef) rhs).getBase();
																				if(base instanceof Local){
																					List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																					if(defs0.size()==1){
																						def0 = (Stmt)defs0.get(0);

																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																					}else{
																						hasDef = false;
																					}

																				}else{
																					hasDef = false;
																				}
																			}

																			else if(rhs instanceof StaticFieldRef){

																				if(!taintedStaticFields.contains(def0)){
																					taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																				}

																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}


																			else if(rhs instanceof NewExpr){																			
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof NewArrayExpr){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof ThisRef){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof ParameterRef){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof InstanceInvokeExpr){
																				if(((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																						"<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>")
																						|| ((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																								"<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>")){
																					Value base = ((InstanceInvokeExpr) rhs).getBase();
																					if(base instanceof Local){
																						List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																						if(defs0.size()==1){
																							def0 = (Stmt)defs0.get(0);

																							DefWithScope def0WS = new DefWithScope(def0, s);
																							if(!defs.containsKey(def0)){
																								Vector<Stmt> scopes = new Vector<Stmt>();
																								scopes.add(s);
																								defs.put(def0, scopes);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}else if(!(defs.get(def0).contains(s))){
																								defs.get(def0).add(s);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}
																						}else{
																							hasDef = false;
																						}
																					}else{
																						hasDef = false;
																					}
																				}else{
																					hasDef = false;
																				}
																			}

																			else{
																				hasDef = false;
																			}

																		}else{
																			hasDef = false;
																		}
																	}//end while(hasDef){
																	/*
																if(taintedThisRef instanceof Local){
																	List<Unit> thisRefDefs = mrd.getDefsOfAt((Local)taintedThisRef, s);
																	for(Unit thisRefDef : thisRefDefs){

																		if((!taintedRefDefs.contains((Stmt)thisRefDef))
																				&& (!defs.contains((Stmt)thisRefDef))){
																			taintedRefDefs.add((Stmt)thisRefDef);
																			//deltaTaintedRefDefs.add((Stmt)thisRefDef);
																			defsStack.push((Stmt)thisRefDef);
																		}
																	}
																}	
																	 */														
																}														 

															}else if(index >= 0){

																Value taintedArg = s.getInvokeExpr().getArg(index);

																boolean hasDef = false;
																Stmt def0 = s;
																if(taintedArg instanceof Local && taintedArg.getType() instanceof RefLikeType){
																	List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedArg, def0);
																	if(defs0.size()==1){
																		def0 = (Stmt)defs0.get(0);
																		hasDef = true;

																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																	}
																}

																while(hasDef){
																	//System.out.println("def0:" + def0);


																	if(def0 instanceof DefinitionStmt){
																		Value lhs = ((DefinitionStmt) def0).getLeftOp();
																		Value rhs = ((DefinitionStmt) def0).getRightOp();

																		if(rhs instanceof InstanceFieldRef){

																			if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																				if(!taintedStaticFields.contains(def0)){
																					taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																				}
																			}

																			//System.out.print("instance field expression: " + def0);
																			Value base = ((InstanceFieldRef) rhs).getBase();
																			if(base instanceof Local){
																				List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																				if(defs0.size()==1){
																					def0 = (Stmt)defs0.get(0);

																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																				}else{
																					hasDef = false;
																				}

																			}else{
																				hasDef = false;
																			}


																		}else if(rhs instanceof ArrayRef){
																			Value base = ((ArrayRef) rhs).getBase();
																			if(base instanceof Local){
																				List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																				if(defs0.size()==1){
																					def0 = (Stmt)defs0.get(0);

																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																				}else{
																					hasDef = false;
																				}

																			}else{
																				hasDef = false;
																			}
																		}

																		else if(rhs instanceof StaticFieldRef){

																			if(!taintedStaticFields.contains(def0)){
																				taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																			}

																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}

																			hasDef = false;
																		}


																		else if(rhs instanceof NewExpr){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}else if(rhs instanceof NewArrayExpr){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}else if(rhs instanceof ThisRef){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}else if(rhs instanceof ParameterRef){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}

																		else{
																			hasDef = false;
																		}

																	}else{
																		hasDef = false;
																	}
																}//end while(hasDef){
																/*
															if(taintedArg instanceof Local){
																Type type = taintedArg.getType();
																if(type instanceof RefLikeType){
																	List<Unit> argRefDefs = mrd.getDefsOfAt((Local)taintedArg, s);
																	for(Unit argRefDef : argRefDefs){
																		if((!taintedRefDefs.contains((Stmt)argRefDef))
																				&& (!defs.contains((Stmt)argRefDef))){
																			taintedRefDefs.add((Stmt)argRefDef);
																			//deltaTaintedRefDefs.add((Stmt)argRefDef);
																			defsStack.push((Stmt)argRefDef);
																		}
																	}
																}
															}
																 */
															}
														}
													}
												}
											}

											// invokes.add(s);

										} else {

											boolean isInvoke = false;

											Iterator iUse = s.getUseBoxes().iterator();
											while (iUse.hasNext()) {
												ValueBox vB = (ValueBox) iUse.next();
												if (vB.getValue() instanceof InvokeExpr) {
													isInvoke = true;
												}
											}

											if (isInvoke) {
												Vector<Integer> taintVector = new Vector<Integer>();

												Iterator defIt2 = next.getDefBoxes().iterator();
												while (defIt2.hasNext()) {
													ValueBox vbox2 = (ValueBox) defIt2.next();
													if (vbox2.getValue() instanceof Local) {

														InvokeExpr invokeEx = s.getInvokeExpr();
														int argCount = invokeEx.getArgCount();

														for (int i = 0; i < argCount; i++) {
															if (invokeEx.getArg(i) == vbox2.getValue()) {
																taintVector.add(new Integer(i));
															}
														}

														if(invokeEx instanceof InstanceInvokeExpr){
															if(((InstanceInvokeExpr) invokeEx).getBase() == vbox2.getValue()){

																if(invokeEx instanceof SpecialInvokeExpr){
																	if(next instanceof DefinitionStmt){
																		Value rhs = ((DefinitionStmt) next).getRightOp();
																		if(rhs instanceof NewExpr){
																			continue;
																		}
																	}
																}

																taintVector.add(new Integer(MyConstants.thisObject));
															}
														}

													}
												}

												if(taintVector.isEmpty()){
													if(MyConstants.DEBUG_INFO)
														System.out.println("No parameters: " + s);
													continue;												
												}

												if(sinks.contains(s.getInvokeExpr().getMethod().getSignature())){

													//DefWithScope sWS = new DefWithScope(s);
													if (!defs.containsKey(s)) {
														defs.put(s, new Vector<Stmt>());
													}

													if(taintVector.contains(new Integer(0))
															|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
														//if(!MyConstants.COUNT_LOC){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());
														//}
														continue;
													}else if(taintVector.contains(new Integer(3))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}
													else{
														if(MyConstants.DEBUG_INFO)
															System.out.println(s.getInvokeExpr().getMethod() 
																	+ " found, but tainted index is " + taintVector);
													}

												}

												Iterator targets = new Targets(this.cg.edgesOutOf(s));

												if(!targets.hasNext()){if(MyConstants.DEBUG_INFO)
													System.out.println(s + " does NOT have a target. add a DEFAULT one");
												List<SootMethod> defaultTargets = new ArrayList<SootMethod>();
												defaultTargets.add(s.getInvokeExpr().getMethod());
												targets = defaultTargets.iterator();
												}

												while (targets.hasNext()) {
													SootMethod target = (SootMethod) targets.next();

													//if(MyConstants.DEBUG_INFO)
													if(!MyConstants.COUNT_LOC){
														if(DATAFLOW==true)
															System.out.println("call target is " + target);
													}

													// check for sink
													if(sinks.contains(target.getSignature())){
														if(taintVector.contains(new Integer(0))
																|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
															//if(!MyConstants.COUNT_LOC){
															System.out.println("SINK found in " + sMethod + " : " + target);
															//}
															continue;
														}else if(taintVector.contains(new Integer(3))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}
														else{
															if(MyConstants.DEBUG_INFO)
																System.out.println(target + " found, but tainted index is " + taintVector);
														}

														//DefWithScope sWS = new DefWithScope(s);
														if (!defs.containsKey(s)) {
															defs.put(s, new Vector<Stmt>());
														}
													} else {


														boolean noNewTaint = true;
														if(!propagationHistory.containsKey(sMethod.getSignature()+"|"+s.toString())){														
															noNewTaint = false;
															List<Integer> sources = new ArrayList<Integer>();
															sources.addAll(taintVector);
															propagationHistory.put(sMethod.getSignature()+"|"+s.toString(), sources);
														}else{
															List<Integer> sources = propagationHistory.get(sMethod.getSignature()+"|"+s.toString());

															for(Integer taint : taintVector){
																if(!sources.contains(taint)){
																	noNewTaint = false;
																	sources.add(taint);
																}
															}														
														}

														DefWithScope sWS = new DefWithScope(s);
														if (!defs.containsKey(s)) {
															defs.put(s, new Vector<Stmt>());
															defsStack.push(sWS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
														}else{
															if(noNewTaint){
																break;
															}
														}	

														if(!MyConstants.COUNT_LOC){
															if(DATAFLOW==true){
																System.out.println("PROPAGATING from METHOD: " + sMethod);
																System.out.println("PROPAGATING from STATEMENT: " + s);
															}
														}
														CallGraphTransformer.taintedFieldsInCaller.addAll(taintedStaticFields);
														Vector<Integer> tainted = propagate(target, taintVector, leakSource);
														for(SootField sf : CallGraphTransformer.taintedFieldsInCallee){
															if(!taintedStaticFields.contains(sf)){
																taintedStaticFields.add(sf);
															}
														}
														CallGraphTransformer.taintedFieldsInCallee.clear();

														//if(MyConstants.DEBUG_INFO)
														if(!MyConstants.COUNT_LOC){
															if(DATAFLOW==true)
																System.out.println(s + " |taint:" + taintVector + "| PROPAGATION result: " + tainted);
														}
														if ((tainted!=null) && (!tainted.isEmpty())) {

															for(Integer i : tainted){
																int index = i.intValue();

																if(index == MyConstants.returnValue){
																	if(s instanceof DefinitionStmt){
																		Value taintedRet = ((DefinitionStmt) s).getLeftOp();
																		if(taintedRet instanceof Local){
																			if (!defs.containsKey(s)) {

																				if(MyConstants.DEBUG_INFO)
																					System.out.println("adding def of return value:" + s);

																				defs.put(s, new Vector<Stmt>());
																				//delta.add(s);
																				//System.out.println("def: " + s + " PROPAGATES");
																				defsStack.push(sWS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
																			}
																		}
																	}

																}else if(index == MyConstants.thisObject){
																	if(s.getInvokeExpr() instanceof InstanceInvokeExpr){
																		Value taintedThisRef = ((InstanceInvokeExpr)s.getInvokeExpr()).getBase();

																		boolean hasDef = false;
																		Stmt def0 = s;
																		if(taintedThisRef instanceof Local){
																			List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedThisRef, def0);
																			if(defs0.size()==1){
																				def0 = (Stmt)defs0.get(0);
																				hasDef = true;

																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																			}else{
																				//not very good solution :(
																				for(Unit defn : defs0){

																					DefWithScope defnWS = new DefWithScope((Stmt)defn, s);
																					if(!defs.containsKey(defn)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put((Stmt)defn, scopes);
																						defsStack.push(defnWS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																					}else if(!(defs.get(defn).contains(s))){
																						defs.get(defn).add(s);
																						defsStack.push(defnWS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																					}
																				}
																			}
																		}

																		while(hasDef){

																			if(def0 instanceof DefinitionStmt){
																				Value lhs = ((DefinitionStmt) def0).getLeftOp();
																				Value rhs = ((DefinitionStmt) def0).getRightOp();

																				if(rhs instanceof InstanceFieldRef){

																					if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																						if(!taintedStaticFields.contains(def0)){
																							taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																						}
																					}

																					Value base = ((InstanceFieldRef) rhs).getBase();
																					if(base instanceof Local){
																						List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																						if(defs0.size()==1){
																							def0 = (Stmt)defs0.get(0);

																							DefWithScope def0WS = new DefWithScope(def0, s);
																							if(!defs.containsKey(def0)){
																								Vector<Stmt> scopes = new Vector<Stmt>();
																								scopes.add(s);
																								defs.put(def0, scopes);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}else if(!(defs.get(def0).contains(s))){
																								defs.get(def0).add(s);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}
																						}else{
																							hasDef = false;
																						}

																					}else{
																						hasDef = false;
																					}


																				}else if(rhs instanceof ArrayRef){
																					Value base = ((ArrayRef) rhs).getBase();
																					if(base instanceof Local){
																						List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																						if(defs0.size()==1){
																							def0 = (Stmt)defs0.get(0);

																							DefWithScope def0WS = new DefWithScope(def0, s);
																							if(!defs.containsKey(def0)){
																								Vector<Stmt> scopes = new Vector<Stmt>();
																								scopes.add(s);
																								defs.put(def0, scopes);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}else if(!(defs.get(def0).contains(s))){
																								defs.get(def0).add(s);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}
																						}else{
																							hasDef = false;
																						}

																					}else{
																						hasDef = false;
																					}
																				}
																				else if(rhs instanceof StaticFieldRef){

																					if(!taintedStaticFields.contains(def0)){
																						taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																					}

																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}


																				else if(rhs instanceof NewExpr){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof NewArrayExpr){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof ThisRef){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof ParameterRef){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof InstanceInvokeExpr){
																					if(((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																							"<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>")
																							|| ((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																									"<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>")){
																						Value base = ((InstanceInvokeExpr) rhs).getBase();
																						if(base instanceof Local){
																							List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																							if(defs0.size()==1){
																								def0 = (Stmt)defs0.get(0);

																								DefWithScope def0WS = new DefWithScope(def0, s);
																								if(!defs.containsKey(def0)){
																									Vector<Stmt> scopes = new Vector<Stmt>();
																									scopes.add(s);
																									defs.put(def0, scopes);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}else if(!(defs.get(def0).contains(s))){
																									defs.get(def0).add(s);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}
																							}else{
																								hasDef = false;
																							}
																						}else{
																							hasDef = false;
																						}
																					}else{
																						hasDef = false;
																					}
																				}

																				else{
																					hasDef = false;
																				}

																			}else{
																				hasDef = false;
																			}
																		}//end while(hasDef){
																		/*
																	if(taintedThisRef instanceof Local){
																		List<Unit> thisRefDefs = mrd.getDefsOfAt((Local)taintedThisRef, s);
																		for(Unit thisRefDef : thisRefDefs){
																			if((!taintedRefDefs.contains((Stmt)thisRefDef))
																					&& (!defs.contains((Stmt)thisRefDef))){
																				taintedRefDefs.add((Stmt)thisRefDef);
																				//deltaTaintedRefDefs.add((Stmt)thisRefDef);
																				defsStack.push((Stmt)thisRefDef);
																			}
																		}
																	}	
																		 */														
																	}														 

																}else if(index >= 0){

																	Value taintedArg = s.getInvokeExpr().getArg(index);

																	boolean hasDef = false;
																	Stmt def0 = s;
																	if(taintedArg instanceof Local && taintedArg.getType() instanceof RefLikeType){
																		List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedArg, def0);
																		if(defs0.size()==1){
																			def0 = (Stmt)defs0.get(0);
																			hasDef = true;

																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																		}
																	}

																	while(hasDef){

																		if(def0 instanceof DefinitionStmt){
																			Value lhs = ((DefinitionStmt) def0).getLeftOp();
																			Value rhs = ((DefinitionStmt) def0).getRightOp();

																			if(rhs instanceof InstanceFieldRef){

																				if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																					if(!taintedStaticFields.contains(def0)){
																						taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																					}
																				}

																				//System.out.print("instance field expression: " + def0);
																				Value base = ((InstanceFieldRef) rhs).getBase();
																				if(base instanceof Local){
																					List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																					if(defs0.size()==1){
																						def0 = (Stmt)defs0.get(0);

																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																					}else{
																						hasDef = false;
																					}

																				}else{
																					hasDef = false;
																				}


																			}else if(rhs instanceof ArrayRef){
																				Value base = ((ArrayRef) rhs).getBase();
																				if(base instanceof Local){
																					List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																					if(defs0.size()==1){
																						def0 = (Stmt)defs0.get(0);

																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																					}else{
																						hasDef = false;
																					}

																				}else{
																					hasDef = false;
																				}
																			}
																			else if(rhs instanceof StaticFieldRef){

																				if(!taintedStaticFields.contains(def0)){
																					taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																				}

																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}

																			else if(rhs instanceof NewExpr){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof NewArrayExpr){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof ThisRef){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof ParameterRef){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}

																			else{
																				hasDef = false;
																			}

																		}else{
																			hasDef = false;
																		}
																	}//end while(hasDef){
																	/*
																if(taintedArg instanceof Local){
																	Type type = taintedArg.getType();
																	if(type instanceof RefLikeType){
																		List<Unit> argRefDefs = mrd.getDefsOfAt((Local)taintedArg, s);
																		for(Unit argRefDef : argRefDefs){
																			if((!taintedRefDefs.contains((Stmt)argRefDef))
																					&& (!defs.contains((Stmt)argRefDef))){
																				taintedRefDefs.add((Stmt)argRefDef);
																				//deltaTaintedRefDefs.add((Stmt)argRefDef);
																				defsStack.push((Stmt)argRefDef);
																			}
																		}
																	}
																}
																	 */
																}
															}
														}
													}
												}
												// invokes.add(s);
											} else if(s instanceof ReturnStmt){

												if(!MyConstants.COUNT_LOC){
													if(DATAFLOW==true)
														System.out.println("returning to caller...");
												}
												if(MyConstants.DEBUG_INFO)
													System.out.println("return to caller from: " + sMethod + " | " + s);

												DefWithScope sWS = new DefWithScope(s);
												if (!defs.containsKey(s)) {
													defs.put(s, new Vector<Stmt>());
													defsStack.push(sWS);
													if(MyConstants.DEBUG_INFO)
														System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
												}

												Chain<SootClass> classes = Scene.v().getClasses();
												Iterator<SootClass> classes_iter = classes.iterator();
												while (classes_iter.hasNext()) {
													SootClass soot_class = classes_iter.next();

													if (soot_class.isApplicationClass() == false) {
														continue;
													}

													if(soot_class.isPhantom()){
														continue;
													}

													List<SootMethod> methods = soot_class.getMethods();
													for (SootMethod method : methods) {
														Iterator targets = new Targets(cg.edgesOutOf(method));													

														while (targets.hasNext()) {
															SootMethod target = (SootMethod) targets.next();
															//System.out.println(method + " may call " + target);
															if(target.equals(sMethod)){
																if(!fullWorklist.contains(method)){
																	worklist.add(method);
																	fullWorklist.add(method);
																	if(!sourceMethods.contains(sMethod)){
																		sourceMethods.add(sMethod);
																	}																
																}
															}														
														}
													}
												}
											}

											//pure definiton statement:
											else {
												//use of l appears on the left of assignment
												if(s instanceof DefinitionStmt){
													Value lhs = ((DefinitionStmt) s).getLeftOp();
													if(lhs instanceof ArrayRef){
														Value base = ((ArrayRef) lhs).getBase();
														if(base == l){
															continue;
														}
													}else if(lhs instanceof InstanceFieldRef){
														Value base = ((InstanceFieldRef) lhs).getBase();
														if(base == l){
															continue;
														}
													}
												}

												DefWithScope sWS = new DefWithScope(s);											
												if (!defs.containsKey(s)) {
													defs.put(s, new Vector<Stmt>());
													defsStack.push(sWS);
													if(MyConstants.DEBUG_INFO)
														System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");

													if(s instanceof DefinitionStmt){
														Value lhs = ((DefinitionStmt) s).getLeftOp();

														if(lhs instanceof StaticFieldRef){
															if(!taintedStaticFields.contains(s)){
																taintedStaticFields.add(((StaticFieldRef)lhs).getField());
															}
														}
													}												

													boolean hasDef = false;
													Stmt def0 = s;


													if(def0 instanceof DefinitionStmt){
														Value lhs = ((DefinitionStmt) def0).getLeftOp();
														//Value rhs = ((DefinitionStmt) s).getRightOp();

														/*
													if(lhs instanceof Local){
														List<Unit> defs0 = mrd.getDefsOfAt((Local)lhs, def0);
														if(defs0.size()==1){
															Stmt def1 = (Stmt)defs0.get(0);
															if(def1 instanceof DefinitionStmt){
																Value def1rhs = ((DefinitionStmt) def1).getRightOp();
																if(def1rhs instanceof InstanceFieldRef){

																	hasDef = true;

																	if(!defs.contains(def0)){
																		defs.add(def0);
																		delta.add(def0);
																	}

																	if(!defs.contains(def1)){
																		defs.add(def1);
																		delta.add(def1);
																	}

																	def0 = def1;
																}
															}
														}
													}*/

														if(lhs instanceof InstanceFieldRef){

															if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																if(!taintedStaticFields.contains(def0)){
																	taintedStaticFields.add(((InstanceFieldRef)lhs).getField());
																}
															}
															//System.out.print("instance field expression: " + def0);
															Value base = ((InstanceFieldRef) lhs).getBase();
															if(base instanceof Local){
																List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																if(defs0.size()==1){
																	def0 = (Stmt)defs0.get(0);
																	hasDef = true;

																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																}
															}
														}else if(lhs instanceof ArrayRef){
															Value base = ((ArrayRef) lhs).getBase();
															if(base instanceof Local){
																List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																if(defs0.size()==1){
																	def0 = (Stmt)defs0.get(0);
																	hasDef = true;

																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																}
															}
														}
													}

													while(hasDef){

														if(def0 instanceof DefinitionStmt){
															Value lhs = ((DefinitionStmt) def0).getLeftOp();
															Value rhs = ((DefinitionStmt) def0).getRightOp();
															/*
														if(lhs instanceof InstanceFieldRef){
															//System.out.print("instance field expression: " + def0);
															Value base = ((InstanceFieldRef) lhs).getBase();
															if(base instanceof Local){
																List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																if(defs0.size()==1){
																	def0 = (Stmt)defs0.get(0);

																	if(!defs.contains(def0)){
																		defs.add(def0);
																		delta.add(def0);
																		//System.out.println("both:" + defs + " " + delta);
																	}
																}else{
																	hasDef = false;
																}

															}else{
																hasDef = false;
															}

														}else */
															if(rhs instanceof InstanceFieldRef){

																if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																	if(!taintedStaticFields.contains(def0)){
																		taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																	}
																}
																//System.out.print("instance field expression: " + def0);
																Value base = ((InstanceFieldRef) rhs).getBase();
																if(base instanceof Local){
																	List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																	if(defs0.size()==1){
																		def0 = (Stmt)defs0.get(0);

																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																	}else{
																		hasDef = false;
																	}

																}else{
																	hasDef = false;
																}


															}else if(rhs instanceof ArrayRef){
																Value base = ((ArrayRef) rhs).getBase();
																if(base instanceof Local){
																	List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																	if(defs0.size()==1){
																		def0 = (Stmt)defs0.get(0);

																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																	}else{
																		hasDef = false;
																	}

																}else{
																	hasDef = false;
																}
															}


															else if(rhs instanceof NewExpr){
																DefWithScope def0WS = new DefWithScope(def0, s);
																if(!defs.containsKey(def0)){
																	Vector<Stmt> scopes = new Vector<Stmt>();
																	scopes.add(s);
																	defs.put(def0, scopes);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}else if(!(defs.get(def0).contains(s))){
																	defs.get(def0).add(s);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}
																hasDef = false;
															}else if(rhs instanceof NewArrayExpr){
																DefWithScope def0WS = new DefWithScope(def0, s);
																if(!defs.containsKey(def0)){
																	Vector<Stmt> scopes = new Vector<Stmt>();
																	scopes.add(s);
																	defs.put(def0, scopes);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}else if(!(defs.get(def0).contains(s))){
																	defs.get(def0).add(s);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}
																hasDef = false;
															}else if(rhs instanceof ThisRef){
																DefWithScope def0WS = new DefWithScope(def0, s);
																if(!defs.containsKey(def0)){
																	Vector<Stmt> scopes = new Vector<Stmt>();
																	scopes.add(s);
																	defs.put(def0, scopes);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}else if(!(defs.get(def0).contains(s))){
																	defs.get(def0).add(s);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}
																hasDef = false;
															}else if(rhs instanceof ParameterRef){
																DefWithScope def0WS = new DefWithScope(def0, s);
																if(!defs.containsKey(def0)){
																	Vector<Stmt> scopes = new Vector<Stmt>();
																	scopes.add(s);
																	defs.put(def0, scopes);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}else if(!(defs.get(def0).contains(s))){
																	defs.get(def0).add(s);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}
																hasDef = false;
															}

															else{
																hasDef = false;
															}

														}else{
															hasDef = false;
														}
													}//end while(hasDef){
												}
											}//end else
										}
									}
								}

							}
						}
					}

				}// end while(!delta.isEmpty())

				Iterator i = defs.keySet().iterator();
				while (i.hasNext()) {
					Stmt s = (Stmt)i.next();
					//System.out.print(s + "|");
					
					if(!s.getTags().contains(generalTaintTag)){
						s.addTag(generalTaintTag);
					}
					
					if (!s.getTags().contains(taintTag)) {
						s.addTag(taintTag);
					}

					Iterator usesIt = s.getUseBoxes().iterator();
					while (usesIt.hasNext()) {
						ValueBox vbox = (ValueBox) usesIt.next();
						if (vbox.getValue() instanceof Local) {
							Local l = (Local) vbox.getValue();

							Iterator rDefsIt = mrd.getDefsOfAt(l, s).iterator();
							while (rDefsIt.hasNext()) {
								Stmt next = (Stmt) rDefsIt.next();
								if(!next.getTags().contains(taintTag)){
									
									if(!next.getTags().contains(generalExtraDefTag)){
										next.addTag(generalExtraDefTag);
									}
									
									if(!next.getTags().contains(extraDefTag)){
										next.addTag(extraDefTag);
									}
								}
							}
						}
					}
					//System.out.println(s.getTags());
				}
				// System.out.println();

				if(!MyConstants.COUNT_LOC){
					if(DATAFLOW==true){
						System.out.println();
						System.out.println("method:" + sMethod.getSignature());
						System.out.println("dataflow for " + source + ":");
					}
				}
				Iterator printIt = body.getUnits().iterator();
				while(printIt.hasNext()){
					Stmt s = (Stmt)printIt.next();
					if(s.getTags().contains(taintTag) || s.getTags().contains(extraDefTag)){

						if(!MyConstants.COUNT_LOC){
							if(DATAFLOW==true){
								if(MyConstants.DEBUG_INFO){
									System.out.println(s + "|" + s.getTags());
								}else{
									System.out.println(s);
								}
							}
						}
						
						Vector<Integer> labels = new Vector<Integer>();
						
						for(Tag tag : s.getTags()){
							if(taintTagReverseMap.containsKey(tag)){
								Integer label = new Integer(((TaintTag)tag).getLabel());
								if(!labels.contains(label)){
									labels.add(label);
								}
							}else if(extraDefTagReverseMap.containsKey(tag)){
								Integer label = new Integer(((TaintTag)tag).getLabel());
								if(!labels.contains(label)){
									labels.add(label);
								}
							}								
						}
												
						List<ValueBox> vbs = s.getUseAndDefBoxes();
						Iterator iter = vbs.iterator();
						while(iter.hasNext()){
							ValueBox vb = (ValueBox)iter.next();
							if(vb.getValue() instanceof InstanceFieldRef){
								SootField instanceField = ((InstanceFieldRef)vb.getValue()).getField();

								if(instanceField.getDeclaringClass().isApplicationClass() == false){
									continue;
								}

								if(instanceField.getDeclaringClass().isPhantom()){
									continue;
								}

								//if(!instanceFields.contains(instanceField)){
								//	instanceFields.add(instanceField);
								//}
								////							
								if(!instanceFieldMap.containsKey(instanceField)){						

									Vector<Integer> taintSources = new Vector<Integer>();
									taintSources.addAll(labels);							
									instanceFieldMap.put(instanceField, taintSources);
									
								}else{
									
									Vector<Integer> taintSources = instanceFieldMap.get(instanceField);
									for(Integer label : labels){
										if(!taintSources.contains(label)){
											taintSources.add(label);
										}
									}
								}
								////
								
								LinkedHashMap<String, List<String>> taintSourceToField = new LinkedHashMap<String, List<String>>();
								List<String> fieldList = new ArrayList<String>();
								if(fieldList.contains(instanceField.getSignature())){
									fieldList.add(instanceField.getSignature());
								}								
								taintSourceToField.put(leakSource, fieldList);
								classToSourceToField.put(sMethod.getDeclaringClass().getName(), taintSourceToField);
								
							}else if(vb.getValue() instanceof StaticFieldRef){
								SootField staticField = ((StaticFieldRef)vb.getValue()).getField();

								if(staticField.getDeclaringClass().isApplicationClass() == false){
									continue;
								}

								if(staticField.getDeclaringClass().isPhantom()){
									continue;
								}

								//if(!staticFields.contains(staticField)){
								//	staticFields.add(staticField);
								//}
								///
								if(!staticFieldMap.containsKey(staticField)){						

									Vector<Integer> taintSources = new Vector<Integer>();
									taintSources.addAll(labels);
									staticFieldMap.put(staticField, taintSources);
									
								}else{
									
									Vector<Integer> taintSources = staticFieldMap.get(staticField);
									for(Integer label : labels){
										if(!taintSources.contains(label)){
											taintSources.add(label);
										}
									}
								}
								///
								
								LinkedHashMap<String, List<String>> taintSourceToField = new LinkedHashMap<String, List<String>>();
								List<String> fieldList = new ArrayList<String>();
								if(fieldList.contains(staticField.getSignature())){
									fieldList.add(staticField.getSignature());
								}								
								taintSourceToField.put(leakSource, fieldList);
								classToSourceToField.put(sMethod.getDeclaringClass().getName(), taintSourceToField);
								
							}else if(vb.getValue() instanceof Local){
								
								String varName = ((Local)vb.getValue()).getName();								
								LinkedHashMap<String, List<String>> taintSourceToVar = new LinkedHashMap<String, List<String>>();
								List<String> varList = new ArrayList<String>();
								if(varList.contains(varName)){
									varList.add(varName);
								}								
								taintSourceToVar.put(leakSource, varList);
								methodToSourceToVar.put(sMethod.getSignature(), taintSourceToVar);
							}
						}
					}
				}

				if(!MyConstants.COUNT_LOC){
					if(DATAFLOW==true){
						System.out.println("end dataflow for " + source + "\n");
					}
				}

			}//while(!worklist.isEmpty())



			//doDataFlowAnalysis phase two:
			//iteratively performs data propagation for tainted static fields
			Queue<SootField> fWorklist = new LinkedList<SootField>();
			fWorklist.addAll(taintedStaticFields);
			while(!fWorklist.isEmpty())
			{
				SootField taintedStaticField = fWorklist.remove();

				if(!MyConstants.COUNT_LOC){
					System.out.println("NEW SOURCE: TAINTED FIELD " + taintedStaticField);
				}

				entryPoints = new ArrayList<SootMethod>();
				//instanceFields = new ArrayList<SootField>();
				//staticFields = new ArrayList<SootField>();

				Chain<SootClass> classes = Scene.v().getClasses();
				Iterator<SootClass> classes_iter = classes.iterator();
				while (classes_iter.hasNext()) {
					SootClass soot_class = classes_iter.next();

					if (soot_class.isApplicationClass() == false) {
						continue;
					}

					if(soot_class.isPhantom()){
						continue;
					}

					if(!MyConstants.COUNT_LOC){
						System.out.println("looking for use of static field in " + soot_class.getName() + "..." );
					}
					//System.out.println("package name: " + soot_class.getPackageName());

					List<SootMethod> methods = soot_class.getMethods();
					for (SootMethod method : methods) {

						if(!method.isConcrete()){
							continue;
						}


						JimpleBody body = (JimpleBody) method.retrieveActiveBody();
						Iterator it = body.getUnits().iterator();

						while (it.hasNext()) {
							Stmt s = (Stmt) it.next();
							if(s instanceof DefinitionStmt){
								Value rhs = ((DefinitionStmt) s).getRightOp();
								if(rhs instanceof StaticFieldRef){
									if(((StaticFieldRef) rhs).getField().equals(taintedStaticField)){
										entryPoints.add(method);
									}
								}

								else if(rhs instanceof InstanceFieldRef){

									//if(((InstanceFieldRef) rhs).getField().getType().equals(
									//		RefType.v("android.location.Location"))){
									if(((InstanceFieldRef) rhs).getField().equals(taintedStaticField)){
										entryPoints.add(method);
									}
									//}									

								}
							}
						}


					}
				}



				//for(SootMethod sm : entryPoints){
				//	System.out.println("entry point sm: " + sm);
				//}


				//List<SootMethod> entryPoints = Scene.v().getEntryPoints();


				worklist = new LinkedList<SootMethod>();
				fullWorklist = new LinkedList<SootMethod>();

				worklist.addAll(entryPoints);
				fullWorklist.addAll(entryPoints);

				sourceMethods = new ArrayList<SootMethod>();


				//Iterator itMeth = entryPoints.iterator();


				while(!worklist.isEmpty()){

					//while (itMeth.hasNext()) {

					SootMethod sMethod = worklist.remove();


					boolean hasEquivTable = false;
					LinkedHashMap<Stmt, List<Stmt>> equivTable = null;

					if(methodToEquiv.containsKey(sMethod)){
						hasEquivTable = true;
						equivTable = methodToEquiv.get(sMethod);
					}


					//SootMethod sMethod = (SootMethod) itMeth.next();

					if(!MyConstants.COUNT_LOC){
						System.out.println();
						System.out.println("analyzing method:" + sMethod.getSignature());
					}
					// System.out.println(sMethod.getSource());
					// System.out.println(sMethod.getBytecodeParms());

					JimpleBody body = (JimpleBody) sMethod.retrieveActiveBody();



					ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);

					/*
				if(CFG==true){
					System.out.println("BEGIN [CFG] - " + sMethod + "\n");
					System.out.println(eug.toString());
					System.out.println("END [CFG]");
				}
					 */

					MyReachingDefinition mrd = new MyReachingDefinition(eug);

					/*
				if(REACH_DEF==true){
					System.out.println("BEGIN [Reaching Definition Analysis] - " + sMethod + "\n");
					dumpReachingDefs(mrd, body);
					System.out.println("END [Reaching Definition Analysis]");
				}
					 */


					//dumpReachingDefs(mrd, body);
					/*
				if(sMethod.getSignature().equals("<com.dseffects.MonkeyJump2.jump2.e.c: boolean b(java.lang.String)>")){
					dumpReachingDefs(mrd, body);
				}	
					 */

					//Stack<Stmt> defsStack = new Stack<Stmt>();
					//Vector<Stmt> taintedRefDefs = new Vector<Stmt>();
					Stack<DefWithScope> defsStack = new Stack<DefWithScope>();
					Vector<DefWithScope> taintedRefDefs = new Vector<DefWithScope>();

					//Vector<Stmt> defs = new Vector<Stmt>();
					//Vector<DefWithScope> defs = new Vector<DefWithScope>();
					LinkedHashMap<Stmt, Vector<Stmt>> defs = new LinkedHashMap<Stmt, Vector<Stmt>>();

					Stmt source = null;
					{
						Iterator it = body.getUnits().iterator();
						while (it.hasNext()) {
							Stmt s = (Stmt) it.next();

							if(s instanceof DefinitionStmt){
								Value rhs = ((DefinitionStmt) s).getRightOp();
								if(rhs instanceof StaticFieldRef){
									if(((StaticFieldRef) rhs).getField().equals(taintedStaticField)){

										DefWithScope sWS = new DefWithScope(s);
										if(!defs.containsKey(s)){
											defs.put(s, new Vector<Stmt>());
											defsStack.push(sWS);
											if(MyConstants.DEBUG_INFO)
												System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
											source = s;
										}
									}
								}

								else if(rhs instanceof InstanceFieldRef){
									if(((InstanceFieldRef) rhs).getField().equals(taintedStaticField)){

										DefWithScope sWS = new DefWithScope(s);
										if(!defs.containsKey(s)){
											defs.put(s, new Vector<Stmt>());
											defsStack.push(sWS);
											if(MyConstants.DEBUG_INFO)
												System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
											source = s;
										}
									}
								}
							}

							Iterator useIt = s.getUseBoxes().iterator();
							while (useIt.hasNext()) {
								ValueBox vBox = (ValueBox) useIt.next();
								if (vBox.getValue() instanceof InvokeExpr) {
									if (sourceMethods.contains(((InvokeExpr) vBox.getValue()).getMethod())) {

										DefWithScope sWS = new DefWithScope(s);
										if(!defs.containsKey(s)){
											defs.put(s, new Vector<Stmt>());
											defsStack.push(sWS);
											if(MyConstants.DEBUG_INFO)
												System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
											source = s;
										}
									}
								}
							}
						}
					}

					while(!defsStack.isEmpty()){

						DefWithScope defWS = defsStack.pop();
						System.out.println("POP from def stack: " + defWS.dump());

						if(hasEquivTable){
							if(equivTable.containsKey(defWS.getDef())){

								if(MyConstants.DEBUG_INFO)
									System.out.println(sMethod + " has equivTable: " + equivTable);
								List<Stmt> equivs = equivTable.get(defWS.getDef());

								if(MyConstants.DEBUG_INFO)
									System.out.println("EQUIV found: " + defWS.getDef() + "|" + equivs);

								for(Stmt equiv : equivs){
									DefWithScope equivWS = new DefWithScope(equiv);
									if (!defs.containsKey(equiv)) {
										defs.put(equiv, new Vector<Stmt>());
										defsStack.push(equivWS);
										if(MyConstants.DEBUG_INFO)
											System.out.println("def stack doesn't contain " + equivWS.dump() + ". Push it.");
									}
								}
							}
						}

						Iterator it = body.getUnits().iterator();
						while (it.hasNext()) {
							Stmt s = (Stmt) it.next();

							//if current statement is not within the scope of the new definition, continue to next statement.
							/*
						if(defWS.getScopeBegin()!=null){						
							if(eug.getExtendedBasicBlockPathBetween(defWS.getScopeBegin(), s)!=null){
								if(MyConstants.DEBUG_INFO){
									System.out.println(s + " is NOT in the scope: " + defWS.getScopeBegin());
								}
								continue;
							}
						}
							 */
							if(defWS.getScopeBegin()!=null){
								if(!isInScope(eug, s, defWS.getScopeBegin())){
									if(MyConstants.DEBUG_INFO){
										System.out.println(s + " is NOT in the scope: " + defWS.getScopeBegin());
									}
									continue;
								}
							}

							Iterator usesIt = s.getUseBoxes().iterator();
							while (usesIt.hasNext()) {
								ValueBox vbox = (ValueBox) usesIt.next();
								if (vbox.getValue() instanceof Local) {
									Local l = (Local) vbox.getValue();

									Iterator rDefsIt = mrd.getDefsOfAt(l, s).iterator();
									while (rDefsIt.hasNext()) {
										Stmt next = (Stmt) rDefsIt.next();

										if(next == defWS.getDef()){

											if (s instanceof InvokeStmt) {
												Vector<Integer> taintVector = new Vector<Integer>();

												Iterator defIt2 = next.getDefBoxes().iterator();
												while (defIt2.hasNext()) {
													ValueBox vbox2 = (ValueBox) defIt2.next();
													if (vbox2.getValue() instanceof Local) {
														InvokeExpr invokeEx = s.getInvokeExpr();
														int argCount = invokeEx.getArgCount();
														for (int i = 0; i < argCount; i++) {
															if (invokeEx.getArg(i) == vbox2.getValue()) {
																taintVector.add(new Integer(i));
															}												
														}

														if(invokeEx instanceof InstanceInvokeExpr){
															if(((InstanceInvokeExpr) invokeEx).getBase() == vbox2.getValue()){

																if(invokeEx instanceof SpecialInvokeExpr){
																	if(next instanceof DefinitionStmt){
																		Value rhs = ((DefinitionStmt) next).getRightOp();
																		if(rhs instanceof NewExpr){
																			continue;
																		}
																	}
																}
																taintVector.add(new Integer(MyConstants.thisObject));
															}
														}
													}
												}

												if(taintVector.isEmpty()){

													if(MyConstants.DEBUG_INFO)
														System.out.println("No parameters: " + s);
													continue;
												}

												if(sinks.contains(s.getInvokeExpr().getMethod().getSignature())){	

													DefWithScope sWS = new DefWithScope(s);
													if (!defs.containsKey(s)) {
														defs.put(s, new Vector<Stmt>());
													}

													if(taintVector.contains(new Integer(0))
															|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
														//if(!MyConstants.COUNT_LOC){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());
														//}
														continue;
													}else if(taintVector.contains(new Integer(3))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}else if(taintVector.contains(new Integer(2))
															&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
														System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

														continue;
													}
													else{
														if(MyConstants.DEBUG_INFO)
															System.out.println(s.getInvokeExpr().getMethod() 
																	+ " found, but tainted index is " + taintVector);
													}
												}

												Iterator targets = new Targets(this.cg.edgesOutOf(s));

												if(!targets.hasNext()){
													if(MyConstants.DEBUG_INFO)
														System.out.println(s + " does NOT have a target. add a DEFAULT one");
													List<SootMethod> defaultTargets = new ArrayList<SootMethod>();
													defaultTargets.add(s.getInvokeExpr().getMethod());
													targets = defaultTargets.iterator();
												}

												while (targets.hasNext()) {
													SootMethod target = (SootMethod) targets.next();

													//if(MyConstants.DEBUG_INFO)
													if(!MyConstants.COUNT_LOC){
														if(DATAFLOW==true)
															System.out.println("call target is " + target);
													}

													// check for sink
													if(sinks.contains(target.getSignature())){
														if(taintVector.contains(new Integer(0))
																|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
															//if(!MyConstants.COUNT_LOC){
															System.out.println("SINK found in " + sMethod + " : " + target);
															//}
															continue;
														}else if(taintVector.contains(new Integer(3))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}															
														else{
															if(MyConstants.DEBUG_INFO)
																System.out.println(target + " found, but tainted index is " + taintVector);
														}

														DefWithScope sWS = new DefWithScope(s);
														if (!defs.containsKey(s)) {
															defs.put(s, new Vector<Stmt>());
														}
													} else {

														boolean noNewTaint = true;
														if(!propagationHistory.containsKey(sMethod.getSignature()+"|"+s.toString())){														
															noNewTaint = false;
															List<Integer> sources = new ArrayList<Integer>();
															sources.addAll(taintVector);
															propagationHistory.put(sMethod.getSignature()+"|"+s.toString(), sources);
														}else{
															List<Integer> sources = propagationHistory.get(sMethod.getSignature()+"|"+s.toString());
															for(Integer taint : taintVector){
																if(!sources.contains(taint)){
																	noNewTaint = false;
																	sources.add(taint);
																}
															}														
														}

														DefWithScope sWS = new DefWithScope(s);
														if (!defs.containsKey(s)) {
															defs.put(s, new Vector<Stmt>());
															defsStack.push(sWS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
														}else{
															if(noNewTaint){
																break;
															}
														}

														if(!MyConstants.COUNT_LOC){
															if(DATAFLOW==true){
																System.out.println("PROPAGATING from METHOD: " + sMethod);
																System.out.println("PROPAGATING from STATEMENT: " + s);
															}
														}
														CallGraphTransformer.taintedFieldsInCaller.addAll(taintedStaticFields);
														Vector<Integer> tainted = propagate(target, taintVector, leakSource);
														for(SootField sf : CallGraphTransformer.taintedFieldsInCallee){
															if(!taintedStaticFields.contains(sf)){
																taintedStaticFields.add(sf);
																fWorklist.add(sf);
															}
														}
														CallGraphTransformer.taintedFieldsInCallee.clear();

														//if(MyConstants.DEBUG_INFO)
														if(!MyConstants.COUNT_LOC){
															if(DATAFLOW==true)
																System.out.println(s + " |taint:" + taintVector + "| PROPAGATION result: " + tainted);
														}
														if ((tainted!=null) && (!tainted.isEmpty())) {

															for(Integer i : tainted){
																int index = i.intValue();

																if(index == MyConstants.returnValue){
																	if(s instanceof DefinitionStmt){
																		Value taintedRet = ((DefinitionStmt) s).getLeftOp();
																		if(taintedRet instanceof Local){

																			if (!defs.containsKey(s)) {

																				if(MyConstants.DEBUG_INFO)
																					System.out.println("adding def of return value:" + s);

																				defs.put(s, new Vector<Stmt>());
																				defsStack.push(sWS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
																			}
																		}
																	}

																}else if(index == MyConstants.thisObject){
																	if(s.getInvokeExpr() instanceof InstanceInvokeExpr){
																		Value taintedThisRef = ((InstanceInvokeExpr)s.getInvokeExpr()).getBase();

																		boolean hasDef = false;
																		Stmt def0 = s;
																		if(taintedThisRef instanceof Local){
																			List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedThisRef, def0);
																			if(defs0.size()==1){
																				def0 = (Stmt)defs0.get(0);
																				hasDef = true;

																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																			}else{
																				//not very good solution :(
																				for(Unit defn : defs0){

																					DefWithScope defnWS = new DefWithScope((Stmt)defn, s);
																					if(!defs.containsKey(defn)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put((Stmt)defn, scopes);
																						defsStack.push(defnWS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																					}else if(!(defs.get(defn).contains(s))){
																						defs.get(defn).add(s);
																						defsStack.push(defnWS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																					}
																				}
																			}
																		}

																		while(hasDef){

																			if(def0 instanceof DefinitionStmt){
																				Value lhs = ((DefinitionStmt) def0).getLeftOp();
																				Value rhs = ((DefinitionStmt) def0).getRightOp();

																				if(rhs instanceof InstanceFieldRef){

																					if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																						if(!taintedStaticFields.contains(((InstanceFieldRef)rhs).getField())){
																							taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																							fWorklist.add(((InstanceFieldRef)rhs).getField());
																						}
																					}
																					Value base = ((InstanceFieldRef) rhs).getBase();
																					if(base instanceof Local){
																						List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																						if(defs0.size()==1){
																							def0 = (Stmt)defs0.get(0);

																							DefWithScope def0WS = new DefWithScope(def0, s);
																							if(!defs.containsKey(def0)){
																								Vector<Stmt> scopes = new Vector<Stmt>();
																								scopes.add(s);
																								defs.put(def0, scopes);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}else if(!(defs.get(def0).contains(s))){
																								defs.get(def0).add(s);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}
																						}else{
																							hasDef = false;
																						}

																					}else{
																						hasDef = false;
																					}


																				}else if(rhs instanceof ArrayRef){
																					Value base = ((ArrayRef) rhs).getBase();
																					if(base instanceof Local){
																						List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																						if(defs0.size()==1){
																							def0 = (Stmt)defs0.get(0);

																							DefWithScope def0WS = new DefWithScope(def0, s);
																							if(!defs.containsKey(def0)){
																								Vector<Stmt> scopes = new Vector<Stmt>();
																								scopes.add(s);
																								defs.put(def0, scopes);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}else if(!(defs.get(def0).contains(s))){
																								defs.get(def0).add(s);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}
																						}else{
																							hasDef = false;
																						}

																					}else{
																						hasDef = false;
																					}
																				}
																				else if(rhs instanceof StaticFieldRef){

																					if(!taintedStaticFields.contains(((StaticFieldRef)rhs).getField())){
																						taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																						fWorklist.add(((StaticFieldRef)rhs).getField());
																					}

																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}


																				else if(rhs instanceof NewExpr){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof NewArrayExpr){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof ThisRef){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof ParameterRef){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof InstanceInvokeExpr){
																					if(((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																							"<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>")
																							|| ((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																									"<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>")){
																						Value base = ((InstanceInvokeExpr) rhs).getBase();
																						if(base instanceof Local){
																							List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																							if(defs0.size()==1){
																								def0 = (Stmt)defs0.get(0);

																								DefWithScope def0WS = new DefWithScope(def0, s);
																								if(!defs.containsKey(def0)){
																									Vector<Stmt> scopes = new Vector<Stmt>();
																									scopes.add(s);
																									defs.put(def0, scopes);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}else if(!(defs.get(def0).contains(s))){
																									defs.get(def0).add(s);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}
																							}else{
																								hasDef = false;
																							}
																						}else{
																							hasDef = false;
																						}
																					}else{
																						hasDef = false;
																					}
																				}

																				else{
																					hasDef = false;
																				}

																			}else{
																				hasDef = false;
																			}
																		}//end while(hasDef){

																		/*
																	if(taintedThisRef instanceof Local){
																		List<Unit> thisRefDefs = mrd.getDefsOfAt((Local)taintedThisRef, s);
																		for(Unit thisRefDef : thisRefDefs){
																			if((!taintedRefDefs.contains((Stmt)thisRefDef))
																					&& (!defs.contains((Stmt)thisRefDef))){
																				taintedRefDefs.add((Stmt)thisRefDef);
																				//deltaTaintedRefDefs.add((Stmt)thisRefDef);
																				defsStack.push((Stmt)thisRefDef);
																			}
																		}
																	}
																		 */															
																	}														 

																}else if(index >= 0){

																	Value taintedArg = s.getInvokeExpr().getArg(index);


																	boolean hasDef = false;
																	Stmt def0 = s;
																	if(taintedArg instanceof Local && taintedArg.getType() instanceof RefLikeType){
																		List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedArg, def0);
																		if(defs0.size()==1){
																			def0 = (Stmt)defs0.get(0);
																			hasDef = true;

																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																		}
																	}

																	while(hasDef){

																		if(def0 instanceof DefinitionStmt){
																			Value lhs = ((DefinitionStmt) def0).getLeftOp();
																			Value rhs = ((DefinitionStmt) def0).getRightOp();

																			if(rhs instanceof InstanceFieldRef){

																				if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																					if(!taintedStaticFields.contains(((InstanceFieldRef)rhs).getField())){
																						taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																						fWorklist.add(((InstanceFieldRef)rhs).getField());
																					}
																				}

																				Value base = ((InstanceFieldRef) rhs).getBase();
																				if(base instanceof Local){
																					List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																					if(defs0.size()==1){
																						def0 = (Stmt)defs0.get(0);

																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																					}else{
																						hasDef = false;
																					}

																				}else{
																					hasDef = false;
																				}

																			}else if(rhs instanceof ArrayRef){
																				Value base = ((ArrayRef) rhs).getBase();
																				if(base instanceof Local){
																					List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																					if(defs0.size()==1){
																						def0 = (Stmt)defs0.get(0);

																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																					}else{
																						hasDef = false;
																					}

																				}else{
																					hasDef = false;
																				}
																			}
																			else if(rhs instanceof StaticFieldRef){

																				if(!taintedStaticFields.contains(((StaticFieldRef)rhs).getField())){
																					taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																					fWorklist.add(((StaticFieldRef)rhs).getField());
																				}

																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}
																			else if(rhs instanceof NewExpr){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof NewArrayExpr){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof ThisRef){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}else if(rhs instanceof ParameterRef){
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																				hasDef = false;
																			}

																			else{
																				hasDef = false;
																			}

																		}else{
																			hasDef = false;
																		}
																	}//end while(hasDef){
																	/*
																if(taintedArg instanceof Local){
																	Type type = taintedArg.getType();
																	if(type instanceof RefLikeType){


																		List<Unit> argRefDefs = mrd.getDefsOfAt((Local)taintedArg, s);
																		for(Unit argRefDef : argRefDefs){

																			if((!taintedRefDefs.contains((Stmt)argRefDef))
																					&& (!defs.contains((Stmt)argRefDef))){
																				taintedRefDefs.add((Stmt)argRefDef);
																				//deltaTaintedRefDefs.add((Stmt)argRefDef);
																				defsStack.push((Stmt)argRefDef);
																			}

																		}

																	}
																}
																	 */
																}
															}
														}
													}
												}

											} else {

												boolean isInvoke = false;

												Iterator iUse = s.getUseBoxes().iterator();
												while (iUse.hasNext()) {
													ValueBox vB = (ValueBox) iUse.next();
													if (vB.getValue() instanceof InvokeExpr) {
														isInvoke = true;
													}
												}

												if (isInvoke) {
													Vector<Integer> taintVector = new Vector<Integer>();

													Iterator defIt2 = next.getDefBoxes().iterator();
													while (defIt2.hasNext()) {
														ValueBox vbox2 = (ValueBox) defIt2.next();
														if (vbox2.getValue() instanceof Local) {
															InvokeExpr invokeEx = s.getInvokeExpr();
															int argCount = invokeEx.getArgCount();
															for (int i = 0; i < argCount; i++) {
																if (invokeEx.getArg(i) == vbox2.getValue()) {
																	taintVector.add(new Integer(i));
																}
															}


															if(invokeEx instanceof InstanceInvokeExpr){
																if(((InstanceInvokeExpr) invokeEx).getBase() == vbox2.getValue()){

																	if(invokeEx instanceof SpecialInvokeExpr){
																		if(next instanceof DefinitionStmt){
																			Value rhs = ((DefinitionStmt) next).getRightOp();
																			if(rhs instanceof NewExpr){
																				continue;
																			}
																		}
																	}
																	taintVector.add(new Integer(MyConstants.thisObject));
																}
															}

														}
													}

													if(taintVector.isEmpty()){
														if(MyConstants.DEBUG_INFO)
															System.out.println("No parameters: " + s);
														continue;
													}

													if(sinks.contains(s.getInvokeExpr().getMethod().getSignature())){	

														//DefWithScope sWS = new DefWithScope(s);
														if (!defs.containsKey(s)) {
															defs.put(s, new Vector<Stmt>());
														}

														if(taintVector.contains(new Integer(0))
																|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
															//if(!MyConstants.COUNT_LOC){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());
															//}
															continue;
														}else if(taintVector.contains(new Integer(3))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}else if(taintVector.contains(new Integer(2))
																&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
															System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

															continue;
														}
														else{
															if(MyConstants.DEBUG_INFO)
																System.out.println(s.getInvokeExpr().getMethod() + 
																		" found, but tainted index is " + taintVector);
														}

													}

													Iterator targets = new Targets(this.cg.edgesOutOf(s));

													if(!targets.hasNext()){

														if(MyConstants.DEBUG_INFO)
															System.out.println(s + " does NOT have a target. add a DEFAULT one");
														List<SootMethod> defaultTargets = new ArrayList<SootMethod>();
														defaultTargets.add(s.getInvokeExpr().getMethod());
														targets = defaultTargets.iterator();
													}

													while (targets.hasNext()) {
														SootMethod target = (SootMethod) targets.next();

														//if(MyConstants.DEBUG_INFO)
														if(!MyConstants.COUNT_LOC){
															if(DATAFLOW==true)
																System.out.println("call target is " + target);
														}

														// check for sink
														if(sinks.contains(target.getSignature())){
															if(taintVector.contains(new Integer(0))
																	|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
																//if(!MyConstants.COUNT_LOC){
																System.out.println("SINK found in " + sMethod + " : " + target);
																//}
																continue;
															}else if(taintVector.contains(new Integer(3))
																	&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
																System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

																continue;
															}else if(taintVector.contains(new Integer(2))
																	&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
																System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

																continue;
															}else if(taintVector.contains(new Integer(2))
																	&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
																System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

																continue;
															}else if(taintVector.contains(new Integer(2))
																	&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
																System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

																continue;
															}
															else{
																if(MyConstants.DEBUG_INFO)
																	System.out.println(target + " found, but tainted index is " + taintVector);
															}

															//DefWithScope sWS = new DefWithScope(s);
															if (!defs.containsKey(s)) {
																defs.put(s, new Vector<Stmt>());
															}
														} else {
															boolean noNewTaint = true;
															if(!propagationHistory.containsKey(sMethod.getSignature()+"|"+s.toString())){															
																noNewTaint = false;
																List<Integer> sources = new ArrayList<Integer>();
																sources.addAll(taintVector);
																propagationHistory.put(sMethod.getSignature()+"|"+s.toString(), sources);
															}else{
																List<Integer> sources = propagationHistory.get(sMethod.getSignature()+"|"+s.toString());

																for(Integer taint : taintVector){
																	if(!sources.contains(taint)){
																		noNewTaint = false;
																		sources.add(taint);
																	}
																}

															}

															DefWithScope sWS = new DefWithScope(s);
															if (!defs.containsKey(s)) {
																defs.put(s, new Vector<Stmt>());
																defsStack.push(sWS);
																if(MyConstants.DEBUG_INFO)
																	System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
															}else{
																if(noNewTaint){
																	break;
																}
															}

															if(!MyConstants.COUNT_LOC){
																if(DATAFLOW==true){
																	System.out.println("PROPAGATING from METHOD: " + sMethod);
																	System.out.println("PROPAGATING from STATEMENT: " + s);
																}
															}
															CallGraphTransformer.taintedFieldsInCaller.addAll(taintedStaticFields);
															Vector<Integer> tainted = propagate(target, taintVector, leakSource);														
															for(SootField sf : CallGraphTransformer.taintedFieldsInCallee){
																if(!taintedStaticFields.contains(sf)){
																	taintedStaticFields.add(sf);
																	fWorklist.add(sf);
																}
															}
															CallGraphTransformer.taintedFieldsInCallee.clear();

															//if(MyConstants.DEBUG_INFO)
															if(!MyConstants.COUNT_LOC){
																if(DATAFLOW==true)
																	System.out.println(s + " |taint:" + taintVector + "| PROPAGATION result: " + tainted);
															}
															if ((tainted!=null) && (!tainted.isEmpty())) {

																for(Integer i : tainted){
																	int index = i.intValue();

																	if(index == MyConstants.returnValue){
																		if(s instanceof DefinitionStmt){
																			Value taintedRet = ((DefinitionStmt) s).getLeftOp();
																			if(taintedRet instanceof Local){

																				if (!defs.containsKey(s)) {

																					if(MyConstants.DEBUG_INFO)
																						System.out.println("adding def of return value:" + s);

																					defs.put(s, new Vector<Stmt>());
																					defsStack.push(sWS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
																				}
																			}
																		}

																	}else if(index == MyConstants.thisObject){
																		if(s.getInvokeExpr() instanceof InstanceInvokeExpr){
																			Value taintedThisRef = ((InstanceInvokeExpr)s.getInvokeExpr()).getBase();

																			boolean hasDef = false;
																			Stmt def0 = s;
																			if(taintedThisRef instanceof Local){
																				List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedThisRef, def0);
																				if(defs0.size()==1){
																					def0 = (Stmt)defs0.get(0);
																					hasDef = true;

																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																				}else{
																					//not very good solution :(
																					for(Unit defn : defs0){

																						DefWithScope defnWS = new DefWithScope((Stmt)defn, s);
																						if(!defs.containsKey(defn)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put((Stmt)defn, scopes);
																							defsStack.push(defnWS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																						}else if(!(defs.get(defn).contains(s))){
																							defs.get(defn).add(s);
																							defsStack.push(defnWS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																						}
																					}
																				}
																			}

																			while(hasDef){
																				//System.out.println("def0:" + def0);


																				if(def0 instanceof DefinitionStmt){
																					Value lhs = ((DefinitionStmt) def0).getLeftOp();
																					Value rhs = ((DefinitionStmt) def0).getRightOp();

																					if(rhs instanceof InstanceFieldRef){

																						if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																							if(!taintedStaticFields.contains(((InstanceFieldRef)rhs).getField())){
																								taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																								fWorklist.add(((InstanceFieldRef)rhs).getField());
																							}
																						}

																						//System.out.print("instance field expression: " + def0);
																						Value base = ((InstanceFieldRef) rhs).getBase();
																						if(base instanceof Local){
																							List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																							if(defs0.size()==1){
																								def0 = (Stmt)defs0.get(0);

																								DefWithScope def0WS = new DefWithScope(def0, s);
																								if(!defs.containsKey(def0)){
																									Vector<Stmt> scopes = new Vector<Stmt>();
																									scopes.add(s);
																									defs.put(def0, scopes);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}else if(!(defs.get(def0).contains(s))){
																									defs.get(def0).add(s);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}
																							}else{
																								hasDef = false;
																							}

																						}else{
																							hasDef = false;
																						}


																					}else if(rhs instanceof ArrayRef){
																						Value base = ((ArrayRef) rhs).getBase();
																						if(base instanceof Local){
																							List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																							if(defs0.size()==1){
																								def0 = (Stmt)defs0.get(0);

																								DefWithScope def0WS = new DefWithScope(def0, s);
																								if(!defs.containsKey(def0)){
																									Vector<Stmt> scopes = new Vector<Stmt>();
																									scopes.add(s);
																									defs.put(def0, scopes);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}else if(!(defs.get(def0).contains(s))){
																									defs.get(def0).add(s);
																									defsStack.push(def0WS);
																									if(MyConstants.DEBUG_INFO)
																										System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																								}
																							}else{
																								hasDef = false;
																							}

																						}else{
																							hasDef = false;
																						}
																					}
																					else if(rhs instanceof StaticFieldRef){

																						if(!taintedStaticFields.contains(((StaticFieldRef)rhs).getField())){
																							taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																							fWorklist.add(((StaticFieldRef)rhs).getField());
																						}

																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																						hasDef = false;
																					}


																					else if(rhs instanceof NewExpr){
																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																						hasDef = false;
																					}else if(rhs instanceof NewArrayExpr){
																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																						hasDef = false;
																					}else if(rhs instanceof ThisRef){
																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																						hasDef = false;
																					}else if(rhs instanceof ParameterRef){
																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																						hasDef = false;
																					}else if(rhs instanceof InstanceInvokeExpr){
																						if(((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																								"<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>")
																								|| ((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																										"<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>")){
																							Value base = ((InstanceInvokeExpr) rhs).getBase();
																							if(base instanceof Local){
																								List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																								if(defs0.size()==1){
																									def0 = (Stmt)defs0.get(0);

																									DefWithScope def0WS = new DefWithScope(def0, s);
																									if(!defs.containsKey(def0)){
																										Vector<Stmt> scopes = new Vector<Stmt>();
																										scopes.add(s);
																										defs.put(def0, scopes);
																										defsStack.push(def0WS);
																										if(MyConstants.DEBUG_INFO)
																											System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																									}else if(!(defs.get(def0).contains(s))){
																										defs.get(def0).add(s);
																										defsStack.push(def0WS);
																										if(MyConstants.DEBUG_INFO)
																											System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																									}
																								}else{
																									hasDef = false;
																								}
																							}else{
																								hasDef = false;
																							}
																						}else{
																							hasDef = false;
																						}
																					}

																					else{
																						hasDef = false;
																					}

																				}else{
																					hasDef = false;
																				}
																			}//end while(hasDef){
																			/*
																		if(taintedThisRef instanceof Local){
																			List<Unit> thisRefDefs = mrd.getDefsOfAt((Local)taintedThisRef, s);
																			for(Unit thisRefDef : thisRefDefs){
																				if((!taintedRefDefs.contains((Stmt)thisRefDef))
																						&& (!defs.contains((Stmt)thisRefDef))){
																					taintedRefDefs.add((Stmt)thisRefDef);
																					//deltaTaintedRefDefs.add((Stmt)thisRefDef);
																					defsStack.push((Stmt)thisRefDef);
																				}
																			}
																		}	
																			 */														
																		}														 

																	}else if(index >= 0){

																		Value taintedArg = s.getInvokeExpr().getArg(index);

																		boolean hasDef = false;
																		Stmt def0 = s;
																		if(taintedArg instanceof Local && taintedArg.getType() instanceof RefLikeType){
																			List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedArg, def0);
																			if(defs0.size()==1){
																				def0 = (Stmt)defs0.get(0);
																				hasDef = true;

																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																			}
																		}

																		while(hasDef){

																			if(def0 instanceof DefinitionStmt){
																				Value lhs = ((DefinitionStmt) def0).getLeftOp();
																				Value rhs = ((DefinitionStmt) def0).getRightOp();

																				if(rhs instanceof InstanceFieldRef){

																					if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																						if(!taintedStaticFields.contains(((InstanceFieldRef)rhs).getField())){
																							taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																							fWorklist.add(((InstanceFieldRef)rhs).getField());
																						}
																					}

																					//System.out.print("instance field expression: " + def0);
																					Value base = ((InstanceFieldRef) rhs).getBase();
																					if(base instanceof Local){
																						List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																						if(defs0.size()==1){
																							def0 = (Stmt)defs0.get(0);

																							DefWithScope def0WS = new DefWithScope(def0, s);
																							if(!defs.containsKey(def0)){
																								Vector<Stmt> scopes = new Vector<Stmt>();
																								scopes.add(s);
																								defs.put(def0, scopes);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}else if(!(defs.get(def0).contains(s))){
																								defs.get(def0).add(s);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}
																						}else{
																							hasDef = false;
																						}

																					}else{
																						hasDef = false;
																					}


																				}else if(rhs instanceof ArrayRef){
																					Value base = ((ArrayRef) rhs).getBase();
																					if(base instanceof Local){
																						List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																						if(defs0.size()==1){
																							def0 = (Stmt)defs0.get(0);

																							DefWithScope def0WS = new DefWithScope(def0, s);
																							if(!defs.containsKey(def0)){
																								Vector<Stmt> scopes = new Vector<Stmt>();
																								scopes.add(s);
																								defs.put(def0, scopes);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}else if(!(defs.get(def0).contains(s))){
																								defs.get(def0).add(s);
																								defsStack.push(def0WS);
																								if(MyConstants.DEBUG_INFO)
																									System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																							}
																						}else{
																							hasDef = false;
																						}

																					}else{
																						hasDef = false;
																					}
																				}
																				else if(rhs instanceof StaticFieldRef){

																					if(!taintedStaticFields.contains(((StaticFieldRef)rhs).getField())){
																						taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																						fWorklist.add(((StaticFieldRef)rhs).getField());
																					}

																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}


																				else if(rhs instanceof NewExpr){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof NewArrayExpr){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof ThisRef){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}else if(rhs instanceof ParameterRef){
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																					hasDef = false;
																				}

																				else{
																					hasDef = false;
																				}

																			}else{
																				hasDef = false;
																			}
																		}//end while(hasDef){
																		/*
																	if(taintedArg instanceof Local){
																		Type type = taintedArg.getType();
																		if(type instanceof RefLikeType){
																			List<Unit> argRefDefs = mrd.getDefsOfAt((Local)taintedArg, s);
																			for(Unit argRefDef : argRefDefs){
																				if((!taintedRefDefs.contains((Stmt)argRefDef))
																						&& (!defs.contains((Stmt)argRefDef))){
																					taintedRefDefs.add((Stmt)argRefDef);
																					//deltaTaintedRefDefs.add((Stmt)argRefDef);
																					defsStack.push((Stmt)argRefDef);
																				}
																			}
																		}
																	}
																		 */
																	}
																}
															}
														}
													}
													// invokes.add(s);
												} else if(s instanceof ReturnStmt){

													if(!MyConstants.COUNT_LOC){
														if(DATAFLOW==true)
															System.out.println("returning to caller...");
													}
													if(MyConstants.DEBUG_INFO)
														System.out.println("return to caller from: " + sMethod + " | " + s);

													DefWithScope sWS = new DefWithScope(s);
													if (!defs.containsKey(s)) {
														defs.put(s, new Vector<Stmt>());
														defsStack.push(sWS);
														if(MyConstants.DEBUG_INFO)
															System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
													}

													Chain<SootClass> classes1 = Scene.v().getClasses();
													Iterator<SootClass> classes_iter1 = classes1.iterator();
													while (classes_iter1.hasNext()) {
														SootClass soot_class = classes_iter1.next();

														if (soot_class.isApplicationClass() == false) {
															continue;
														}

														if(soot_class.isPhantom()){
															continue;
														}

														List<SootMethod> methods = soot_class.getMethods();
														for (SootMethod method : methods) {
															Iterator targets = new Targets(cg.edgesOutOf(method));													

															while (targets.hasNext()) {
																SootMethod target = (SootMethod) targets.next();
																//System.out.println(method + " may call " + target);
																if(target.equals(sMethod)){
																	if(!fullWorklist.contains(method)){
																		worklist.add(method);
																		fullWorklist.add(method);
																		if(!sourceMethods.contains(sMethod)){
																			sourceMethods.add(sMethod);
																		}																	
																	}
																}															
															}
														}
													}
												}										

												else {
													if(s instanceof DefinitionStmt){
														Value lhs = ((DefinitionStmt) s).getLeftOp();
														if(lhs instanceof ArrayRef){
															Value base = ((ArrayRef) lhs).getBase();
															if(base == l){
																continue;
															}
														}else if(lhs instanceof InstanceFieldRef){
															Value base = ((InstanceFieldRef) lhs).getBase();
															if(base == l){
																continue;
															}
														}
													}

													DefWithScope sWS = new DefWithScope(s);
													if (!defs.containsKey(s)) {
														defs.put(s, new Vector<Stmt>());
														defsStack.push(sWS);
														if(MyConstants.DEBUG_INFO)
															System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");

														if(s instanceof DefinitionStmt){
															Value lhs = ((DefinitionStmt) s).getLeftOp();
															if(lhs instanceof StaticFieldRef){
																if(!taintedStaticFields.contains(((StaticFieldRef)lhs).getField())){
																	taintedStaticFields.add(((StaticFieldRef)lhs).getField());
																	fWorklist.add(((StaticFieldRef)lhs).getField());
																}
															}
														}

														boolean hasDef = false;
														Stmt def0 = s;

														if(def0 instanceof DefinitionStmt){
															Value lhs = ((DefinitionStmt) def0).getLeftOp();

															if(lhs instanceof InstanceFieldRef){

																if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																	if(!taintedStaticFields.contains(((InstanceFieldRef)lhs).getField())){
																		taintedStaticFields.add(((InstanceFieldRef)lhs).getField());
																		fWorklist.add(((InstanceFieldRef)lhs).getField());
																	}
																}

																Value base = ((InstanceFieldRef) lhs).getBase();
																if(base instanceof Local){
																	List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																	if(defs0.size()==1){
																		def0 = (Stmt)defs0.get(0);
																		hasDef = true;

																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																	}
																}
															}else if(lhs instanceof ArrayRef){
																Value base = ((ArrayRef) lhs).getBase();
																if(base instanceof Local){
																	List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																	if(defs0.size()==1){
																		def0 = (Stmt)defs0.get(0);
																		hasDef = true;

																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																	}
																}
															}
														}





														while(hasDef){

															if(def0 instanceof DefinitionStmt){
																Value lhs = ((DefinitionStmt) def0).getLeftOp();
																Value rhs = ((DefinitionStmt) def0).getRightOp();

																if(rhs instanceof InstanceFieldRef){

																	if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																		if(!taintedStaticFields.contains(((InstanceFieldRef)rhs).getField())){
																			taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																			fWorklist.add(((InstanceFieldRef)rhs).getField());
																		}
																	}

																	Value base = ((InstanceFieldRef) rhs).getBase();
																	if(base instanceof Local){
																		List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																		if(defs0.size()==1){
																			def0 = (Stmt)defs0.get(0);

																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																		}else{
																			hasDef = false;
																		}

																	}else{
																		hasDef = false;
																	}


																}else if(rhs instanceof ArrayRef){
																	Value base = ((ArrayRef) rhs).getBase();
																	if(base instanceof Local){
																		List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																		if(defs0.size()==1){
																			def0 = (Stmt)defs0.get(0);

																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																		}else{
																			hasDef = false;
																		}

																	}else{
																		hasDef = false;
																	}
																}


																else if(rhs instanceof NewExpr){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}else if(rhs instanceof NewArrayExpr){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}else if(rhs instanceof ThisRef){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}else if(rhs instanceof ParameterRef){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}

																else{
																	hasDef = false;
																}

															}else{
																hasDef = false;
															}
														}//end while(hasDef){
													}
												}//end else
											}
										}
									}

								}
							}
						}

					}// end while(!delta.isEmpty())


					Iterator i = defs.keySet().iterator();
					while (i.hasNext()) {
						Stmt s = (Stmt)i.next();
						//System.out.print(s + "|");
						if(!s.getTags().contains(generalTaintTag)){
							s.addTag(generalTaintTag);
						}
						
						if (!s.getTags().contains(taintTag)) {
							s.addTag(taintTag);
							s.addTag(taintStaticTag);
						}

						else if(!s.getTags().contains(taintStaticTag)){
							s.addTag(taintStaticTag);
						}

						Iterator usesIt = s.getUseBoxes().iterator();
						while (usesIt.hasNext()) {
							ValueBox vbox = (ValueBox) usesIt.next();
							if (vbox.getValue() instanceof Local) {
								Local l = (Local) vbox.getValue();

								Iterator rDefsIt = mrd.getDefsOfAt(l, s).iterator();
								while (rDefsIt.hasNext()) {
									Stmt next = (Stmt) rDefsIt.next();
																		
									if(!next.getTags().contains(taintTag)){
										
										if(!next.getTags().contains(generalExtraDefTag)){
											next.addTag(generalExtraDefTag);
										}
										
										if(!next.getTags().contains(extraDefTag)){
											next.addTag(extraDefTag);
											next.addTag(taintStaticTag);
										}
									}else if(!next.getTags().contains(taintStaticTag)){
										next.addTag(taintStaticTag);
									}
								}
							}
						}

					}

					if(!MyConstants.COUNT_LOC){
						if(DATAFLOW==true){
							System.out.println();
							System.out.println("method:" + sMethod.getSignature());
							System.out.println("dataflow for " + source + ":");
						}
					}

					Iterator printIt = body.getUnits().iterator();
					while(printIt.hasNext()){
						Stmt s = (Stmt)printIt.next();

						if((s.getTags().contains(taintTag) || s.getTags().contains(extraDefTag))
								&& s.getTags().contains(taintStaticTag)){

							if(!MyConstants.COUNT_LOC){
								if(DATAFLOW==true){
									if(MyConstants.DEBUG_INFO){
										System.out.println(s + "|" + s.getTags());
									}else{
										System.out.println(s);
									}
								}
							}
							
							Vector<Integer> labels = new Vector<Integer>();
							
							for(Tag tag : s.getTags()){
								if(taintTagReverseMap.containsKey(tag)){
									Integer label = new Integer(((TaintTag)tag).getLabel());
									if(!labels.contains(label)){
										labels.add(label);
									}
								}else if(extraDefTagReverseMap.containsKey(tag)){
									Integer label = new Integer(((TaintTag)tag).getLabel());
									if(!labels.contains(label)){
										labels.add(label);
									}
								}								
							}

							List<ValueBox> vbs = s.getUseAndDefBoxes();
							Iterator iter = vbs.iterator();
							while(iter.hasNext()){
								ValueBox vb = (ValueBox)iter.next();
								if(vb.getValue() instanceof InstanceFieldRef){
									SootField instanceField = ((InstanceFieldRef)vb.getValue()).getField();

									if(instanceField.getDeclaringClass().isApplicationClass() == false){
										continue;
									}

									if(instanceField.getDeclaringClass().isPhantom()){
										continue;
									}

									//if(!instanceFields.contains(instanceField)){
									//	instanceFields.add(instanceField);
									//}
									////								
									if(!instanceFieldMap.containsKey(instanceField)){						

										Vector<Integer> taintSources = new Vector<Integer>();
										taintSources.addAll(labels);							
										instanceFieldMap.put(instanceField, taintSources);
										
									}else{
										
										Vector<Integer> taintSources = instanceFieldMap.get(instanceField);
										for(Integer label : labels){
											if(!taintSources.contains(label)){
												taintSources.add(label);
											}
										}
									}
									////
									
									LinkedHashMap<String, List<String>> taintSourceToField = new LinkedHashMap<String, List<String>>();
									List<String> fieldList = new ArrayList<String>();
									if(fieldList.contains(instanceField.getSignature())){
										fieldList.add(instanceField.getSignature());
									}								
									taintSourceToField.put(leakSource, fieldList);
									classToSourceToField.put(sMethod.getDeclaringClass().getName(), taintSourceToField);
									
								}else if(vb.getValue() instanceof StaticFieldRef){
									SootField staticField = ((StaticFieldRef)vb.getValue()).getField();

									if(staticField.getDeclaringClass().isApplicationClass() == false){
										continue;
									}

									if(staticField.getDeclaringClass().isPhantom()){
										continue;
									}

									//if(!staticFields.contains(staticField)){
									//	staticFields.add(staticField);
									//}
									///
									if(!staticFieldMap.containsKey(staticField)){						

										Vector<Integer> taintSources = new Vector<Integer>();
										taintSources.addAll(labels);
										staticFieldMap.put(staticField, taintSources);
										
									}else{
										
										Vector<Integer> taintSources = staticFieldMap.get(staticField);
										for(Integer label : labels){
											if(!taintSources.contains(label)){
												taintSources.add(label);
											}
										}
									}
									///
									
									LinkedHashMap<String, List<String>> taintSourceToField = new LinkedHashMap<String, List<String>>();
									List<String> fieldList = new ArrayList<String>();
									if(fieldList.contains(staticField.getSignature())){
										fieldList.add(staticField.getSignature());
									}								
									taintSourceToField.put(leakSource, fieldList);
									classToSourceToField.put(sMethod.getDeclaringClass().getName(), taintSourceToField);
									
								}else if(vb.getValue() instanceof Local){
									
									String varName = ((Local)vb.getValue()).getName();								
									LinkedHashMap<String, List<String>> taintSourceToVar = new LinkedHashMap<String, List<String>>();
									List<String> varList = new ArrayList<String>();
									if(varList.contains(varName)){
										varList.add(varName);
									}								
									taintSourceToVar.put(leakSource, varList);
									methodToSourceToVar.put(sMethod.getSignature(), taintSourceToVar);
								}
							}
						}

					}

					if(!MyConstants.COUNT_LOC){
						if(DATAFLOW==true){
							System.out.println("end dataflow for " + source + "\n");
						}
					}

				}//while(!worklist.isEmpty())


			}//end while(!fWorklist.isEmpty())

			CallGraphTransformer.taintedStaticFields.addAll(taintedStaticFields);

			/*
			for(SootField f : instanceFields){
				//addTaintField(f);
				if(!usedInstanceFields.contains(f)){
					usedInstanceFields.add(f);
				}
			}

			for(SootField f : staticFields){
				//addTaintField(f);
				if(!usedStaticFields.contains(f)){
					usedStaticFields.add(f);
				}
			}
			*/
			
			Set<SootField> instanceKeySet = instanceFieldMap.keySet();
			Iterator<SootField> instanceIter = instanceKeySet.iterator();
			while(instanceIter.hasNext()){
				SootField f = instanceIter.next();
				Vector<Integer> newLabels = instanceFieldMap.get(f);
				
				if(usedInstanceFieldMap.containsKey(f)){
					Vector<Integer> oldLabels = usedInstanceFieldMap.get(f);
					for(Integer label : newLabels){
						if(!oldLabels.contains(label)){
							oldLabels.add(label);
						}
					}
				}else{
					Vector<Integer> labels = new Vector<Integer>();
					labels.addAll(newLabels);
					usedInstanceFieldMap.put(f, labels);
				}
			}
			
			Set<SootField> staticKeySet = staticFieldMap.keySet();
			Iterator<SootField> staticIter = staticKeySet.iterator();
			while(staticIter.hasNext()){
				SootField f = staticIter.next();
				Vector<Integer> newLabels = staticFieldMap.get(f);
				
				if(usedStaticFieldMap.containsKey(f)){
					Vector<Integer> oldLabels = usedStaticFieldMap.get(f);
					for(Integer label : newLabels){
						if(!oldLabels.contains(label)){
							oldLabels.add(label);
						}
					}
				}else{
					Vector<Integer> labels = new Vector<Integer>();
					labels.addAll(newLabels);
					usedStaticFieldMap.put(f, labels);
				}
			}
			
		}
	}

	private void addTaintFields(){
		
		Set<SootField> instanceKeySet = usedInstanceFieldMap.keySet();
		Iterator<SootField> instanceIter = instanceKeySet.iterator();
		while(instanceIter.hasNext()){
			SootField f = instanceIter.next();
			Vector<Integer> labels = usedInstanceFieldMap.get(f);
			addTaintField(f, labels);
		}
		
		Set<SootField> staticKeySet = usedStaticFieldMap.keySet();
		Iterator<SootField> staticIter = staticKeySet.iterator();
		while(staticIter.hasNext()){
			SootField f = staticIter.next();
			Vector<Integer> labels = usedStaticFieldMap.get(f);
			addTaintField(f, labels);
		}
	}
	
	private void dumpReachingDefs(MyReachingDefinition mrd, JimpleBody body){
		
		//System.out.println("MRD: " + body.getMethod());
		
		Iterator it = body.getUnits().iterator();
		while (it.hasNext()) {
			Stmt s = (Stmt) it.next();
			System.out.println(s);
			
			Iterator usesIt = s.getUseBoxes().iterator();
			while (usesIt.hasNext()) {
				ValueBox vbox = (ValueBox) usesIt.next();
				if (vbox.getValue() instanceof Local) {
					Local l = (Local) vbox.getValue();
					System.out.print(l + " : ");

					Iterator rDefsIt = mrd.getDefsOfAt(l, s).iterator();
					while(rDefsIt.hasNext()){
						Stmt def = (Stmt)rDefsIt.next();
						System.out.print(def);
						if(rDefsIt.hasNext())
							System.out.print(" | ");						
					}
					
					System.out.println();
				}
			}
			
			System.out.println();
		}
	}
	
	
	private Vector<Integer> propagate(SootMethod sMethod, Vector<Integer> taintIndexes, String leakSource){
		
		if(callString.contains(sMethod)){
			
			if(MyConstants.DEBUG_INFO)
				System.out.println("RECURSIVE call found, return null");
			return null;
		}
			
		TaintTag taintTag = taintTagMap.get(leakSource);
		TaintTag extraDefTag = extraDefTagMap.get(leakSource);
		
		callString.push(sMethod);			
		
		if(!MyConstants.COUNT_LOC){
			if(DATAFLOW==true)
				System.out.println("step into method: " + sMethod + "|taintIndexes: " + taintIndexes + "\n");
		}
		
		if(sMethod.getSignature().equals("<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>")){
			System.out.println("REFLECTION on path");			
		}else if(sMethod.isNative() && sMethod.getDeclaringClass().isApplicationClass()){
			System.out.println("NATIVE on path");			
		}
		
		/*
		if(!sMethod.isConcrete()){
			
			System.out.println("method is NOT CONCRETE!");
			callString.pop();
			return null;
		}
		*/
		
		//List<SootField> instanceFields = new ArrayList<SootField>();
		//List<SootField> staticFields = new ArrayList<SootField>();
		
		LinkedHashMap<SootField, Vector<Integer>> instanceFieldMap = new LinkedHashMap<SootField, Vector<Integer>>();
		LinkedHashMap<SootField, Vector<Integer>> staticFieldMap = new LinkedHashMap<SootField, Vector<Integer>>();
		
		List<SootField> taintedStaticFields = new ArrayList<SootField>();
		taintedStaticFields.addAll(CallGraphTransformer.taintedFieldsInCaller);
		CallGraphTransformer.taintedFieldsInCaller.clear();
		
		Vector<Integer> taintResult = new Vector<Integer>();
		
		//function summaries would be inserted here
		if(sMethod.getDeclaringClass().isApplicationClass()==false || (!sMethod.isConcrete())){
			
			if(MyConstants.DEBUG_INFO)
				System.out.println(sMethod + " is not declared in an application class");
			
			if(MyConstants.DEBUG_INFO)
				System.out.println("CHECK if " + sMethod.getSignature() + " has a function summary?");
			LinkedHashMap<Integer, List<Integer>> result = AndroidFunctionSummary.lookupFunctionSummary(sMethod.getSignature());
			if(result==null){
				
				if(MyConstants.DEBUG_INFO)
					System.out.println(sMethod.getSignature() + " has NO function summary");
				if(sMethod.getReturnType().equals(VoidType.v())){
					
					if(MyConstants.DEBUG_INFO)
						System.out.println(sMethod.getSignature() + " has NO return value as well");
					callString.pop();
					return null;
					
				}else{
					
					if(MyConstants.DEBUG_INFO)
						System.out.println(sMethod.getSignature() + " luckily has a RETURN value");
					taintResult.add(new Integer(MyConstants.returnValue));
					callString.pop();
					return taintResult;
				}
			}else{
				
				if(MyConstants.DEBUG_INFO)
					System.out.println(sMethod.getSignature() + " HAS function SUMMARY");
				Set<Integer> sources = result.keySet();
				Iterator iterSources = sources.iterator();
				while(iterSources.hasNext()){
					Integer source = (Integer)iterSources.next();
					List<Integer> dests = result.get(source);
					if(taintIndexes.contains(source)){
						for(Integer dest:dests){
							if(!taintResult.contains(dest)){
								taintResult.add(dest);
							}
						}
					}
				}
				
				if(MyConstants.DEBUG_INFO)
					System.out.println("function summary tells which ones are tainted: " + taintResult);
				callString.pop();
				return taintResult;
			}
			
			
		}
		
		//System.out.println("step into method: " + sMethod + "|taintIndexes: " + taintIndexes + "\n");
		
		boolean hasEquivTable = false;
		
		LinkedHashMap<Stmt, List<Stmt>> equivTable = null;
		if(methodToEquiv.containsKey(sMethod)){
			hasEquivTable = true;
			equivTable = methodToEquiv.get(sMethod);
		}
		
		Stmt source = null;
		//Vector<Stmt> defs = new Vector<Stmt>();
		//Stack<Stmt> defsStack = new Stack<Stmt>();
		
		//Vector<DefWithScope> defs = new Vector<DefWithScope>();
		LinkedHashMap<Stmt, Vector<Stmt>> defs = new LinkedHashMap<Stmt, Vector<Stmt>>();		
		
		Stack<DefWithScope> defsStack = new Stack<DefWithScope>();
		
		//Vector<Stmt> taintedRefDefs = new Vector<Stmt>();
		Vector<DefWithScope> taintedRefDefs = new Vector<DefWithScope>();

		JimpleBody body = (JimpleBody) sMethod.retrieveActiveBody();

		{
			Iterator it = body.getUnits().iterator();
			while (it.hasNext()) {
				Stmt s = (Stmt) it.next();
				if (s instanceof IdentityStmt) {
					List<ValueBox> vBoxes = ((IdentityStmt) s).getUseBoxes();
					Iterator iBox = vBoxes.iterator();
					while (iBox.hasNext()) {
						ValueBox vBox = (ValueBox) iBox.next();
						if (vBox.getValue() instanceof ParameterRef) {

							if (taintIndexes.contains(new Integer(((ParameterRef) vBox.getValue()).getIndex()))) {

								DefWithScope sWS = new DefWithScope(s);
								if (!defs.containsKey(s)) {
									defs.put(s, new Vector<Stmt>());
									defsStack.push(sWS);
									if(MyConstants.DEBUG_INFO)
										System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
									source = s;
								}
								
							}

						}else if(vBox.getValue() instanceof ThisRef){
							if(taintIndexes.contains(new Integer(MyConstants.thisObject))){
								
								DefWithScope sWS = new DefWithScope(s);
								if (!defs.containsKey(s)) {
									defs.put(s, new Vector<Stmt>());
									defsStack.push(sWS);
									if(MyConstants.DEBUG_INFO)
										System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
									source = s;
								}
							}
						}
					}
				}
			}
		}

		if (defs.isEmpty()) {
			callString.pop();
			return null;
		}

		ExceptionalUnitGraph eug = new ExceptionalUnitGraph(body);

		/*
		if(CFG==true){
			System.out.println("BEGIN [CFG] - " + sMethod + "\n");
			System.out.println(eug.toString());
			System.out.println("END [CFG]");
		}
		*/

		MyReachingDefinition mrd = new MyReachingDefinition(eug);
		
		/*
		if(REACH_DEF){
			System.out.println("BEGIN [Reaching Definition Analysis] - " + sMethod + "\n");
			dumpReachingDefs(mrd, body);
			System.out.println("END [Reaching Definition Analysis]");
		}
		*/
		
		while(!defsStack.isEmpty()){

			DefWithScope defWS = defsStack.pop();
			System.out.println("POP from def stack: " + defWS.dump());
						
			if(hasEquivTable){
				
				if(equivTable.containsKey(defWS.getDef())){
					if(MyConstants.DEBUG_INFO)
						System.out.println(sMethod + "has equivTable: " + equivTable);
					List<Stmt> equivs = equivTable.get(defWS.getDef());
					
					if(MyConstants.DEBUG_INFO)
						System.out.println("EQUIV found: " + defWS.getDef() + "|" + equivs);
					
					for(Stmt equiv : equivs){
						DefWithScope equivWS = new DefWithScope(equiv);
						if (!defs.containsKey(equiv)) {
							defs.put(equiv, new Vector<Stmt>());
							defsStack.push(equivWS);
							if(MyConstants.DEBUG_INFO)
								System.out.println("def stack doesn't contain " + equivWS.dump() + ". Push it.");
						}
					}
				}
			}

			Iterator it = body.getUnits().iterator();
			while (it.hasNext()) {
				Stmt s = (Stmt) it.next();
				
				//if current statement is not within the scope of the new definition, continue to next statement.
				/*
				if(defWS.getScopeBegin()!=null){						
					if(eug.getExtendedBasicBlockPathBetween(defWS.getScopeBegin(), s)!=null){
						if(MyConstants.DEBUG_INFO){
							System.out.println(s + " is NOT in the scope: " + defWS.getScopeBegin());
						}
						continue;
					}
				}
				*/
				if(defWS.getScopeBegin()!=null){
					if(!isInScope(eug, s, defWS.getScopeBegin())){
						if(MyConstants.DEBUG_INFO){
							System.out.println(s + " is NOT in the scope: " + defWS.getScopeBegin());
						}
						continue;
					}
				}
				
				Iterator usesIt = s.getUseBoxes().iterator();
				while (usesIt.hasNext()) {
					ValueBox vbox = (ValueBox) usesIt.next();
					if (vbox.getValue() instanceof Local) {
						Local l = (Local) vbox.getValue();

						Iterator rDefsIt = mrd.getDefsOfAt(l, s).iterator();
						while (rDefsIt.hasNext()) {
							Stmt next = (Stmt) rDefsIt.next();
							
							if(next == defWS.getDef()){

								if (s instanceof InvokeStmt) {

									Vector<Integer> taintVector = new Vector<Integer>();
									
									Iterator defIt2 = next.getDefBoxes().iterator();
									while (defIt2.hasNext()) {
										ValueBox vbox2 = (ValueBox) defIt2.next();
										if (vbox2.getValue() instanceof Local) {
											InvokeExpr invokeEx = s.getInvokeExpr();
											int argCount = invokeEx.getArgCount();
											for (int i = 0; i < argCount; i++) {
												if (invokeEx.getArg(i) == vbox2.getValue()) {
													taintVector.add(new Integer(i));
												}
											}
											
											if(invokeEx instanceof InstanceInvokeExpr){
												
												if(((InstanceInvokeExpr) invokeEx).getBase() == vbox2.getValue()){
													
													if(invokeEx instanceof SpecialInvokeExpr){
														if(next instanceof DefinitionStmt){
															Value rhs = ((DefinitionStmt) next).getRightOp();
															if(rhs instanceof NewExpr){
																continue;
															}
														}
													}
													
													taintVector.add(new Integer(MyConstants.thisObject));
												}
											}
										}
									}
									
									
									if(taintVector.isEmpty()){
										
										if(MyConstants.DEBUG_INFO)
											System.out.println("No parameters: " + s);
										continue;
									}
									
									if(sinks.contains(s.getInvokeExpr().getMethod().getSignature())){
										
										//DefWithScope sWS = new DefWithScope(s);
										if (!defs.containsKey(s)) {
											defs.put(s, new Vector<Stmt>());
										}
										
										if(taintVector.contains(new Integer(0))
												|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
											
											//if(!MyConstants.COUNT_LOC){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());
											//}
											continue;
										}else if(taintVector.contains(new Integer(3))
												&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
											System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

											continue;
										}else if(taintVector.contains(new Integer(2))
												&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
											System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

											continue;
										}else if(taintVector.contains(new Integer(2))
												&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
											System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

											continue;
										}else if(taintVector.contains(new Integer(2))
												&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
											System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

											continue;
										}
										else{
											if(MyConstants.DEBUG_INFO)
												System.out.println(s.getInvokeExpr().getMethod()
													+ " found, but tainted index is " + taintVector);
										}
										
									}

									Iterator targets = new Targets(this.cg.edgesOutOf(s));
									
									if(!targets.hasNext()){
										
										if(MyConstants.DEBUG_INFO)
											System.out.println(s + " does NOT have a target. add a DEFAULT one");
										List<SootMethod> defaultTargets = new ArrayList<SootMethod>();
										defaultTargets.add(s.getInvokeExpr().getMethod());
										targets = defaultTargets.iterator();
									}
									
									while (targets.hasNext()) {
										SootMethod target = (SootMethod) targets.next();
										
										//if(MyConstants.DEBUG_INFO)
										
										if(!MyConstants.COUNT_LOC){
											if(DATAFLOW==true)
												System.out.println("call target is " + target);
										}
										// check for sink
										if(sinks.contains(target.getSignature())){
											if(taintVector.contains(new Integer(0))
													|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
												
												//if(!MyConstants.COUNT_LOC){
													System.out.println("SINK found in " + sMethod + " : " + target);
												//}
												continue;
											}else if(taintVector.contains(new Integer(3))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}else if(taintVector.contains(new Integer(2))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}else if(taintVector.contains(new Integer(2))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}else if(taintVector.contains(new Integer(2))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}
											else{
												if(MyConstants.DEBUG_INFO)
													System.out.println(target + " found, but tainted index is " + taintVector);
											}
											
											DefWithScope sWS = new DefWithScope(s);
											if (!defs.containsKey(s)) {
												defs.put(s, new Vector<Stmt>());
											}

										} else {

											boolean noNewTaint = true;
											if(!propagationHistory.containsKey(sMethod.getSignature()+"|"+s.toString())){
												
												noNewTaint = false;
												List<Integer> sources = new ArrayList<Integer>();
												sources.addAll(taintVector);
												propagationHistory.put(sMethod.getSignature()+"|"+s.toString(), sources);
											}else{
												List<Integer> sources = propagationHistory.get(sMethod.getSignature()+"|"+s.toString());
												
												for(Integer taint : taintVector){
													if(!sources.contains(taint)){
														noNewTaint = false;
														sources.add(taint);
													}
												}
												
											}
											
											DefWithScope sWS = new DefWithScope(s);
											if (!defs.containsKey(s)) {
												defs.put(s, new Vector<Stmt>());
												defsStack.push(sWS);
												if(MyConstants.DEBUG_INFO)
													System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
											}else{
												if(noNewTaint){
													break;
												}
											}

											if(!MyConstants.COUNT_LOC){
												if(DATAFLOW==true){
													System.out.println("PROPAGATING from METHOD: " + sMethod);
													System.out.println("PROPAGATING from STATEMENT: " + s);
												}
											}
											
											CallGraphTransformer.taintedFieldsInCaller.addAll(taintedStaticFields);
											Vector<Integer> tainted = propagate(target, taintVector, leakSource);
											for(SootField sf : CallGraphTransformer.taintedFieldsInCallee){
												if(!taintedStaticFields.contains(sf)){
													taintedStaticFields.add(sf);
												}
											}
											CallGraphTransformer.taintedFieldsInCallee.clear();
											
											if(!MyConstants.COUNT_LOC){
												if(DATAFLOW==true)
													System.out.println(s + " |taint:" + taintVector + "| PROPAGATION result: " + tainted);
											}
											if ((tainted!=null) && (!tainted.isEmpty())) {
												
												for(Integer i : tainted){
													int index = i.intValue();
													
													if(index == MyConstants.returnValue){
														if(s instanceof DefinitionStmt){
															Value taintedRet = ((DefinitionStmt) s).getLeftOp();
															if(taintedRet instanceof Local){
																if (!defs.containsKey(s)) {
																	
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("adding def of return value:" + s);
																	
																	defs.put(s, new Vector<Stmt>());
																	defsStack.push(sWS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
																}
															}
														}
														
													}else if(index == MyConstants.thisObject){
														if(s.getInvokeExpr() instanceof InstanceInvokeExpr){
															Value taintedThisRef = ((InstanceInvokeExpr)s.getInvokeExpr()).getBase();
															
															boolean hasDef = false;
															Stmt def0 = s;
															if(taintedThisRef instanceof Local){
																List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedThisRef, def0);
																if(defs0.size()==1){
																	def0 = (Stmt)defs0.get(0);
																	hasDef = true;
																	
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																}else{
																	//not very good solution :(
																	for(Unit defn : defs0){
																		
																		DefWithScope defnWS = new DefWithScope((Stmt)defn, s);
																		if(!defs.containsKey(defn)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put((Stmt)defn, scopes);
																			defsStack.push(defnWS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																		}else if(!(defs.get(defn).contains(s))){
																			defs.get(defn).add(s);
																			defsStack.push(defnWS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																		}
																	}
																}
															}
															
															while(hasDef){
																
																if(def0 instanceof DefinitionStmt){
																	Value lhs = ((DefinitionStmt) def0).getLeftOp();
																	Value rhs = ((DefinitionStmt) def0).getRightOp();
																	
																	if(rhs instanceof InstanceFieldRef){
																		
																		if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																			if(!taintedStaticFields.contains(def0)){
																				taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																			}
																		}
																		
																		Value base = ((InstanceFieldRef) rhs).getBase();
																		if(base instanceof Local){
																			List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																			if(defs0.size()==1){
																				def0 = (Stmt)defs0.get(0);
																				
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																			}else{
																				hasDef = false;
																			}
																			
																		}else{
																			hasDef = false;
																		}
																		
																	
																	}else if(rhs instanceof ArrayRef){
																		Value base = ((ArrayRef) rhs).getBase();
																		if(base instanceof Local){
																			List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																			if(defs0.size()==1){
																				def0 = (Stmt)defs0.get(0);
																				
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																			}else{
																				hasDef = false;
																			}
																			
																		}else{
																			hasDef = false;
																		}
																	}
																	else if(rhs instanceof StaticFieldRef){
																		
																		if(!taintedStaticFields.contains(def0)){
																			taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																		}
																		
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}
																	
																	
																	else if(rhs instanceof NewExpr){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}else if(rhs instanceof NewArrayExpr){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}else if(rhs instanceof ThisRef){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}else if(rhs instanceof ParameterRef){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}else if(rhs instanceof InstanceInvokeExpr){
																		if(((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																				"<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>")
																				|| ((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																						"<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>")){
																			Value base = ((InstanceInvokeExpr) rhs).getBase();
																			if(base instanceof Local){
																				List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																				if(defs0.size()==1){
																					def0 = (Stmt)defs0.get(0);
																					
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																				}else{
																					hasDef = false;
																				}
																			}else{
																				hasDef = false;
																			}
																		}else{
																			hasDef = false;
																		}
																	}
																	
																	else{
																		hasDef = false;
																	}
																	
																}else{
																	hasDef = false;
																}
															}//end while(hasDef){
															/*
															if(taintedThisRef instanceof Local){
																List<Unit> thisRefDefs = mrd.getDefsOfAt((Local)taintedThisRef, s);
																for(Unit thisRefDef : thisRefDefs){
																	if((!taintedRefDefs.contains((Stmt)thisRefDef))
																			&& (!defs.contains((Stmt)thisRefDef))){
																		taintedRefDefs.add((Stmt)thisRefDef);
																		//deltaTaintedRefDefs.add((Stmt)thisRefDef);
																		defsStack.push((Stmt)thisRefDef);
																	}
																}
															}	
															*/														
														}														 
														
													}else if(index >= 0){
													
														Value taintedArg = s.getInvokeExpr().getArg(index);
														
														boolean hasDef = false;
														Stmt def0 = s;
														if(taintedArg instanceof Local && taintedArg.getType() instanceof RefLikeType){
															List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedArg, def0);
															if(defs0.size()==1){
																def0 = (Stmt)defs0.get(0);
																hasDef = true;
																
																DefWithScope def0WS = new DefWithScope(def0, s);
																if(!defs.containsKey(def0)){
																	Vector<Stmt> scopes = new Vector<Stmt>();
																	scopes.add(s);
																	defs.put(def0, scopes);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}else if(!(defs.get(def0).contains(s))){
																	defs.get(def0).add(s);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}
															}
														}
														
														while(hasDef){
															
															if(def0 instanceof DefinitionStmt){
																Value lhs = ((DefinitionStmt) def0).getLeftOp();
																Value rhs = ((DefinitionStmt) def0).getRightOp();
																
																if(rhs instanceof InstanceFieldRef){
																	
																	if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																		if(!taintedStaticFields.contains(def0)){
																			taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																		}
																	}
																	
																	//System.out.print("instance field expression: " + def0);
																	Value base = ((InstanceFieldRef) rhs).getBase();
																	if(base instanceof Local){
																		List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																		if(defs0.size()==1){
																			def0 = (Stmt)defs0.get(0);
																			
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																		}else{
																			hasDef = false;
																		}
																		
																	}else{
																		hasDef = false;
																	}
																	
																
																}else if(rhs instanceof ArrayRef){
																	Value base = ((ArrayRef) rhs).getBase();
																	if(base instanceof Local){
																		List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																		if(defs0.size()==1){
																			def0 = (Stmt)defs0.get(0);
																			
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																		}else{
																			hasDef = false;
																		}
																		
																	}else{
																		hasDef = false;
																	}
																}
																else if(rhs instanceof StaticFieldRef){
																	
																	if(!taintedStaticFields.contains(def0)){
																		taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																	}
																	
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}
																
																
																else if(rhs instanceof NewExpr){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}else if(rhs instanceof NewArrayExpr){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}else if(rhs instanceof ThisRef){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}else if(rhs instanceof ParameterRef){
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																	hasDef = false;
																}
																
																else{
																	hasDef = false;
																}
																
															}else{
																hasDef = false;
															}
														}//end while(hasDef){
														/*
														if(taintedArg instanceof Local){
															Type type = taintedArg.getType();
															if(type instanceof RefLikeType){
																List<Unit> argRefDefs = mrd.getDefsOfAt((Local)taintedArg, s);
																for(Unit argRefDef : argRefDefs){
																	if((!taintedRefDefs.contains((Stmt)argRefDef))
																			&& (!defs.contains((Stmt)argRefDef))){
																		taintedRefDefs.add((Stmt)argRefDef);
																		//deltaTaintedRefDefs.add((Stmt)argRefDef);
																		defsStack.push((Stmt)argRefDef);
																	}
																}
															}
														}
														*/
													}
												}
											}
										}
									}


								} else {

									boolean isInvoke = false;

									Iterator iUse = s.getUseBoxes().iterator();
									while (iUse.hasNext()) {
										ValueBox vB = (ValueBox) iUse.next();
										if (vB.getValue() instanceof InvokeExpr) {
											isInvoke = true;
										}
									}

									if (isInvoke) {
										
										if(MyConstants.DEBUG_INFO)
											System.out.println("s is Invoke: " + s);

										Vector<Integer> taintVector = new Vector<Integer>();
										
										Iterator defIt2 = next.getDefBoxes().iterator();
										while (defIt2.hasNext()) {
											ValueBox vbox2 = (ValueBox) defIt2.next();
											if (vbox2.getValue() instanceof Local) {
												InvokeExpr invokeEx = s.getInvokeExpr();
												int argCount = invokeEx.getArgCount();
												for (int i = 0; i < argCount; i++) {
													if (invokeEx.getArg(i) == vbox2.getValue()) {
														taintVector.add(new Integer(i));
													}
												}
												
												if(invokeEx instanceof InstanceInvokeExpr){
													
													if(((InstanceInvokeExpr) invokeEx).getBase() == vbox2.getValue()){
														
														if(invokeEx instanceof SpecialInvokeExpr){
															if(next instanceof DefinitionStmt){
																Value rhs = ((DefinitionStmt) next).getRightOp();
																if(rhs instanceof NewExpr){
																	continue;
																}
															}
														}
														
														taintVector.add(new Integer(MyConstants.thisObject));
													}
												}
											}
										}

										

										if(taintVector.isEmpty()){
											if(MyConstants.DEBUG_INFO)
												System.out.println("No parameters: " + s);
											continue;
										}
										
										if(sinks.contains(s.getInvokeExpr().getMethod().getSignature())){
											
											//DefWithScope sWS = new DefWithScope(s);
											if (!defs.containsKey(s)) {
												defs.put(s, new Vector<Stmt>());
											}
											
											if(taintVector.contains(new Integer(0))
													|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
												
												//if(!MyConstants.COUNT_LOC){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());
												//}
												continue;
											}else if(taintVector.contains(new Integer(3))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}else if(taintVector.contains(new Integer(2))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}else if(taintVector.contains(new Integer(2))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}else if(taintVector.contains(new Integer(2))
													&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
												System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

												continue;
											}
											else{
												if(MyConstants.DEBUG_INFO)
													System.out.println(s.getInvokeExpr().getMethod() 
														+ " found, but tainted index is " + taintVector);
											}
											
										}

										Iterator targets = new Targets(this.cg.edgesOutOf(s));
										
										if(!targets.hasNext()){
											
											if(MyConstants.DEBUG_INFO)
												System.out.println(s + " does NOT have a target. add a DEFAULT one");
											List<SootMethod> defaultTargets = new ArrayList<SootMethod>();
											defaultTargets.add(s.getInvokeExpr().getMethod());
											targets = defaultTargets.iterator();
										}
										
										while (targets.hasNext()) {
											SootMethod target = (SootMethod) targets.next();
											//if(MyConstants.DEBUG_INFO)
											
											if(!MyConstants.COUNT_LOC){
												if(DATAFLOW==true)
													System.out.println("call target is " + target);
											}
											// check for sink
											if(sinks.contains(target.getSignature())){
												if(taintVector.contains(new Integer(0))
														|| (s.getInvokeExpr().getMethod().getSignature().equals("<java.net.URL: java.net.URLConnection openConnection()>"))){
													
													//if(!MyConstants.COUNT_LOC){
														System.out.println("SINK found in " + sMethod + " : " + target);
													//}
													continue;
												}else if(taintVector.contains(new Integer(3))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}else if(taintVector.contains(new Integer(2))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}else if(taintVector.contains(new Integer(2))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteQueryBuilder: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}else if(taintVector.contains(new Integer(2))
														&& (s.getInvokeExpr().getMethod().getSignature().equals("<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>"))){
													System.out.println("SINK found in " + sMethod + " : " + s.getInvokeExpr().getMethod());

													continue;
												}
												else{
													if(MyConstants.DEBUG_INFO)
														System.out.println(target + " found, but tainted index is " + taintVector);
												}
												
												//DefWithScope sWS = new DefWithScope(s);
												if (!defs.containsKey(s)) {
													defs.put(s, new Vector<Stmt>());
												}
											} else {

												boolean noNewTaint = true;
												if(!propagationHistory.containsKey(sMethod.getSignature()+"|"+s.toString())){
													
													noNewTaint = false;
													List<Integer> sources = new ArrayList<Integer>();
													sources.addAll(taintVector);
													propagationHistory.put(sMethod.getSignature()+"|"+s.toString(), sources);
												}else{
													List<Integer> sources = propagationHistory.get(sMethod.getSignature()+"|"+s.toString());
													
													for(Integer taint : taintVector){
														if(!sources.contains(taint)){
															noNewTaint = false;
															sources.add(taint);
														}
													}													
												}
												
												DefWithScope sWS = new DefWithScope(s);
												if (!defs.containsKey(s)) {
													defs.put(s, new Vector<Stmt>());
													defsStack.push(sWS);
													if(MyConstants.DEBUG_INFO)
														System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
												}else{
													if(noNewTaint){
														break;
													}
												}

												if(!MyConstants.COUNT_LOC){
													if(DATAFLOW==true){
														System.out.println("PROPAGATING from METHOD: " + sMethod);
														System.out.println("PROPAGATING from STATEMENT: " + s);
													}
												}
												CallGraphTransformer.taintedFieldsInCaller.addAll(taintedStaticFields);
												Vector<Integer> tainted = propagate(target, taintVector, leakSource);
												for(SootField sf : CallGraphTransformer.taintedFieldsInCallee){
													if(!taintedStaticFields.contains(sf)){
														taintedStaticFields.add(sf);
													}
												}
												CallGraphTransformer.taintedFieldsInCallee.clear();
												if(!MyConstants.COUNT_LOC){
													if(DATAFLOW==true)
														System.out.println(s + " |taint:" + taintVector + "| PROPAGATION result: " + tainted);
												}
												if ((tainted!=null) && (!tainted.isEmpty())) {
													
													for(Integer i : tainted){
														int index = i.intValue();
														
														if(index == MyConstants.returnValue){
															if(s instanceof DefinitionStmt){
																Value taintedRet = ((DefinitionStmt) s).getLeftOp();
																if(taintedRet instanceof Local){
																	
																	if (!defs.containsKey(s)) {
																		
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("adding def of return value:" + s);
																		
																		defs.put(s, new Vector<Stmt>());
																		defsStack.push(sWS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
																	}
																}
															}
															
														}else if(index == MyConstants.thisObject){
															if(s.getInvokeExpr() instanceof InstanceInvokeExpr){
																																
																Value taintedThisRef = ((InstanceInvokeExpr)s.getInvokeExpr()).getBase();
																
																boolean hasDef = false;
																Stmt def0 = s;
																if(taintedThisRef instanceof Local){
																	List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedThisRef, def0);
																	if(defs0.size()==1){
																		def0 = (Stmt)defs0.get(0);
																		hasDef = true;
																		
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																	}else{
																		//not very good solution :(
																		for(Unit defn : defs0){
																			
																			DefWithScope defnWS = new DefWithScope((Stmt)defn, s);
																			if(!defs.containsKey(defn)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put((Stmt)defn, scopes);
																				defsStack.push(defnWS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																			}else if(!(defs.get(defn).contains(s))){
																				defs.get(defn).add(s);
																				defsStack.push(defnWS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + defnWS.dump() + ". Push it.");
																			}
																		}
																	}
																}
																
																while(hasDef){																	
																	
																	if(def0 instanceof DefinitionStmt){
																		Value lhs = ((DefinitionStmt) def0).getLeftOp();
																		Value rhs = ((DefinitionStmt) def0).getRightOp();
																		
																		if(rhs instanceof InstanceFieldRef){
																			
																			if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																				if(!taintedStaticFields.contains(def0)){
																					taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																				}
																			}
																			
																			Value base = ((InstanceFieldRef) rhs).getBase();
																			if(base instanceof Local){
																				List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																				if(defs0.size()==1){
																					def0 = (Stmt)defs0.get(0);
																					
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																				}else{
																					hasDef = false;
																				}
																				
																			}else{
																				hasDef = false;
																			}
																			
																		
																		}else if(rhs instanceof ArrayRef){
																			Value base = ((ArrayRef) rhs).getBase();
																			if(base instanceof Local){
																				List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																				if(defs0.size()==1){
																					def0 = (Stmt)defs0.get(0);
																					
																					DefWithScope def0WS = new DefWithScope(def0, s);
																					if(!defs.containsKey(def0)){
																						Vector<Stmt> scopes = new Vector<Stmt>();
																						scopes.add(s);
																						defs.put(def0, scopes);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}else if(!(defs.get(def0).contains(s))){
																						defs.get(def0).add(s);
																						defsStack.push(def0WS);
																						if(MyConstants.DEBUG_INFO)
																							System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																					}
																				}else{
																					hasDef = false;
																				}
																				
																			}else{
																				hasDef = false;
																			}
																		}
																		else if(rhs instanceof StaticFieldRef){
																			
																			if(!taintedStaticFields.contains(def0)){
																				taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																			}
																			
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}
																		
																		
																		else if(rhs instanceof NewExpr){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}else if(rhs instanceof NewArrayExpr){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}else if(rhs instanceof ThisRef){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}else if(rhs instanceof ParameterRef){
																			DefWithScope def0WS = new DefWithScope(def0, s);
																			if(!defs.containsKey(def0)){
																				Vector<Stmt> scopes = new Vector<Stmt>();
																				scopes.add(s);
																				defs.put(def0, scopes);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}else if(!(defs.get(def0).contains(s))){
																				defs.get(def0).add(s);
																				defsStack.push(def0WS);
																				if(MyConstants.DEBUG_INFO)
																					System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																			}
																			hasDef = false;
																		}else if(rhs instanceof InstanceInvokeExpr){
																			if(((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																					"<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>")
																					|| ((InstanceInvokeExpr) rhs).getMethod().getSignature().equals(
																							"<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>")){
																				Value base = ((InstanceInvokeExpr) rhs).getBase();
																				if(base instanceof Local){
																					List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																					if(defs0.size()==1){
																						def0 = (Stmt)defs0.get(0);
																						
																						DefWithScope def0WS = new DefWithScope(def0, s);
																						if(!defs.containsKey(def0)){
																							Vector<Stmt> scopes = new Vector<Stmt>();
																							scopes.add(s);
																							defs.put(def0, scopes);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}else if(!(defs.get(def0).contains(s))){
																							defs.get(def0).add(s);
																							defsStack.push(def0WS);
																							if(MyConstants.DEBUG_INFO)
																								System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																						}
																					}else{
																						hasDef = false;
																					}
																				}else{
																					hasDef = false;
																				}
																			}else{
																				hasDef = false;
																			}
																		}
																		
																		else{
																			hasDef = false;
																		}
																		
																	}else{
																		hasDef = false;
																	}
																}//end while(hasDef){
																/*
																if(taintedThisRef instanceof Local){
																	List<Unit> thisRefDefs = mrd.getDefsOfAt((Local)taintedThisRef, s);
																	for(Unit thisRefDef : thisRefDefs){
																		if((!taintedRefDefs.contains((Stmt)thisRefDef))
																				&& (!defs.contains((Stmt)thisRefDef))){
																			taintedRefDefs.add((Stmt)thisRefDef);
																			//deltaTaintedRefDefs.add((Stmt)thisRefDef);
																			defsStack.push((Stmt)thisRefDef);
																		}
																	}
																}
																*/															
															}														 
															
														}else if(index >= 0){
														
															Value taintedArg = s.getInvokeExpr().getArg(index);
															
															boolean hasDef = false;
															Stmt def0 = s;
															if(taintedArg instanceof Local && taintedArg.getType() instanceof RefLikeType){
																List<Unit> defs0 = mrd.getDefsOfAt((Local)taintedArg, def0);
																if(defs0.size()==1){
																	def0 = (Stmt)defs0.get(0);
																	hasDef = true;
																	
																	DefWithScope def0WS = new DefWithScope(def0, s);
																	if(!defs.containsKey(def0)){
																		Vector<Stmt> scopes = new Vector<Stmt>();
																		scopes.add(s);
																		defs.put(def0, scopes);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}else if(!(defs.get(def0).contains(s))){
																		defs.get(def0).add(s);
																		defsStack.push(def0WS);
																		if(MyConstants.DEBUG_INFO)
																			System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																	}
																}
															}
															
															while(hasDef){																
																
																if(def0 instanceof DefinitionStmt){
																	Value lhs = ((DefinitionStmt) def0).getLeftOp();
																	Value rhs = ((DefinitionStmt) def0).getRightOp();
																	
																	if(rhs instanceof InstanceFieldRef){
																		
																		if(MyConstants.TO_TAINT_INSTANCE_FIELD){
																			if(!taintedStaticFields.contains(def0)){
																				taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
																			}
																		}
																		
																		Value base = ((InstanceFieldRef) rhs).getBase();
																		if(base instanceof Local){
																			List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																			if(defs0.size()==1){
																				def0 = (Stmt)defs0.get(0);
																				
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																			}else{
																				hasDef = false;
																			}
																			
																		}else{
																			hasDef = false;
																		}
																		
																	
																	}else if(rhs instanceof ArrayRef){
																		Value base = ((ArrayRef) rhs).getBase();
																		if(base instanceof Local){
																			List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
																			if(defs0.size()==1){
																				def0 = (Stmt)defs0.get(0);
																				
																				DefWithScope def0WS = new DefWithScope(def0, s);
																				if(!defs.containsKey(def0)){
																					Vector<Stmt> scopes = new Vector<Stmt>();
																					scopes.add(s);
																					defs.put(def0, scopes);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}else if(!(defs.get(def0).contains(s))){
																					defs.get(def0).add(s);
																					defsStack.push(def0WS);
																					if(MyConstants.DEBUG_INFO)
																						System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																				}
																			}else{
																				hasDef = false;
																			}
																			
																		}else{
																			hasDef = false;
																		}
																	}
																	else if(rhs instanceof StaticFieldRef){
																		
																		if(!taintedStaticFields.contains(def0)){
																			taintedStaticFields.add(((StaticFieldRef)rhs).getField());
																		}
																		
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}
																	
																	
																	else if(rhs instanceof NewExpr){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}else if(rhs instanceof NewArrayExpr){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}else if(rhs instanceof ThisRef){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}else if(rhs instanceof ParameterRef){
																		DefWithScope def0WS = new DefWithScope(def0, s);
																		if(!defs.containsKey(def0)){
																			Vector<Stmt> scopes = new Vector<Stmt>();
																			scopes.add(s);
																			defs.put(def0, scopes);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}else if(!(defs.get(def0).contains(s))){
																			defs.get(def0).add(s);
																			defsStack.push(def0WS);
																			if(MyConstants.DEBUG_INFO)
																				System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																		}
																		hasDef = false;
																	}
																	
																	else{
																		hasDef = false;
																	}
																	
																}else{
																	hasDef = false;
																}
															}//end while(hasDef){
															/*
															if(taintedArg instanceof Local){
																Type type = taintedArg.getType();
																if(type instanceof RefLikeType){
																	List<Unit> argRefDefs = mrd.getDefsOfAt((Local)taintedArg, s);
																	for(Unit argRefDef : argRefDefs){
																		if((!taintedRefDefs.contains((Stmt)argRefDef))
																				&& (!defs.contains((Stmt)argRefDef))){
																			taintedRefDefs.add((Stmt)argRefDef);
																			//deltaTaintedRefDefs.add((Stmt)argRefDef);
																			defsStack.push((Stmt)argRefDef);
																		}
																	}
																}
															}
															*/
														}
													}
												}
											}
										}

									} else {
										
										//if the use of l is located on the left-handed side of the assignment, ignore it
										if(s instanceof DefinitionStmt){
											Value lhs = ((DefinitionStmt) s).getLeftOp();
											if(lhs instanceof ArrayRef){
												Value base = ((ArrayRef) lhs).getBase();
												if(base == l){
													continue;
												}
											}else if(lhs instanceof InstanceFieldRef){
												Value base = ((InstanceFieldRef) lhs).getBase();
												if(base == l){
													continue;
												}
											}
										}
										
										DefWithScope sWS = new DefWithScope(s);
										if (!defs.containsKey(s)) {
											defs.put(s, new Vector<Stmt>());
											defsStack.push(sWS);
											if(MyConstants.DEBUG_INFO)
												System.out.println("def stack doesn't contain " + sWS.dump() + ". Push it.");
											
											if(s instanceof DefinitionStmt){
												Value lhs = ((DefinitionStmt) s).getLeftOp();
												
												if(lhs instanceof StaticFieldRef){
													if(!taintedStaticFields.contains(s)){
														taintedStaticFields.add(((StaticFieldRef)lhs).getField());
													}
												}
											}
											
											
											boolean hasDef = false;
											Stmt def0 = s;
											
											
											if(def0 instanceof DefinitionStmt){
												Value lhs = ((DefinitionStmt) def0).getLeftOp();
												//Value rhs = ((DefinitionStmt) s).getRightOp();
												
												/*
												if(lhs instanceof Local){
													List<Unit> defs0 = mrd.getDefsOfAt((Local)lhs, def0);
													if(defs0.size()==1){
														Stmt def1 = (Stmt)defs0.get(0);
														if(def1 instanceof DefinitionStmt){
															Value def1rhs = ((DefinitionStmt) def1).getRightOp();
															if(def1rhs instanceof InstanceFieldRef){
																
																hasDef = true;
																
																if(!defs.contains(def0)){
																	defs.add(def0);
																	delta.add(def0);
																}
																
																if(!defs.contains(def1)){
																	defs.add(def1);
																	delta.add(def1);
																}
																
																def0 = def1;
															}
														}
													}
												}*/
												
												if(lhs instanceof InstanceFieldRef){
													
													if(MyConstants.TO_TAINT_INSTANCE_FIELD){
														if(!taintedStaticFields.contains(def0)){
															taintedStaticFields.add(((InstanceFieldRef)lhs).getField());
														}
													}

													Value base = ((InstanceFieldRef) lhs).getBase();
													if(base instanceof Local){
														List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
														if(defs0.size()==1){
															def0 = (Stmt)defs0.get(0);
															hasDef = true;
															
															DefWithScope def0WS = new DefWithScope(def0, s);
															if(!defs.containsKey(def0)){
																Vector<Stmt> scopes = new Vector<Stmt>();
																scopes.add(s);
																defs.put(def0, scopes);
																defsStack.push(def0WS);
																if(MyConstants.DEBUG_INFO)
																	System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
															}else if(!(defs.get(def0).contains(s))){
																defs.get(def0).add(s);
																defsStack.push(def0WS);
																if(MyConstants.DEBUG_INFO)
																	System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
															}
														}
													}
												}else if(lhs instanceof ArrayRef){
													Value base = ((ArrayRef) lhs).getBase();
													if(base instanceof Local){
														List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
														if(defs0.size()==1){
															def0 = (Stmt)defs0.get(0);
															hasDef = true;
															
															DefWithScope def0WS = new DefWithScope(def0, s);
															if(!defs.containsKey(def0)){
																Vector<Stmt> scopes = new Vector<Stmt>();
																scopes.add(s);
																defs.put(def0, scopes);
																defsStack.push(def0WS);
																if(MyConstants.DEBUG_INFO)
																	System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
															}else if(!(defs.get(def0).contains(s))){
																defs.get(def0).add(s);
																defsStack.push(def0WS);
																if(MyConstants.DEBUG_INFO)
																	System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
															}
														}
													}
												}
											}
											
											while(hasDef){
												
												if(def0 instanceof DefinitionStmt){
													Value lhs = ((DefinitionStmt) def0).getLeftOp();
													Value rhs = ((DefinitionStmt) def0).getRightOp();
													/*
													if(lhs instanceof InstanceFieldRef){
														//System.out.print("instance field expression: " + def0);
														Value base = ((InstanceFieldRef) lhs).getBase();
														if(base instanceof Local){
															List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
															if(defs0.size()==1){
																def0 = (Stmt)defs0.get(0);
																
																if(!defs.contains(def0)){
																	defs.add(def0);
																	delta.add(def0);
																	//System.out.println("both:" + defs + " " + delta);
																}
															}else{
																hasDef = false;
															}
															
														}else{
															hasDef = false;
														}
														
													}else */
													if(rhs instanceof InstanceFieldRef){
														
														if(MyConstants.TO_TAINT_INSTANCE_FIELD){
															if(!taintedStaticFields.contains(def0)){
																taintedStaticFields.add(((InstanceFieldRef)rhs).getField());
															}
														}
														
														Value base = ((InstanceFieldRef) rhs).getBase();
														if(base instanceof Local){
															List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
															if(defs0.size()==1){
																def0 = (Stmt)defs0.get(0);
																
																DefWithScope def0WS = new DefWithScope(def0, s);
																if(!defs.containsKey(def0)){
																	Vector<Stmt> scopes = new Vector<Stmt>();
																	scopes.add(s);
																	defs.put(def0, scopes);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}else if(!(defs.get(def0).contains(s))){
																	defs.get(def0).add(s);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}
															}else{
																hasDef = false;
															}
															
														}else{
															hasDef = false;
														}
														
													
													}else if(rhs instanceof ArrayRef){
														Value base = ((ArrayRef) rhs).getBase();
														if(base instanceof Local){
															List<Unit> defs0 = mrd.getDefsOfAt((Local)base, def0);
															if(defs0.size()==1){
																def0 = (Stmt)defs0.get(0);
																
																DefWithScope def0WS = new DefWithScope(def0, s);
																if(!defs.containsKey(def0)){
																	Vector<Stmt> scopes = new Vector<Stmt>();
																	scopes.add(s);
																	defs.put(def0, scopes);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}else if(!(defs.get(def0).contains(s))){
																	defs.get(def0).add(s);
																	defsStack.push(def0WS);
																	if(MyConstants.DEBUG_INFO)
																		System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
																}
															}else{
																hasDef = false;
															}
															
														}else{
															hasDef = false;
														}
													}													
													
													else if(rhs instanceof NewExpr){
														DefWithScope def0WS = new DefWithScope(def0, s);
														if(!defs.containsKey(def0)){
															Vector<Stmt> scopes = new Vector<Stmt>();
															scopes.add(s);
															defs.put(def0, scopes);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}else if(!(defs.get(def0).contains(s))){
															defs.get(def0).add(s);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}
														hasDef = false;
													}else if(rhs instanceof NewArrayExpr){
														DefWithScope def0WS = new DefWithScope(def0, s);
														if(!defs.containsKey(def0)){
															Vector<Stmt> scopes = new Vector<Stmt>();
															scopes.add(s);
															defs.put(def0, scopes);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}else if(!(defs.get(def0).contains(s))){
															defs.get(def0).add(s);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}
														hasDef = false;
													}else if(rhs instanceof ThisRef){
														DefWithScope def0WS = new DefWithScope(def0, s);
														if(!defs.containsKey(def0)){
															Vector<Stmt> scopes = new Vector<Stmt>();
															scopes.add(s);
															defs.put(def0, scopes);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}else if(!(defs.get(def0).contains(s))){
															defs.get(def0).add(s);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}
														hasDef = false;
													}else if(rhs instanceof ParameterRef){
														DefWithScope def0WS = new DefWithScope(def0, s);
														if(!defs.containsKey(def0)){
															Vector<Stmt> scopes = new Vector<Stmt>();
															scopes.add(s);
															defs.put(def0, scopes);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}else if(!(defs.get(def0).contains(s))){
															defs.get(def0).add(s);
															defsStack.push(def0WS);
															if(MyConstants.DEBUG_INFO)
																System.out.println("def stack doesn't contain " + def0WS.dump() + ". Push it.");
														}
														hasDef = false;
													}
													
													else{
														hasDef = false;
													}
													
												}else{
													hasDef = false;
												}
											}//end while(hasDef){										
										}
									}
								}
							}
						}
					}
				}
			}// end while(it.hasNext())

		}// end while(!delta.isEmpty())

		
		//////////////////////////
		Iterator i = defs.keySet().iterator();
		while (i.hasNext()) {
			Stmt s = (Stmt) i.next();
			
			if(!s.getTags().contains(generalTaintTag)){
				s.addTag(generalTaintTag);
			}
			
			if (!s.getTags().contains(taintTag)) {
				s.addTag(taintTag);
			}
			
			Iterator usesIt = s.getUseBoxes().iterator();
			while (usesIt.hasNext()) {
				ValueBox vbox = (ValueBox) usesIt.next();
				if (vbox.getValue() instanceof Local) {
					Local l = (Local) vbox.getValue();

					Iterator rDefsIt = mrd.getDefsOfAt(l, s).iterator();
					while (rDefsIt.hasNext()) {
						Stmt next = (Stmt) rDefsIt.next();
						if(!next.getTags().contains(taintTag)){
							
							if(!next.getTags().contains(generalExtraDefTag)){
								next.addTag(generalExtraDefTag);
							}
							
							if(!next.getTags().contains(extraDefTag)){
								next.addTag(extraDefTag);
							}
						}
					}
				}
			}
			
			if (s instanceof ReturnStmt) {
				taintResult.add(new Integer(MyConstants.returnValue));
			}else if(s instanceof IdentityStmt){
				
				Value rhsIdentity = ((IdentityStmt) s).getRightOp();
				if(rhsIdentity instanceof ThisRef){
					if(!taintIndexes.contains(new Integer(MyConstants.thisObject))){
						taintResult.add(new Integer(MyConstants.thisObject));
					}
				}else if(rhsIdentity instanceof ParameterRef){
					int index = ((ParameterRef)rhsIdentity).getIndex();
					if(!taintIndexes.contains(new Integer(index))){
						taintResult.add(new Integer(index));
					}
				}
			}		
		}
		
		if(!MyConstants.COUNT_LOC){
			if(DATAFLOW==true){
				System.out.println();
				System.out.println("method:" + sMethod.getSignature());
				System.out.println("dataflow for " + source + ":");
			}
		}
			
		Iterator printIt = body.getUnits().iterator();
		while(printIt.hasNext()){
			Stmt s = (Stmt)printIt.next();
			if(s.getTags().contains(taintTag) || s.getTags().contains(extraDefTag)){

				if(!MyConstants.COUNT_LOC){
					if(DATAFLOW==true){
						if(MyConstants.DEBUG_INFO){
							System.out.println(s + "|" + s.getTags());
						}else{
							System.out.println(s);
						}
					}
				}
				
				Vector<Integer> labels = new Vector<Integer>();
				
				for(Tag tag : s.getTags()){
					if(taintTagReverseMap.containsKey(tag)){
						Integer label = new Integer(((TaintTag)tag).getLabel());
						if(!labels.contains(label)){
							labels.add(label);
						}
					}else if(extraDefTagReverseMap.containsKey(tag)){
						Integer label = new Integer(((TaintTag)tag).getLabel());
						if(!labels.contains(label)){
							labels.add(label);
						}
					}								
				}
				
				List<ValueBox> vbs = s.getUseAndDefBoxes();
				Iterator iter = vbs.iterator();
				while(iter.hasNext()){
					ValueBox vb = (ValueBox)iter.next();
					if(vb.getValue() instanceof InstanceFieldRef){
						SootField instanceField = ((InstanceFieldRef)vb.getValue()).getField();

						if(instanceField.getDeclaringClass().isApplicationClass() == false){
							continue;
						}

						if(instanceField.getDeclaringClass().isPhantom()){
							continue;
						}

						//if(!instanceFields.contains(instanceField)){
						//	instanceFields.add(instanceField);
						//}
						
						////					
						if(!instanceFieldMap.containsKey(instanceField)){						

							Vector<Integer> taintSources = new Vector<Integer>();
							taintSources.addAll(labels);							
							instanceFieldMap.put(instanceField, taintSources);
							
						}else{
							
							Vector<Integer> taintSources = instanceFieldMap.get(instanceField);
							for(Integer label : labels){
								if(!taintSources.contains(label)){
									taintSources.add(label);
								}
							}
						}
						////
						
						LinkedHashMap<String, List<String>> taintSourceToField = new LinkedHashMap<String, List<String>>();
						List<String> fieldList = new ArrayList<String>();
						if(fieldList.contains(instanceField.getSignature())){
							fieldList.add(instanceField.getSignature());
						}								
						taintSourceToField.put(leakSource, fieldList);
						classToSourceToField.put(sMethod.getDeclaringClass().getName(), taintSourceToField);
						
					}else if(vb.getValue() instanceof StaticFieldRef){
						SootField staticField = ((StaticFieldRef)vb.getValue()).getField();

						if(staticField.getDeclaringClass().isApplicationClass() == false){
							continue;
						}

						if(staticField.getDeclaringClass().isPhantom()){
							continue;
						}

						//if(!staticFields.contains(staticField)){
						//	staticFields.add(staticField);
						//}

						///
						if(!staticFieldMap.containsKey(staticField)){						

							Vector<Integer> taintSources = new Vector<Integer>();
							taintSources.addAll(labels);
							staticFieldMap.put(staticField, taintSources);
							
						}else{
							
							Vector<Integer> taintSources = staticFieldMap.get(staticField);
							for(Integer label : labels){
								if(!taintSources.contains(label)){
									taintSources.add(label);
								}
							}
						}
						///
					
						LinkedHashMap<String, List<String>> taintSourceToField = new LinkedHashMap<String, List<String>>();
						List<String> fieldList = new ArrayList<String>();
						if(fieldList.contains(staticField.getSignature())){
							fieldList.add(staticField.getSignature());
						}								
						taintSourceToField.put(leakSource, fieldList);
						classToSourceToField.put(sMethod.getDeclaringClass().getName(), taintSourceToField);
						
					}else if(vb.getValue() instanceof Local){
						
						String varName = ((Local)vb.getValue()).getName();								
						LinkedHashMap<String, List<String>> taintSourceToVar = new LinkedHashMap<String, List<String>>();
						List<String> varList = new ArrayList<String>();
						if(varList.contains(varName)){
							varList.add(varName);
						}								
						taintSourceToVar.put(leakSource, varList);
						methodToSourceToVar.put(sMethod.getSignature(), taintSourceToVar);
					}
				}
			}
		}

		if(!MyConstants.COUNT_LOC){
			if(DATAFLOW==true){
				System.out.println("end dataflow for " + source + "\n");
			}
		}
		
		/////////////////////////
		CallGraphTransformer.taintedFieldsInCallee.addAll(taintedStaticFields);
		
		/*
		for(SootField f : instanceFields){
			//addTaintField(f);
			if(!usedInstanceFields.contains(f)){
				usedInstanceFields.add(f);
			}
		}
		
		for(SootField f : staticFields){
			//addTaintField(f);
			if(!usedStaticFields.contains(f)){
				usedStaticFields.add(f);
			}
		}
		*/
		
		Set<SootField> instanceKeySet = instanceFieldMap.keySet();
		Iterator<SootField> instanceIter = instanceKeySet.iterator();
		while(instanceIter.hasNext()){
			SootField f = instanceIter.next();
			Vector<Integer> newLabels = instanceFieldMap.get(f);
			
			if(usedInstanceFieldMap.containsKey(f)){
				Vector<Integer> oldLabels = usedInstanceFieldMap.get(f);
				for(Integer label : newLabels){
					if(!oldLabels.contains(label)){
						oldLabels.add(label);
					}
				}
			}else{
				Vector<Integer> labels = new Vector<Integer>();
				labels.addAll(newLabels);
				usedInstanceFieldMap.put(f, labels);
			}
		}
		
		Set<SootField> staticKeySet = staticFieldMap.keySet();
		Iterator<SootField> staticIter = staticKeySet.iterator();
		while(staticIter.hasNext()){
			SootField f = staticIter.next();
			Vector<Integer> newLabels = staticFieldMap.get(f);
			
			if(usedStaticFieldMap.containsKey(f)){
				Vector<Integer> oldLabels = usedStaticFieldMap.get(f);
				for(Integer label : newLabels){
					if(!oldLabels.contains(label)){
						oldLabels.add(label);
					}
				}
			}else{
				Vector<Integer> labels = new Vector<Integer>();
				labels.addAll(newLabels);
				usedStaticFieldMap.put(f, labels);
			}
		}
		
		callString.pop();
		
		return taintResult;
	}
	
	private void uglyFix(String signature){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {

				if(!method.getSignature().equals(signature)){
					continue;
				}
				
				if(!method.isConcrete()){
					System.out.println("Method given is not a concrete one!");
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				List<Stmt> toRemove = new ArrayList<Stmt>();

				Iterator it = body.getUnits().iterator();
				while (it.hasNext()) {
					Stmt s = (Stmt) it.next();
					if(s instanceof IdentityStmt){
						
					}else if(s instanceof ReturnVoidStmt){
						
					}else if(s instanceof ReturnStmt){
						
					}else{
						if(!toRemove.contains(s)){
							toRemove.add(s);
						}
					}
				}
				
				body.getUnits().removeAll(toRemove);
			}
		}
	}
	
	
	private void uglyFix(String signature, Stmt inject){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {

				if(!method.getSignature().equals(signature)){
					continue;
				}
				
				if(!method.isConcrete()){
					System.out.println("Method given is not a concrete one!");
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				body.getUnits().insertBefore(inject, body.getFirstNonIdentityStmt());				
			}
		}
	}
	
	private void uglyFix(String signature, String localName){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}			
			
			if(soot_class.isPhantom()){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {

				if(!method.getSignature().equals(signature)){
					continue;
				}
				
				if(!method.isConcrete()){
					System.out.println("Method given is not a concrete one!");
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				Local local = null;
				Chain<Local> locals = body.getLocals();
				for(Local l : locals){
					if(l.getName().equals(localName)){
						local = l;
					}
				}
				
				if(local!=null){
					Stmt inject = Jimple.v().newAssignStmt(local, IntConstant.v(0));				
					body.getUnits().insertBefore(inject, body.getFirstNonIdentityStmt());
				}
			}
		}
	}
	
	private void uglyFixClass(String signature, String localName){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}			
			
			if(soot_class.isPhantom()){
				continue;
			}

			if(!soot_class.getName().equals(signature)){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				if(!method.isConcrete()){
					System.out.println("Method given is not a concrete one!");
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				Local local = null;
				Chain<Local> locals = body.getLocals();
				for(Local l : locals){
					if(l.getName().equals(localName)){
						local = l;
					}
				}
				
				if(local!=null){
					Stmt inject = Jimple.v().newAssignStmt(local, IntConstant.v(0));				
					body.getUnits().insertBefore(inject, body.getFirstNonIdentityStmt());
				}
			}
		}
	}
	
	private void uglyFixClass(String signature){
		Chain<SootClass> classes = Scene.v().getClasses();
		Iterator<SootClass> classes_iter = classes.iterator();
		while (classes_iter.hasNext()) {
			SootClass soot_class = classes_iter.next();
			
			if (soot_class.isApplicationClass() == false) {
				continue;
			}			
			
			if(soot_class.isPhantom()){
				continue;
			}

			if(!soot_class.getName().equals(signature)){
				continue;
			}

			List<SootMethod> methods = soot_class.getMethods();
			for (SootMethod method : methods) {
				
				if(!method.isConcrete()){
					System.out.println("Method given is not a concrete one!");
					continue;
				}
				
				JimpleBody body = (JimpleBody) method.retrieveActiveBody();
				
				
				Chain<Local> locals = body.getLocals();
				for(Local local : locals){
					if(local.getName().contains("_t") && local.getType().equals(BooleanType.v())){
						Stmt inject = Jimple.v().newAssignStmt(local, IntConstant.v(0));				
						body.getUnits().insertBefore(inject, body.getFirstNonIdentityStmt());
					}else if(local.getName().contains("tmp") && local.getType().equals(BooleanType.v())){
						Stmt inject = Jimple.v().newAssignStmt(local, IntConstant.v(0));				
						body.getUnits().insertBefore(inject, body.getFirstNonIdentityStmt());
					}
				}
				
				
			}
		}
	}

	//private String getTaintVarName(String varName) {
	//	return (varName + "_t");
	//}
	
	private String getTaintVarName(String varName, int label) {
		return (varName + "_s" + label + "_t");
	}
	
	private String getTaintWrapperName(String taintVarName){
		return (taintVarName + "_w");
	}
	
	private String getWrapperMethodName(String methodName, String label){
		return (methodName + "_s" + label + "Wrapper");
	}
	
	private String getWrapperMethodName(String methodName){
		return (methodName + "Wrapper");
	}
	
	private Vector<Integer> decodeLabelString(String label){
		Vector<Integer> labels = new Vector<Integer>();
		String labelString = label.substring(1);
		String[] parts = labelString.split("_");
		for(int i=0;i<parts.length;i++){
			labels.add(new Integer(parts[i]));
		}
		return labels;
	}

	public CallGraph getCallGraph() {
		return this.cg;
	}
	
	private boolean isInScope(ExceptionalUnitGraph eug, Stmt toTest, Stmt scopeBegin){
		
		if(toTest == scopeBegin){
			return false;
		}
				
		Stack<Stmt> successors = new Stack<Stmt>();
		Vector<Stmt> traversedSuccs = new Vector<Stmt>();
		
		successors.push(scopeBegin);
		traversedSuccs.add(scopeBegin);
		
		while(!successors.isEmpty()){
			Stmt successor = successors.pop();
			if(successor == toTest){
				return true;
			}
			List<Unit> succsOfSuccessor = eug.getSuccsOf(successor);
			for(Unit u : succsOfSuccessor){
				Stmt s = (Stmt)u;
				if(!traversedSuccs.contains(s)){
					traversedSuccs.add(s);
					successors.push(s);
				}
			}
		}
		
		return false;
	}

}
